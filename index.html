<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Consistency</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <link rel="apple-touch-icon" href="https://raw.githubusercontent.com/lillyapp/habits/refs/heads/main/3FC2E555-7142-43BE-83DE-E5ED7A123793.png">

      <link rel="manifest" href="/habits/manifest.json">
      
      <meta name="apple-mobile-web-app-capable" content="yes">
      <meta name="mobile-web-app-capable" content="yes">
      
          
  <!-- Lucide -->
  <script src="https://unpkg.com/lucide@latest"></script>
  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- GSAP -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">

  <style>
    :root {
      --page-padding: 16px;
      --card-height: calc((100svh - 16px*5 - 60px - env(safe-area-inset-bottom)) / 3);
    }
      
      :root {
        --c-bg: #ffffff;
        --c-text: #000000;
        --c-card: #e4e4e4;
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --c-bg: #000000;
          --c-text: #e4e4e4;
          --c-card: #1a1a1a;
        }
      }

    * {
      margin:0;
      padding:0;
      box-sizing:border-box;
      user-select:none;
      -webkit-user-select:none;
    }

    body {
      margin:0;
      padding:0;
      font-family: "Poppins", sans-serif;
      background: var(--c-bg);
        color: var(--c-text);
      height:100svh;
      overflow:hidden;
    }
    /* Dark Mode Enhancements */
    .card {
      background: var(--c-card);
      color: var(--c-text);
    }

    .card-face.back {
      background: var(--c-card);
      color: var(--c-text);
    }

    .login-input {
      background: var(--c-card);
      color: var(--c-text);
    }

    #loginScreen {
      background: var(--c-bg);
      color: var(--c-text);
    }

    #statsView {
      background: var(--c-bg);
      color: var(--c-text);
    }

    .stat-bar {
      background: var(--c-card);
    }

    .stat-fill {
      color: var(--c-text);
    }

    #deletePanel {
      background: var(--c-card);
      color: var(--c-text);
    }

    .btn-plus {
      background: none !important;
      border: none !important;
      color: var(--c-text) !important;
    }

    .btn-stats {
      background: none !important;
      border: none !important;
      color: var(--c-text) !important;
    }

    #qrInfoBox {
      color: var(--c-text);
      background: var(--c-card);
    }

    /* LOGIN */
    #loginScreen {
      position:absolute;
      inset:0;
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      padding:20px;
      z-index:20;
      background: var(--c-bg);
      color: var(--c-text);
      opacity:1;
      transition:opacity 0.4s ease;
    }

    @keyframes pulse {
      0% {transform:scale(1);}
      50%{transform:scale(1.06);}
      100%{transform:scale(1);}
    }

    #loginCircle {
      width:30px;
      height:30px;
      background:#000;
      border-radius:50%;
      animation:pulse 2.2s ease-in-out infinite;
    }

    #loginHeadline {
      margin-top:28px;
      font-size:26px;
      font-weight:600;
      text-align:center;
      color: var(--c-text);
    }

    /* rolling-text styles removed */

    #loginButtonBar {
      width:100%;
      max-width:400px;
      display:flex;
      gap:14px;
      margin-top:50px;
    }

    .btn {
      flex:1;
      padding:14px;
      border-radius:20px;
      border:none;
      font-size:17px;
      cursor:pointer;
    }

    #btnLogin    {
      background: var(--c-text);
      color: var(--c-bg);
    }
    #btnRegister {
      background: var(--c-card);
      color: var(--c-text);
    }

    #loginForm {
      width:100%;
      max-width:400px;
      display:none;
      flex-direction:column;
      gap:12px;
      margin-top:30px;
    }

    .login-input {
      padding:12px;
      border:none;
      border-radius:12px;
      background: var(--c-card);
      color: var(--c-text);
    }

    #loginError {
      margin-top:12px;
      color: var(--c-text);
      font-size:14px;
      display:none;
      text-align:center;
    }

    /* MAIN PAGE (Habit-Klötze) */
    #appPage {
      position:absolute;
      inset:0;
      display:none;
      opacity:0;
    }

    .page {
      height:100%;
      display:flex;
      flex-direction:column;
      padding:16px;
      padding-bottom:140px;
      gap:16px;
    }

    .cards {
      flex:1;
      display:flex;
      flex-direction:column;
      gap:16px;
    }

    .slot {
      position:relative;
      min-height:var(--card-height);
      perspective:1200px;
    }

    .card {
      position:absolute;
      inset:0;
      border-radius:24px;
      background: var(--c-card);
      padding:24px;
      transform-style:preserve-3d;
      cursor:pointer;
      opacity:0;
      transition:transform 0.25s linear;
      height:100%;
    }

    .card-face {
      position:absolute;
      inset:0;
      backface-visibility:hidden;
      border-radius:24px;
      padding:24px;
    }

      .card-face.front {
        background:transparent;
        display:flex;
        flex-direction:column;
        justify-content:flex-start;
      }

    .back {
      background: var(--c-card);
      transform:rotateY(180deg);
      display:flex;
      flex-direction:row;
      justify-content:space-between;
      padding:24px;
    }

    .half {
      width:50%;
      display:flex;
      justify-content:center;
      align-items:center;
      font-size:2rem;
      font-weight:800;
      color:#777;
    }
    .quarter {
      width:25%;
      display:flex;
      justify-content:center;
      align-items:center;
      font-size:1.6rem;
      font-weight:800;
      color:#777;
    }

      .card-input {
        width: 100%;
        max-width: calc(100% - 90px);
        font-size: 2rem;
        font-weight: 800;
        border: none;
        background: transparent;
        outline: none;
        color: var(--c-text);
        margin-top: 6px;
        margin-bottom: 0;
        line-height: 1.1;
        white-space: normal;      /* neuer Umbruch */
        word-wrap: break-word;    /* Wörter umbrechen */
        min-height: 2.4rem;       /* Platz für min. 1 Zeile */
      }

      .card-input:empty::before {
        content: attr(data-placeholder);
        color: var(--c-text);
      }

    .counter {
      position: absolute;
      bottom: 24px;
      right: 24px;
      padding: 4px 12px;
      border-radius: 999px;
      font-size: 1.2rem;
      font-weight: 700;
      display: none;

      /* Light Mode */
      background: #ffffff;
      color: #000000;
      border: 2px solid #000000;
    }

    @media (prefers-color-scheme: dark) {
      .counter {
        background: #ffffff !important;
        color: #000000 !important;
        border: 2px solid #000000 !important;
      }
    }

    /* Bottom Buttons (Plus/Haus + Stats) */
    .buttons-row {
      position:fixed;
      left:0;
      right:0;
      bottom:0;
      padding:0 16px calc(16px + env(safe-area-inset-bottom));
      height:calc(60px + env(safe-area-inset-bottom));
      background:transparent; /* Karten bleiben dahinter sichtbar */
      display:flex;
      gap:12px;
      z-index:9999;
      pointer-events:none;
    }

    .btn-half {
      flex:1;
      height:60px;
      border-radius:999px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:1.5rem;
      border:none !important;
      background:none !important;
      box-shadow:none !important;
      outline:none !important;
      cursor:pointer;
      pointer-events:auto;
      color: var(--c-text) !important;
    }


    /* Stats View */
    #statsView {
      position:fixed;
      left:0;
      right:0;
      top:100svh;
      bottom:0;
      background: var(--c-bg);
      padding:24px;
      padding-bottom:140px;
      overflow-y:auto;
      z-index:50;
    }

    .stats-name { font-size:2rem; font-weight:700; margin-bottom:20px; }
    .stat-bar { width:100%; height:48px; background: var(--c-card); border-radius:16px; margin-bottom:18px; overflow:hidden; }
    .stat-fill {
      height:100%;
      width:0;
      padding-left:12px;
      display:flex;
      align-items:center;
      font-weight:700;
      border-radius:16px;
      background: var(--c-card);
      color: var(--c-text);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .stats-reset-wrap {
      display:flex;
      justify-content:center;
      margin-top:36px; /* mehr Abstand zur Progressbar */
      margin-bottom:12px;
    }

    .stats-reset-btn {
      min-width:160px;        /* breit genug für Hinweistext in einer Zeile */
      height:48px;
      padding:0 16px;
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius:14px;
      border:2px solid #ef4444;
      background:transparent;
      color:#ef4444;
      cursor:pointer;
      position:relative;
      overflow:hidden;
      font-size:14px;
      white-space:nowrap;     /* Text bleibt einzeilig */
    }

    /* Blue variant for streak commit */
    .stats-reset-btn.blue {
      border: 2px solid #1d4ed8; /* dark blue */
      color: #1d4ed8;
    }

    .stats-reset-btn.blue .stats-reset-progress {
      background: rgba(29,78,216,0.25);
    }

    .stats-reset-btn.hint {
      font-size:14px;
      font-weight:600;
      padding:0 16px;
      text-align:center;
    }

    .stats-reset-progress {
      position:absolute;
      bottom:0;
      left:0;
      height:100%;
      width:0%;
      background:rgba(239,68,68,0.25);
      z-index:0;
    }

    .stats-reset-btn-content {
      position:relative;
      z-index:1;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      line-height:1.2;
    }

    /* Dünner Delete-Balken über der obersten Karte */
    #deletePanel {
      position:fixed;
      left:16px;
      right:16px;
      top:12px; /* wird per JS genauer über der obersten Karte platziert */
      background: var(--c-card);
      border-radius:999px;
      box-shadow:0 8px 20px rgba(0,0,0,0.12);
      padding:6px 12px;
      display:none;
      align-items:center;
      justify-content:center;
      gap:8px;
      z-index:10000;
      font-size:12px;
    }

    #deletePanelText {
      font-weight:500;
      white-space:nowrap;
    }

    #deleteAllBtn {
      padding:4px 10px;
      border-radius:999px;
      border:1px solid #d4d4d4;
      background:#f3f3f3;
      color:#ef4444;
      font-weight:600;
      font-size:12px;
      cursor:pointer;
      flex-shrink:0;
    }
      
      .front-header {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .expand-area {
        margin-top: 12px;
      }

      .expand-divider {
        width: 100%;
        height: 2px;
        margin: 12px 0;
        opacity: 0.35;
      }

      .subtask {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
      }

      .subtask i {
        width: 22px;
        height: 22px;
        cursor: pointer;
        flex-shrink: 0;
      }

      .subtask i {
        color: inherit;
      }

      .subtask-title {
        font-size: 1.05rem;
        font-weight: 600;
        background: transparent;
        border: none;
        outline: none;
        flex: 1;
        user-select: text;
        -webkit-user-select: text;
        cursor: text;
      }

      /* Make the placeholder inherit a CSS variable set on the input by JS */
      .subtask-title::placeholder {
        color: var(--ph, #666);
        opacity: 0.85;
      }

      .add-subtask {
        margin-top: 8px;
        opacity: 0.6;
        cursor: pointer;
      }

      /* --- Clickable subtask icons fix --- */
      /* --- Clickable subtask icons fix --- */
      /* Ensure the icon element and all nested SVG parts accept pointer events,
         including on touch devices. Use !important to override any inline
         attributes lucide might add. */
      .subtask i,
      .subtask i svg,
      .subtask i * {
        pointer-events: auto !important;
        touch-action: manipulation;
        -webkit-user-select: none;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        cursor: pointer;
      }
      
      #notificationsView {
        position: fixed;
        left: 0;
        right: 0;
        top: 100svh;
        bottom: 0;
        background: var(--c-bg);
        color: var(--c-text);
        padding: 24px;
        padding-bottom: 140px;
        overflow-y: auto;
        z-index: 55;
      }

      .notification-title {
        font-size: 2rem;
        font-weight: 700;
        margin-bottom: 24px;
      }

      .notification-item {
        background: var(--c-card);
        border-radius: 16px;
        padding: 14px 16px;
        margin-bottom: 12px;
        font-weight: 600;
      }
      
      @keyframes bellShake {
        0% { transform: rotate(0deg); }
        20% { transform: rotate(-10deg); }
        40% { transform: rotate(10deg); }
        60% { transform: rotate(-6deg); }
        80% { transform: rotate(6deg); }
        100% { transform: rotate(0deg); }
      }

      .bell-shake {
        animation: bellShake 1.2s ease-in-out infinite;
        transform-origin: 50% 0%;
      }
    /* ================================
       Hide streak indicators (visual only)
       ================================ */
    .streak,
    .streak-value,
    .streak-counter,
    [data-streak],
    #streakView,
    #streakCounter,
    .streak-badge {
      display: none !important;
    }
  </style>
  <!-- Counter positioning fix for expanded/front mode -->
  <!-- (removed previous override, see below for new state-based CSS) -->
  <!-- Dynamic theme-color for Safari, PWA, Chrome -->
  <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
  <meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">

  <!-- Safari PWA status bar -->
  <meta name="apple-mobile-web-app-status-bar-style" content="default" media="(prefers-color-scheme: light)">
  <meta name="apple-mobile-web-app-status-bar-style" content="black" media="(prefers-color-scheme: dark)">
</head>
<body>

<!-- LOGIN -->
<div id="loginScreen">
  <div id="loginCircle"></div>
  <div id="loginHeadline">Wir versuchen dich anzumelden</div>

  <div id="loginButtonBar" style="display:none;">
    <button class="btn" id="btnLogin">Login</button>
    <button class="btn" id="btnRegister">Registrieren</button>
  </div>

  <div id="loginForm">
    <input id="loginName" class="login-input" placeholder="Name" type="text" style="display:none;" />
    <input id="loginEmail" class="login-input" placeholder="E-Mail" type="email" />
    <input id="loginPassword" class="login-input" placeholder="Passwort" type="password" />
    <div id="forgotPw" style="
      display:none;
      text-align:center;
      margin-top:-6px;
      font-size:14px;
      color:#555;
      text-decoration:underline;
      cursor:pointer;
    ">
      Passwort vergessen?
    </div>
    <button class="btn" id="loginOkBtn">OK</button>
  </div>

  <div id="loginError"></div>
</div>

<!-- MAIN HABIT PAGE (3 Klötze) -->
<div id="appPage">
    <!-- WEEKLY MEDAL SCREEN -->
    <div id="medalScreen" style="
      position:fixed;
      inset:0;
      background:var(--c-bg);
      color:var(--c-text);
      display:none;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      z-index:999995;
      padding:20px;
      text-align:center;
    ">
      <img id="medalImage" src="https://raw.githubusercontent.com/lillyapp/habits/refs/heads/main/firstplace.png" style="
        width:140px;
        height:140px;
        margin-bottom:28px;
      " />

      <div id="medalText" style="
        font-size:22px;
        font-weight:700;
        margin-bottom:34px;
        line-height:1.3;
      "></div>

      <button id="medalOkBtn" style="
        padding:14px 28px;
        border-radius:20px;
        border:none;
        background: var(--c-text);
        color: var(--c-bg);
        font-size:17px;
        font-weight:600;
      ">OK</button>
    </div>
  <div class="page">
    <div class="cards">
      <div class="slot" id="slot1"></div>
      <div class="slot" id="slot2"></div>
      <div class="slot" id="slot3"></div>
    </div>
  </div>

  <div class="buttons-row">
    <button class="btn-half btn-plus" id="addBtn" data-mode="main">
      <i data-lucide="plus"></i>
    </button>

    <button class="btn-half btn-bell" id="bellBtn">
      <i data-lucide="bell"></i>
    </button>

    <button class="btn-half btn-stats" id="statsBtn">
      <i data-lucide="bar-chart-2"></i>
    </button>
  </div>

  <div id="statsView"></div>
  <div id="notificationsView"></div>
  <!-- Dünner Shake-Delete-Balken -->
  <div id="deletePanel">
    <span id="deletePanelText">Klicke hier, um alle Habits zu löschen.</span>
    <button id="deleteAllBtn">Löschen</button>
  </div>
</div>

<script>
    lucide.createIcons();

    const supabaseClient = supabase.createClient(
      "https://gglgenarpskajkaanknk.supabase.co",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdnbGdlbmFycHNrYWprYWFua25rIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMwODA2NzAsImV4cCI6MjA3ODY1NjY3MH0.phVPaPpkiXJ0ncbRiBChpVBtY8gv0sm_MjlCJJnaSt4"
    );

    const loginScreen   = document.getElementById("loginScreen");
    const loginForm     = document.getElementById("loginForm");
    const loginError    = document.getElementById("loginError");
    const appPage       = document.getElementById("appPage");
    const btnLogin      = document.getElementById("btnLogin");
    const btnRegister   = document.getElementById("btnRegister");
    const loginOkBtn    = document.getElementById("loginOkBtn");
    const loginName     = document.getElementById("loginName");
    const loginEmail    = document.getElementById("loginEmail");
    const loginPassword = document.getElementById("loginPassword");
    const forgotPw = document.getElementById("forgotPw");
    const addBtnEl      = document.getElementById("addBtn");
    const statsBtnEl    = document.getElementById("statsBtn");
    const statsViewEl   = document.getElementById("statsView");
    const deletePanel   = document.getElementById("deletePanel");
    const deleteAllBtn  = document.getElementById("deleteAllBtn");
    const bellBtnEl = document.getElementById("bellBtn");
    const notificationsViewEl = document.getElementById("notificationsView");
   
   document.addEventListener("DOMContentLoaded", () => {
     refreshBellIcon();
   });

    const slotOrder = ["slot3","slot2","slot1"];

    let habits      = [];
    let currentUser = null;
    let authMode    = "login";
    let statsOpen   = false;
    let otherUser   = null;

    // unread badge comes from DB
    let unreadNotificationCount = 0;

    // ================================
    // Notification bell polling
    // ================================
    let notificationPollTimer = null;

    function startNotificationPolling(intervalMs = 8000) {
      stopNotificationPolling();
      notificationPollTimer = setInterval(async () => {
        if (!currentUser) return;
        await loadUnreadNotificationCount();
        refreshBellIcon();
      }, intervalMs);
    }

    function stopNotificationPolling() {
      if (notificationPollTimer) {
        clearInterval(notificationPollTimer);
        notificationPollTimer = null;
      }
    }

    // Push/Notification capability
    const supportsPush = (
      "serviceWorker" in navigator &&
      "PushManager" in window &&
      "Notification" in window
    );

    let deleteTimeout = null;
    let deletePanelVisible = false;

    const cycleColors = [
      "#ef4444","#f97316","#f59e0b","#eab308","#84cc16","#22c55e",
      "#10b981","#14b8a6","#06b6d4","#0ea5e9","#3b82f6","#6366f1",
      "#8b5cf6","#a855f7","#d946ef","#ec4899","#f43f5e","#dc2626",
      "#ea580c","#ca8a04","#4d7c0f","#15803d","#047857","#0f766e",
      "#0369a1","#1d4ed8","#4338ca","#6d28d9","#7e22ce","#be185d"
    ];

    // ================================
    // Motivational notification texts
    // ================================

    // When the user is behind (passive-aggressive but caring)
    const MOTIVATION_TEXTS_TRAILING = [
      "Heute war noch Luft nach oben. Morgen zählt wieder.",
      "Du weißt selbst: Du kannst das besser. Und du wirst es zeigen.",
      "Nicht schlimm. Aber wir beide wissen, dass da mehr drin ist.",
      "Ein kleiner Hänger ist kein Rückschritt. Aufstehen lohnt sich.",
      "Du bist nicht raus – du bist nur kurz langsamer.",
      "Das Ziel ist noch da. Es wartet geduldig auf dich.",
      "Kein Drama. Aber auch kein Grund stehenzubleiben.",
      "Andere ziehen vorbei – noch. Das ist kein Urteil.",
      "Du hast schon bewiesen, dass du es kannst.",
      "Morgen ist ein verdammt guter Zeitpunkt, um zurückzukommen."
    ];

    // When the user is leading (positive reinforcement)
    const MOTIVATION_TEXTS_LEADING = [
      "Stark. Genau so entsteht Konstanz.",
      "Du führst – und zwar verdient.",
      "Das sieht nach echter Routine aus.",
      "Sehr gut. Das ist kein Zufall mehr.",
      "Du setzt gerade den Maßstab.",
      "Sauber durchgezogen. Respekt.",
      "So fühlt sich Dranbleiben an.",
      "Du machst es vor. Weiter so.",
      "Konsequent. Und genau deshalb vorne.",
      "Das ist Momentum. Nutz es."
    ];

    // Helper to get a random text from a pool
    function pickRandomMotivationText(pool) {
      if (!Array.isArray(pool) || pool.length === 0) return "";
      return pool[Math.floor(Math.random() * pool.length)];
    }
    
    addBtnEl.addEventListener("click", async () => {

      // --- Close Notifications ---
      if (addBtnEl.dataset.mode === "notifications") {
        addBtnEl.dataset.mode = "main";
        gsap.to("#notificationsView", {
          top: "100svh",
          duration: 0.42,
          ease: "power1.in"
        });
        refreshAddButtonIcon();
        return;
      }

      // --- Close Stats ---
      if (addBtnEl.dataset.mode === "stats") {
        addBtnEl.dataset.mode = "main";
        statsOpen = false;
        gsap.to("#statsView", {
          top: "100svh",
          duration: 0.42,
          ease: "power1.in"
        });
        refreshAddButtonIcon();
        return;
      }

      // --- Normal Add Habit ---
      if (habits.length >= 3) return;

      if (!currentUser) {
        const { data } = await supabaseClient.auth.getUser();
        currentUser = data.user;
        if (!currentUser) return;
      }

      const { data, error } = await supabaseClient
        .from("habits")
        .insert({
          user_id: currentUser.id,
          title: "",
          color: "#e4e4e4",
          progress: 0,
          goal: 1,
          appear_once: false
        })
        .select()
        .single();

      if (error) {
        console.error("insert habit error:", error);
        return;
      }

      habits.push(data);
      createCardFromHabit(data, habits.length - 1, 0);
      refreshAddButtonIcon();
    });
    
    bellBtnEl.addEventListener("click", async () => {

      // iOS/PWA requirement: permission request must be user-triggered
      if (supportsPush && Notification.permission === "default") {
        const res = await Notification.requestPermission();
        await ensurePushInfoRow();

        if (res === "granted") {
          await registerPushSubscription();
        }
      } else {
        // keep DB in sync even if already decided
        await ensurePushInfoRow();
      }

      // Update badge before opening
      await loadUnreadNotificationCount();
      refreshBellIcon();

      await renderNotifications();
      lucide.createIcons({ scope: notificationsViewEl });

      statsOpen = false;
      addBtnEl.dataset.mode = "notifications";

      gsap.to("#notificationsView", {
        top: "0svh",
        duration: 0.42,
        ease: "power1.out"
      });

      gsap.to("#statsView", {
        top: "100svh",
        duration: 0.42,
        ease: "power1.in"
      });

      refreshAddButtonIcon();

      // Mark as read after opening
      await markAllNotificationsRead();
      await loadUnreadNotificationCount();
      refreshBellIcon();
    });


    function darken(hex, f=0.55) {
      let r = parseInt(hex.slice(1,3),16)*f|0;
      let g = parseInt(hex.slice(3,5),16)*f|0;
      let b = parseInt(hex.slice(5,7),16)*f|0;
      return `rgb(${r},${g},${b})`;
    }

    function startLoginCircleFloat() {
      if (!document.getElementById("loginCircle")) return;
      gsap.to("#loginCircle", {
        y: -6,
        duration: 2.4,
        repeat: -1,
        yoyo: true,
        ease: "sine.inOut"
      });
    }
    

    function showAppAfterDataLoaded() {
      appPage.style.display = "block";
      gsap.fromTo(appPage, { opacity:0 }, {
        opacity:1,
        duration:0.5,
        ease:"sine.inOut"
      });

      gsap.to(loginScreen, {
        opacity:0,
        duration:0.45,
        ease:"sine.inOut",
        onComplete: () => { loginScreen.style.display = "none"; }
      });
    }

    // === Passwort-Reset-Funktionen (müssen VOR dem Login-Block stehen) ===
    function showPasswordResetLink() {
      forgotPw.style.display = "block";
    }

    function hidePasswordResetLink() {
      forgotPw.style.display = "none";
    }

// LOGIN
// LOGIN-MODUS AUSWÄHLEN
btnLogin.onclick = () => {
  authMode = "login";
  loginName.style.display = "none";
  hidePasswordResetLink();

  loginForm.style.display = "flex";
  loginEmail.value = "";
  loginPassword.value = "";
  loginError.style.display = "none";
};

btnRegister.onclick = () => {
  authMode = "register";
  loginName.style.display = "block";
  hidePasswordResetLink();

  loginForm.style.display = "flex";
  loginEmail.value = "";
  loginPassword.value = "";
  loginName.value = "";
  loginError.style.display = "none";
};

// Passwort vergessen
forgotPw.onclick = () => {
  authMode = "reset";
  loginName.style.display = "none";
  showPasswordResetLink();

  loginForm.style.display = "flex";
  loginPassword.style.display = "none";   // Passwort verstecken
  loginError.style.display = "none";
};
    
    loginOkBtn.onclick = async () => {
      loginError.style.display = "none";

      const email    = loginEmail.value.trim();
      const password = loginPassword.value.trim();
      const name     = loginName.value.trim();

      if (!email || (!password && authMode !== "reset") || (authMode === "register" && !name)) {
        loginError.textContent = "Bitte alles ausfüllen.";
        loginError.style.display = "block";
        return;
      }

      let error;

      if (authMode === "login") {
        ({ error } = await supabaseClient.auth.signInWithPassword({ email, password }));
      }

      else if (authMode === "register") {
        const { error: signUpErr } = await supabaseClient.auth.signUp({
          email,
          password,
          options: { data: { display_name: name } }
        });
        error = signUpErr;
      }

      else if (authMode === "reset") {
        const { error: resetErr } = await supabaseClient.auth.resetPasswordForEmail(email, {
          redirectTo: window.location.href
        });

        if (resetErr) {
          loginError.textContent = resetErr.message;
          loginError.style.display = "block";
        } else {
          loginError.textContent = "E-Mail zum Zurücksetzen gesendet.";
          loginError.style.display = "block";
        }
        return;
      }

      if (error) {
        loginError.textContent = error.message;
        loginError.style.display = "block";
        return;
      }

      const { data } = await supabaseClient.auth.getUser();
      currentUser = data.user;
      await ensureStreakViewRow();
      await ensurePushInfoRow();
      await loadUnreadNotificationCount();
      refreshBellIcon();
      startNotificationPolling();

      await requestAllPermissions();
      setupRealtime();
      setupShakeDetection();

      await safeLoadHabits();
      const subline = document.getElementById("loginSubline");
      if (subline) subline.style.display = "none";
      showAppAfterDataLoaded();
      await checkMedalScreen();
      const qr = getQRParam();
      if (qr) await processQRFlow(qr);
    };

    // === AUTOLOGIN + QR FLOW ===
    (async () => {
      const { data } = await supabaseClient.auth.getUser();

      if (data.user) {
        currentUser = data.user;
        await ensureOwnStreakRow();
        await ensureStreakViewRow();
        await ensurePushInfoRow();
        await loadUnreadNotificationCount();
        refreshBellIcon();
        startNotificationPolling();

        setupRealtime();
        setupShakeDetection();

        await safeLoadHabits();
        showAppAfterDataLoaded();
        await checkMedalScreen();
        const qr = getQRParam();
        if (qr) await processQRFlow(qr);
      } else {
        // Kein Autologin möglich → Login anbieten
        const headline = document.getElementById("loginHeadline");
        const btnBar   = document.getElementById("loginButtonBar");

        if (headline) headline.textContent = "Bitte melde dich an";
        if (btnBar)   btnBar.style.display = "flex";
      }
    })();
    

    async function ensureOwnStreakRow() {
      if (!currentUser) return;

      await supabaseClient
        .from("streak_view")
        .insert({ user_id: currentUser.id })
        .select()
        .maybeSingle();
    }
    

    function setupRealtime() {
      supabaseClient.channel('habits-realtime')
        .on(
          'postgres_changes',
          { event: '*', schema: 'public', table: 'habits' },
          async () => {
            if (statsOpen) await refreshStatsLive();
          }
        )
        .on(
          'postgres_changes',
          { event: '*', schema: 'public', table: 'streak_view' },
          async () => {
            if (statsOpen) await refreshStatsLive();
          }
        )
        .subscribe();
    }

    // ---------- TEIL 1: Nur-Server-Load + Initialisierung ----------
    async function safeLoadHabits() {
      if (!currentUser) {
        const { data } = await supabaseClient.auth.getUser();
        currentUser = data.user;
        if (!currentUser) return;
      }

      const { data, error } = await supabaseClient
        .from("habits")
        .select(`id, user_id, title, color, progress, goal, location_address, qr_enabled, sub1_title, sub1_progress, sub2_title, sub2_progress, sub3_title, sub3_progress, inserted_at`)
        .eq("user_id", currentUser.id)
        .order("inserted_at", { ascending: true })
        .limit(3);

      if (error) {
        console.error("safeLoadHabits error:", error);
        return;
      }

      const rows = data || [];

      if (rows.length === 0) {
        await createInitialHabits();   // exakt 3 in DB anlegen
        return safeLoadHabits();       // danach erneut laden
      }

      habits = rows;

      clearAllSlots();
      const baseDelay = 0.0;
      habits.forEach((habit, i) => {
        const delay = baseDelay + (habits.length - 1 - i) * 0.12;
        createCardFromHabit(habit, i, delay);
      });

      refreshAddButtonIcon();
    }

    async function createInitialHabits() {
      if (!currentUser) return;

      const inserts = Array.from({ length: 3 }).map(() => ({
        user_id: currentUser.id,
        title: "",
        color: "#e4e4e4",
        progress: 0,
        goal: 1,
        appear_once: false
      }));

      const { error } = await supabaseClient.from("habits").insert(inserts);
      if (error) console.error("createInitialHabits error:", error);
    }

    function clearAllSlots() {
      slotOrder.forEach(id => { document.getElementById(id).innerHTML = ""; });
    }

    function refreshAddButtonIcon() {
      const addBtn = addBtnEl;

      if (addBtn.dataset.mode === "notifications") {
        addBtn.innerHTML = '<i data-lucide="house"></i>';
        lucide.createIcons();
        return;
      }

      if (addBtn.dataset.mode === "stats") {
        addBtn.innerHTML = '<i data-lucide="house"></i>';
        lucide.createIcons();
        return;
      }

      if (habits.length < 3) {
        addBtn.innerHTML = '<i data-lucide="plus"></i>';
      } else {
        addBtn.innerHTML = '<i data-lucide="home"></i>';
      }

      lucide.createIcons();
    }
    
    // -------------------------------
    // Notifications / Push (DB-backed)
    // -------------------------------

    async function ensurePushInfoRow() {
      if (!currentUser) return;
      const uid = currentUser.id;

      const permission_state =
        !supportsPush ? "unsupported" :
        (Notification.permission === "granted" ? "granted" :
         Notification.permission === "denied" ? "denied" : "unknown");

      const { error } = await supabaseClient
        .from("push_info")
        .upsert({
          user_id: uid,
          permission_state,
          platform_capabilities: {
            supportsPush,
            userAgent: navigator.userAgent || ""
          }
        });

      if (error) console.error("push_info upsert error:", error);
    }
    
    async function ensureStreakViewRow() {
      if (!currentUser) return;

      const { error } = await supabaseClient
        .from("streak_view")
        .upsert(
          {
            user_id: currentUser.id,
            current_streak: 0,
            longest_streak: 0,
            showMedal: 0
          },
          { onConflict: "user_id" }
        );

      if (error) {
        console.error("ensureStreakViewRow error:", error);
      }
    }

    async function loadUnreadNotificationCount() {
      if (!currentUser) return 0;
      const uid = currentUser.id;

      const { count, error } = await supabaseClient
        .from("notification_message")
        .select("id", { count: "exact", head: true })
        .eq("user_id", uid)
        .is("read_at", null);

      if (error) {
        console.error("unread count error:", error);
        return 0;
      }

      unreadNotificationCount = count || 0;
      return unreadNotificationCount;
    }

    async function loadNotifications(limit = 30) {
      if (!currentUser) return [];
      const uid = currentUser.id;

      const { data, error } = await supabaseClient
        .from("notification_message")
        .select("id, type, title, body, payload, created_at, read_at")
        .eq("user_id", uid)
        .order("created_at", { ascending: false })
        .limit(limit);

      if (error) {
        console.error("loadNotifications error:", error);
        return [];
      }
      return data || [];
    }

    async function markAllNotificationsRead() {
      if (!currentUser) return;
      const uid = currentUser.id;

      const { error } = await supabaseClient
        .from("notification_message")
        .update({ read_at: new Date().toISOString() })
        .eq("user_id", uid)
        .is("read_at", null);

      if (error) {
        console.error("markAllNotificationsRead error:", error);
        return;
      }

      unreadNotificationCount = 0;
    }

    // NOTE: Push subscription requires HTTPS (or localhost). It will not work on file://
    async function registerPushSubscription() {
      if (!supportsPush) return;
      if (!currentUser) return;
      if (Notification.permission !== "granted") return;

      // TODO: replace with your real VAPID public key (Base64URL)
      const VAPID_PUBLIC_KEY = "REPLACE_WITH_YOUR_VAPID_PUBLIC_KEY";

      function urlBase64ToUint8Array(base64String) {
        const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
        const base64 = (base64String + padding).replace(/-/g, "+").replace(/_/g, "/");
        const rawData = atob(base64);
        const outputArray = new Uint8Array(rawData.length);
        for (let i = 0; i < rawData.length; ++i) outputArray[i] = rawData.charCodeAt(i);
        return outputArray;
      }

      try {
        const reg = await navigator.serviceWorker.register("/habits/sw.js");
        const sub = await reg.pushManager.subscribe({
          userVisibleOnly: true,
          applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY)
        });

        const json = sub.toJSON();
        const endpoint = sub.endpoint;
        const p256dh = json?.keys?.p256dh || "";
        const auth = json?.keys?.auth || "";

        if (!endpoint || !p256dh || !auth) {
          console.error("push subscription missing keys");
          return;
        }

        const platform =
          /iphone|ipad|ipod/i.test(navigator.userAgent) ? "ios" :
          /android/i.test(navigator.userAgent) ? "android" : "desktop";

        const { error } = await supabaseClient
          .from("push_subscription")
          .insert({
            user_id: currentUser.id,
            endpoint,
            p256dh,
            auth,
            platform,
            user_agent: navigator.userAgent || "",
            last_used_at: new Date().toISOString()
          });

        if (error) console.error("push_subscription insert error:", error);
      } catch (e) {
        console.error("registerPushSubscription error:", e);
      }
    }
    
    
    function refreshBellIcon() {
      if (!bellBtnEl) return;

      // bell-dot if unread notifications exist
      const hasUnread = (unreadNotificationCount || 0) > 0;
      const icon = hasUnread ? "bell-dot" : "bell";

      bellBtnEl.innerHTML = `<i data-lucide="${icon}"></i>`;
      lucide.createIcons({ scope: bellBtnEl });

      // shake bell until permission is granted (only if supported)
      const perm = (window.Notification && Notification.permission) ? Notification.permission : "denied";
      if (supportsPush && perm !== "granted") {
        bellBtnEl.classList.add("bell-shake");
      } else {
        bellBtnEl.classList.remove("bell-shake");
      }
    }

    function createCardFromHabit(habit, index, delay = 0) {
      const slot = document.getElementById(slotOrder[index]);
      const card = document.createElement("div");
      card.className = "card";

      const rawGoal   = habit.goal;
      const goal      = (rawGoal === null || rawGoal === undefined) ? 1 : rawGoal;
      const progress  = parseInt(habit.progress) || 0;
      const dbColor   = habit.color || "#e4e4e4";
      const addr      = habit.location_address || "";
      const qrEnabled = habit.qr_enabled || false;
      const lastScanned = habit.last_scanned || null;
      const scannedToday = isToday(lastScanned);

      card.dataset.index    = index;
      card.dataset.habitId  = habit.id;
      card.dataset.goal     = goal;
      card.dataset.progress = progress;
      card.dataset.color    = dbColor;
      card.dataset.location = addr;
      card.dataset.qr       = qrEnabled ? "true" : "false";
      // subtask data (persisted columns)
      card.dataset.sub1_title = habit.sub1_title || "";
      card.dataset.sub1_progress = habit.sub1_progress || 0;
      card.dataset.sub2_title = habit.sub2_title || "";
      card.dataset.sub2_progress = habit.sub2_progress || 0;
      card.dataset.sub3_title = habit.sub3_title || "";
      card.dataset.sub3_progress = habit.sub3_progress || 0;

      const isActive = progress > 0;
      card.dataset.active = isActive ? "true" : "false";

      // --- HTML ---
      card.innerHTML = `
      <div class="card-face front">
        <div class="front-header">
          <div class="card-input" contenteditable="true" data-placeholder="Titel eingeben..."></div>
          <div class="counter counter-kcal" style="display:none;"></div>
        </div>

        <div class="expand-area" style="display:none;">
          <div class="expand-divider"></div>
          <div class="subtasks"></div>
          <div class="add-subtask">
            <i data-lucide="plus-circle"></i>
          </div>
        </div>
      </div>

        <div class="card-face back">

          <!-- GPS AREA -->
          <div class="quarter" id="gpsArea">
            <div style="display:flex; flex-direction:column; align-items:center; gap:4px;">
              <i data-lucide="map-pin" style="width:28px;height:28px;color:#777;"></i>

              <div class="gps-address-line1" style="
                font-size:0.7rem;
                color:#555;
                text-align:center;
                line-height:1;
                display:none;
              "></div>

              <div class="gps-address-line2" style="
                font-size:0.7rem;
                color:#555;
                text-align:center;
                line-height:1;
                display:none;
              "></div>
            </div>
          </div>

          <!-- UNDO / DECREMENT AREA -->
          <div class="quarter" id="undoArea">
            <div style="display:flex; flex-direction:column; align-items:center; gap:4px;">
              <i data-lucide="timer-reset" style="width:28px;height:28px;color:#777;"></i>
            </div>
          </div>

          <!-- SQUARES-SUBTRACT AREA -->
          <div class="quarter" id="collapseArea">
            <div style="display:flex; flex-direction:column; align-items:center; gap:4px;">
              <i data-lucide="squares-subtract" style="width:28px;height:28px;color:#777;"></i>
            </div>
          </div>

          <!-- Counter & GPS Input -->
          <div class="quarter" id="numAreaWrapper">
            <div id="numArea">0</div>

            <input 
              id="gpsInput"
              type="text"
              placeholder="Adresse eingeben..."
              style="
                display:none;
                width:100%;
                padding:6px;
                border-radius:12px;
                border:1px solid #ccc;
                font-size:0.9rem;
              "
            />
          </div>

        </div>
      `;

      slot.appendChild(card);
      lucide.createIcons();

      // --- DOM REFS ---
      const input   = card.querySelector(".card-input");
      const counter = card.querySelector(".counter");
      const isQR = qrEnabled;
      const kcalTarget = 21000;

      if (isQR) {
        counter.style.display = "block";
        counter.textContent = `${parseInt(progress)} KCAL`;
      } else {
        const goal = parseInt(card.dataset.goal) || 1;
        if (goal >= 2) {
          counter.style.display = "block";
          counter.textContent = `${progress}/${goal}`;
        } else {
          counter.style.display = "none";
        }
      }
      const numArea = card.querySelector("#numArea");

      const line1 = card.querySelector(".gps-address-line1");
      const line2 = card.querySelector(".gps-address-line2");


      // === Titel ===
      input.textContent = habit.title || "";

      // === Adresse anzeigen ===
      if (addr) {
        const parts = addr.split(",");
        line1.textContent = (parts[0] || "").trim();
        line2.textContent = (parts[1] || "").trim();
        line1.style.display = "block";
        line2.style.display = "block";
      } else {
        line1.style.display = "none";
        line2.style.display = "none";
      }


      // === Counter ===
      numArea.textContent = goal;
      if (goal >= 2) {
        counter.style.display = "block";
        counter.textContent = progress + "/" + goal;
      } else {
        counter.style.display = "none";
      }

      // === Farben ===
      const progValue = parseInt(progress) || 0;

      if (progValue > 0) {
        card.style.background = dbColor;
        input.style.color     = darken(dbColor);
        card.dataset.active   = "true";
      } else {
        card.style.background = "#e4e4e4";
        input.style.color     = "#666";
        card.dataset.active   = "false";
        card.dataset.color    = "#e4e4e4";
      }

      // === Animation ===
      gsap.fromTo(card, { y:-80, opacity:0 }, {
        y:0,
        opacity:1,
        duration:0.6,
        ease:"power1.out",
        delay
      });
      
      if (qrEnabled) {
        const kcalProgress = parseInt(progress) || 0;
        counter.style.display = "block";
        counter.textContent = `${kcalProgress} KCAL`;
      }
      
      attachCardLogic(card);
    }

    function shake(card) {
      gsap.fromTo(card,
        { x:-10 },
        { x:10, duration:0.1, repeat:3, yoyo:true, ease:"power1.inOut",
          onComplete: () => { card.style.transform = ""; }
        }
      );
    }
    
    function attachCardLogic(card) {
      const input     = card.querySelector(".card-input");
      const counter   = card.querySelector(".counter");
      const gpsArea   = card.querySelector("#gpsArea");
      const numArea   = card.querySelector("#numArea");
      const gpsInput  = card.querySelector("#gpsInput");
      const undoArea  = card.querySelector("#undoArea");
      const collapseArea = card.querySelector("#collapseArea");

      let swipeStartX = 0;
      let swipeEndX   = 0;

      // ======================================
      // SWIPE FRONT/BACK
      // ======================================
      card.addEventListener("touchstart",(e)=>{
        swipeStartX = e.touches[0].clientX;
        swipeEndX   = swipeStartX;
      });

      card.addEventListener("touchmove",(e)=>{
        swipeEndX = e.touches[0].clientX;
      });

      card.addEventListener("touchend",()=>{
        const dx = swipeEndX - swipeStartX;

        if (dx < -40 && !card.style.transform.includes("180deg")){
          gsap.to(card,{ rotationY:180, duration:0.48, ease:"sine.inOut" });
        }
        if (dx > 40 && card.style.transform.includes("180deg")){
          gsap.to(card,{ rotationY:0, duration:0.48, ease:"sine.inOut" });
        }
      });

      // ======================================
      // NUMMER / GOAL ÄNDERN (NICHT BEI QR)
      // ======================================
      numArea.addEventListener("click",(e)=>{
        e.stopPropagation();

        // QR-Mode deaktiviert die Goal-Änderung
        if (card.dataset.qr === "true") return;

        let y = parseInt(card.dataset.goal) || 0;
        y = (y + 1) % 8;

        card.dataset.goal = y;
        numArea.textContent = y;

        let x = parseInt(card.dataset.progress) || 0;
        if (x > y) {
          x = y;
          card.dataset.progress = x;
        }

        if (y >= 2) {
          counter.style.display = "block";
          counter.textContent   = x + "/" + y;
        } else {
          counter.style.display = "none";
        }

        saveHabit(card);
      });

      // ======================================
      // GPS EINGABE
      // ======================================
      gpsArea.addEventListener("click", (e) => {
        e.stopPropagation();

        gsap.to(card, { rotationY:180, duration:0.48, ease:"sine.inOut" });

        gpsInput.style.display = "block";
        numArea.style.display = "none";

        gpsInput.value = card.dataset.location || "";
        gpsInput.focus();
      });

      gpsInput.addEventListener("blur", async () => {
        const addr = gpsInput.value.trim();
        card.dataset.location = addr;

        gpsInput.style.display = "none";
        numArea.style.display = "flex";

        const habitId = card.dataset.habitId;
        if (habitId) {
          const { error } = await supabaseClient
            .from("habits")
            .update({ location_address: addr })
            .eq("id", habitId);

          if (error) console.error("GPS address save error:", error);
        }
      });

      // ======================================
      // UNDO / DECREMENT PROGRESS BY 1
      // ======================================
      if (undoArea) {
        undoArea.addEventListener("click", async (e) => {
          e.stopPropagation();

          let progress = parseInt(card.dataset.progress) || 0;
          if (progress <= 0) return;

          progress -= 1;
          card.dataset.progress = progress;

          const goal = parseInt(card.dataset.goal) || 1;
          const counter = card.querySelector(".counter");

          if (goal >= 2) {
            counter.style.display = "block";
            counter.textContent = progress + "/" + goal;
          } else {
            if (progress <= 0) counter.style.display = "none";
          }

          if (progress <= 0) {
            card.dataset.active = "false";
            card.style.background = "#e4e4e4";
            const input = card.querySelector(".card-input");
            input.style.color = "#666";
            card.dataset.color = "#e4e4e4";
          }

          const habitId = card.dataset.habitId;
          if (!habitId) return;

          const { error } = await supabaseClient
            .from("habits")
            .update({ progress })
            .eq("id", habitId);

          if (error) console.error("decrement progress error:", error);
        });
      }

      // ======================================
      // EXPAND CARD (SQUARES-SUBTRACT)
      // ======================================
      if (collapseArea) {
        collapseArea.addEventListener("click", (e) => {
          e.stopPropagation();

            // rotate to front then delegate to expandCard which handles minimize/button behavior
            gsap.to(card, { rotationY: 0, duration: 0.45, ease: "sine.inOut", onComplete: () => {
              expandCard(card);
            }});
        });
      }

      // ======================================
      // SUBTASKS (refactored, delegation-based)
      // ======================================
      const subtasksWrap = card.querySelector(".subtasks");
      const addSubtaskBtn = card.querySelector(".add-subtask");

      function recalcFromSubtasks() {
        const rows = subtasksWrap.querySelectorAll(".subtask");
        if (rows.length === 0) { card.dataset.subtasksComplete = "false"; return; }

        const allDone = Array.from(rows).every(r => r.dataset.done === "true");
        card.dataset.subtasksComplete = allDone ? "true" : "false";
      }

      function createSubtask(title = "") {
        const existingCount = subtasksWrap.querySelectorAll('.subtask').length;
        if (existingCount >= 3) return null;

        const row = document.createElement("div");
        row.className = "subtask";
        row.dataset.done = "false";

        row.innerHTML = `
          <button class="subtask-toggle" aria-pressed="false" style="background:transparent;border:none;padding:0;margin-right:8px;display:flex;align-items:center;">
            <i data-lucide="circle"></i>
          </button>
          <input class="subtask-title" placeholder="Unteraufgabe..." value="${title}">
        `;

        const inputEl = row.querySelector(".subtask-title");

        inputEl.addEventListener("click", e => e.stopPropagation());
        inputEl.addEventListener("pointerdown", e => e.stopPropagation());
        inputEl.addEventListener("touchstart", e => e.stopPropagation());
        inputEl.addEventListener("blur", (e) => { recalcFromSubtasks(); saveHabit(card); });

        subtasksWrap.appendChild(row);
        syncSubtaskColors();
        lucide.createIcons({ scope: row });
        recalcFromSubtasks();
        return row;
      }

      // Delegated handlers: stop pointerdown/touchstart to prevent card handlers
      // (long-press / touchstart on the card) and handle pointerup to toggle.
      subtasksWrap.addEventListener('pointerdown', (e) => {
        const btn = e.target.closest('.subtask-toggle');
        if (!btn) return;
        e.stopPropagation();
        e.preventDefault && e.preventDefault();
      });
      subtasksWrap.addEventListener('touchstart', (e) => {
        const btn = e.target.closest('.subtask-toggle');
        if (!btn) return;
        e.stopPropagation();
      });

      // Delegated handler: handle pointerup on container so rendered SVGs are caught
      subtasksWrap.addEventListener('pointerup', (e) => {
        const btn = e.target.closest('.subtask-toggle');
        if (!btn) return;
        e.stopPropagation();
        e.preventDefault && e.preventDefault();

        const row = btn.closest('.subtask');
        if (!row) return;

        const allRows = Array.from(subtasksWrap.querySelectorAll('.subtask'));
        const allDoneBefore = allRows.length > 0 && allRows.every(r => r.dataset.done === 'true');

        // Toggle this row
        const wasDone = row.dataset.done === 'true';
        row.dataset.done = wasDone ? 'false' : 'true';

        // Update icon visual
        const newIconName = wasDone ? 'circle' : 'circle-check';
        btn.innerHTML = `<i data-lucide="${newIconName}"></i>`;
        btn.setAttribute('aria-pressed', row.dataset.done === 'true' ? 'true' : 'false');
        lucide.createIcons({ scope: btn });

        // color the newly rendered icon to match the card title color
        try {
          const titleColor = card.querySelector('.card-input')?.style.color || darken(card.dataset.color || '#e4e4e4');
          const sv = btn.querySelector('svg');
          if (sv) {
            sv.style.color = titleColor;
            sv.setAttribute('stroke', titleColor);
            sv.setAttribute('fill', 'none');
            sv.querySelectorAll('*').forEach(el => { try { el.setAttribute('stroke', titleColor); if (!el.getAttribute('fill') || el.getAttribute('fill') === 'none') el.setAttribute('fill','none'); } catch(e){} });
          }
        } catch(e){}

        // Recompute after toggle
        const allDoneAfter = allRows.every(r => (r === row ? row.dataset.done === 'true' : r.dataset.done === 'true'));

        // If subtasks exist, only change main progress when full completion state changes
        try {
          const cardEl = card;
          const goal = parseInt(cardEl.dataset.goal) || 1;
          let progress = parseInt(cardEl.dataset.progress) || 0;
          let active = cardEl.dataset.active === 'true';

          if (!allDoneBefore && allDoneAfter) {
            // became fully completed -> increment progress by one step
            if (goal <= 1) {
              if (!active) {
                progress = 1;
                active = true;
                const idx = parseInt(cardEl.dataset.index);
                let col = cardEl.dataset.color;
                if (!col || col === '#e4e4e4') col = cycleColors[idx % cycleColors.length];
                cardEl.style.background = col;
                cardEl.dataset.color = col;
                const inputElTitle = cardEl.querySelector('.card-input');
                if (inputElTitle) inputElTitle.style.color = darken(col);
              }
            } else {
              if (progress < goal) {
                progress += 1;
                active = true;
                const idx = parseInt(cardEl.dataset.index);
                let col = cardEl.dataset.color;
                if (!col || col === '#e4e4e4') col = cycleColors[idx % cycleColors.length];
                cardEl.style.background = col;
                cardEl.dataset.color = col;
                const inputElTitle = cardEl.querySelector('.card-input');
                if (inputElTitle) inputElTitle.style.color = darken(col);
              }
            }
          }

          if (allDoneBefore && !allDoneAfter) {
            // became not fully completed -> decrement progress by one step
            if (goal <= 1) {
              if (active) {
                progress = 0;
                active = false;
                cardEl.style.background = '#e4e4e4';
                cardEl.dataset.color = '#e4e4e4';
                const inputElTitle = cardEl.querySelector('.card-input');
                if (inputElTitle) inputElTitle.style.color = '#666';
              }
            } else {
              if (progress > 0) {
                progress = Math.max(0, progress - 1);
                if (progress === 0) {
                  active = false;
                  cardEl.style.background = '#e4e4e4';
                  cardEl.dataset.color = '#e4e4e4';
                  const inputElTitle = cardEl.querySelector('.card-input');
                  if (inputElTitle) inputElTitle.style.color = '#666';
                }
              }
            }
          }

          cardEl.dataset.progress = progress;
          cardEl.dataset.active = active ? 'true' : 'false';

          // Update counter UI
          const counterEl = cardEl.querySelector('.counter');
          if (counterEl) {
            if (parseInt(cardEl.dataset.goal) >= 2) {
              counterEl.style.display = 'block';
              counterEl.textContent = progress + '/' + (parseInt(cardEl.dataset.goal) || 1);
            } else {
              counterEl.style.display = (progress > 0) ? 'block' : 'none';
              if (progress > 0) counterEl.textContent = progress;
            }
          }

          // Persist both subtask states and main progress
          saveHabit(cardEl);
        } catch (err) {
          console.error('subtask progress sync error', err);
        }

        recalcFromSubtasks();
      });

      if (addSubtaskBtn) {
        addSubtaskBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          // enforce max 3 subtasks
          const count = subtasksWrap.querySelectorAll('.subtask').length;
          if (count >= 3) return;
          const r = createSubtask("");
          if (r) {
            // immediately focus the input for quick editing
            const inp = r.querySelector('.subtask-title');
            if (inp) inp.focus();
          }
        });
      }

      // Load persisted subtasks from dataset (if any)
      (function loadSubtasksFromDataset(){
        const subs = [
          { title: card.dataset.sub1_title || '', prog: parseInt(card.dataset.sub1_progress) || 0 },
          { title: card.dataset.sub2_title || '', prog: parseInt(card.dataset.sub2_progress) || 0 },
          { title: card.dataset.sub3_title || '', prog: parseInt(card.dataset.sub3_progress) || 0 }
        ];

        subs.forEach(s => {
          if (s.title && s.title.trim().length > 0) {
            const row = createSubtask(s.title);
            if (row && s.prog > 0) {
              row.dataset.done = 'true';
              const btn = row.querySelector('.subtask-toggle');
              if (btn) {
                  btn.innerHTML = `<i data-lucide="circle-check"></i>`;
                  btn.setAttribute('aria-pressed','true');
                  lucide.createIcons({ scope: btn });
                  try {
                    const titleColor = card.querySelector('.card-input')?.style.color || darken(card.dataset.color || '#e4e4e4');
                    const sv = btn.querySelector('svg');
                    if (sv) { sv.style.color = titleColor; sv.setAttribute('stroke', titleColor); sv.setAttribute('fill','none'); sv.querySelectorAll('*').forEach(el=>{ try{ el.setAttribute('stroke', titleColor); if(!el.getAttribute('fill')||el.getAttribute('fill')==='none') el.setAttribute('fill','none'); }catch(e){} }); }
                  } catch(e){}
                }
            }
          }
        });
        recalcFromSubtasks();

        // If no persisted subtasks, leave the UI available so users can add new ones.
        // Previously we hid the entire subtask UI when columns were empty — that prevented
        // creating new subtasks. Keep expand-area/add-subtask visible on expand, but
        // do not auto-create rows here.
      })();

      function syncSubtaskColors() {
        // Use the actual title color (it may be a darkened variant of the
        // background color or a fallback like "#666"). This ensures subtitles
        // match the visible title color exactly.
        const titleEl = card.querySelector('.card-input');
        const titleColor = (titleEl && titleEl.style && titleEl.style.color)
          ? titleEl.style.color
          : darken(card.dataset.color || '#e4e4e4');

        card.querySelectorAll('.subtask-title').forEach(el => {
          el.style.color = titleColor;
          // also set placeholder color via CSS variable so ::placeholder matches
          el.style.setProperty('--ph', titleColor);
        });

        card.querySelectorAll('.subtask i').forEach(icon => {
          icon.style.color = titleColor;
        });

        // Ensure rendered SVGs use the same stroke/fill color as the title
        card.querySelectorAll('.subtask i svg').forEach(svg => {
          try {
            svg.style.color = titleColor;
            svg.setAttribute('stroke', titleColor);
            // keep fill none for outline icons; checked icons will still show stroke color
            svg.setAttribute('fill', 'none');
            // also update nested paths if lucide inserted them
            svg.querySelectorAll('*').forEach(el => {
              if (el.setAttribute) {
                el.setAttribute('stroke', titleColor);
                // avoid forcing fill on shapes that might be intended to be filled
                if (!el.getAttribute('fill') || el.getAttribute('fill') === 'none') {
                  el.setAttribute('fill', 'none');
                }
              }
            });
          } catch (e) {}
        });

        const divider = card.querySelector('.expand-divider');
        if (divider) divider.style.background = titleColor;

        // Color the add-subtask plus icon to match title color as well
        const addIconWrap = card.querySelector('.add-subtask i');
        if (addIconWrap) {
          try {
            addIconWrap.style.color = titleColor;
            const sv = addIconWrap.querySelector('svg');
            if (sv) {
              sv.style.color = titleColor;
              sv.setAttribute('stroke', titleColor);
              sv.setAttribute('fill', 'none');
              sv.querySelectorAll('*').forEach(el => { try { el.setAttribute('stroke', titleColor); if (!el.getAttribute('fill') || el.getAttribute('fill') === 'none') el.setAttribute('fill','none'); } catch(e){} });
            }
          } catch (e) {}
        }
      }

      // apply colors immediately so icons (plus-circle etc.) match the title on first render
      try { syncSubtaskColors(); } catch (e) { /* ignore */ }

      input.addEventListener("blur", syncSubtaskColors);

      // ======================================
      // LONG-PRESS FARBE
      // ======================================
      let pressTimer = null;
      let pressInterval = null;
      let lastColor = null;

      card.addEventListener("touchstart",()=>{
        clearTimeout(pressTimer);
        clearInterval(pressInterval);
        lastColor = null;

        pressTimer = setTimeout(()=>{
          if (card.dataset.active === "true") {
            let i = 0;
            pressInterval = setInterval(()=>{
              const col = cycleColors[i % cycleColors.length];
              card.style.background = col;
              card.dataset.color    = col;
              input.style.color     = darken(col);
              syncSubtaskColors();
              lastColor = col;
              i++;
            },900);
          }
        },300);
      });

      card.addEventListener("touchend",()=>{
        clearTimeout(pressTimer);
        clearInterval(pressInterval);
        if (lastColor) saveHabit(card);
      });

      // ======================================
      // TITLE SAVE
      // ======================================
      input.addEventListener("blur", ()=> { saveHabit(card); });
      input.addEventListener("keydown", (e)=>{
        if(e.key==="Enter"){ e.preventDefault(); input.blur(); }
      });

      // CARD EXPAND: helper to expand a card based on its vertical position
      function expandCard(cardEl) {
        if (!cardEl) return;
        if (cardEl.classList.contains('expanded')) return;

        const allCards = Array.from(document.querySelectorAll('.card'));
        if (allCards.length === 0) return;

        const rects = allCards.map(c => ({ c, rect: c.getBoundingClientRect(), top: c.getBoundingClientRect().top }));
        const sorted = rects.slice().sort((a,b) => a.top - b.top);
        const topRect = sorted[0].rect;
        const bottomRect = sorted[sorted.length - 1].rect;
        const cardRect = cardEl.getBoundingClientRect();

        const isTop = Math.abs(cardRect.top - topRect.top) < 4;
        const isBottom = Math.abs(cardRect.top - bottomRect.top) < 4;

        let targetTop = cardRect.top;
        let targetHeight = bottomRect.bottom - cardRect.top;

        if (isTop) {
          // top card: expand down to bottom of bottom card
          targetTop = cardRect.top;
          targetHeight = bottomRect.bottom - cardRect.top;
        } else if (!isTop && !isBottom) {
          // middle card: expand from top of top card to bottom of bottom card
          targetTop = topRect.top;
          targetHeight = bottomRect.bottom - topRect.top;
        } else if (isBottom) {
          // bottom card: expand upward to top of top card
          targetTop = topRect.top;
          targetHeight = cardRect.bottom - topRect.top;
        }

        const deltaY = targetTop - cardRect.top;

        // hide other cards
        allCards.forEach(c => {
          if (c !== cardEl) {
            gsap.to(c, { opacity: 0, duration: 0.25, ease: 'power1.out', pointerEvents: 'none' });
          }
        });

        // store original inline styles for restore
        cardEl.dataset.origInlineHeight = cardEl.style.height || '';
        cardEl.dataset.origInlineTransform = cardEl.style.transform || '';
        cardEl.dataset.origInlineZ = cardEl.style.zIndex || '';

        const expandArea = cardEl.querySelector('.expand-area');
        if (expandArea) expandArea.style.display = 'block';

        cardEl.style.zIndex = '9999';
        cardEl.classList.add('expanded');

        // add minimize button if missing — place it in the center of the bottom buttons row
        const buttonsRow = document.querySelector('.buttons-row');
        let bottomMin = buttonsRow ? buttonsRow.querySelector('.minimize-bottom-btn') : null;
        if (!bottomMin && buttonsRow) {
          bottomMin = document.createElement('button');
          bottomMin.className = 'minimize-bottom-btn';
          // transparent background, no shadow, icon will be white
          bottomMin.style.cssText = 'flex:0 0 60px; width:60px; height:60px; margin:0; border-radius:999px; background:transparent; border:none; display:flex; align-items:center; justify-content:center; cursor:pointer; z-index:10002; pointer-events:auto;';
          bottomMin.innerHTML = '<i data-lucide="minimize-2"></i>';
          // insert between addBtnEl and statsBtnEl
          const statsBtn = document.querySelector('.btn-stats');
          if (statsBtn && statsBtn.parentNode) statsBtn.parentNode.insertBefore(bottomMin, statsBtn);
          else if (buttonsRow) buttonsRow.appendChild(bottomMin);
          lucide.createIcons({ scope: bottomMin });

          // ensure it receives pointer events
          bottomMin.addEventListener('pointerdown', ev => { ev.stopPropagation(); });
          bottomMin.addEventListener('touchstart', ev => { ev.stopPropagation(); });
          bottomMin.addEventListener('touchend', ev => { ev.stopPropagation(); ev.preventDefault && ev.preventDefault(); try { bottomMin.click(); } catch(e){} });
        }

        // set icon color to white (no background button).
        // Also force the generated SVG stroke/fill to white in case lucide injected explicit attributes.
        if (bottomMin) {
          const icon = bottomMin.querySelector('i');
          if (icon) icon.style.color = '#fff';
          const svg = bottomMin.querySelector('svg');
          if (svg) {
            try {
              svg.style.color = '#fff';
              svg.setAttribute('stroke', '#fff');
              svg.setAttribute('fill', 'none');
              svg.setAttribute('stroke-width', svg.getAttribute('stroke-width') || '2');
              svg.style.width = svg.style.width || '22px';
              svg.style.height = svg.style.height || '22px';
            } catch (e) {}
          }
        }

        // hide the existing left/right bottom buttons with animation
        try {
          const addBtn = document.querySelector('.btn-plus');
          const homeBtn = document.querySelector('.btn-plus, .btn-half.btn-plus');
          const statsBtn = document.querySelector('.btn-stats');
          const leftBtn = document.getElementById('addBtn') || homeBtn;
          if (leftBtn) gsap.to(leftBtn, { opacity: 0, duration: 0.28, ease: 'power1.out', pointerEvents: 'none' });
          if (statsBtn) gsap.to(statsBtn, { opacity: 0, duration: 0.28, ease: 'power1.out', pointerEvents: 'none' });
        } catch (e) {}

        // attach handler to bottomMin
        if (bottomMin && !bottomMin.dataset.handler) {
          bottomMin.dataset.handler = '1';
          bottomMin.addEventListener('click', (e) => {
            e.stopPropagation(); e.preventDefault && e.preventDefault();

            // restore other cards
            allCards.forEach(c => {
              if (c !== cardEl) {
                gsap.to(c, { opacity: 1, duration: 0.28, ease: 'power1.out', pointerEvents: 'auto' });
              }
            });

            // hide expand area
            if (expandArea) expandArea.style.display = 'none';

            cardEl.classList.remove('expanded');

            // Before collapsing: remove placeholder/empty subtasks so they are not saved
            try {
              const subRows = Array.from(cardEl.querySelectorAll('.subtask'));
              subRows.forEach(r => {
                const ti = r.querySelector('.subtask-title');
                const titleText = (ti ? (ti.value || ti.textContent || ti.placeholder || '') : '').trim();
                if (!titleText || titleText.toLowerCase().includes('unteraufgabe')) {
                  r.parentNode && r.parentNode.removeChild(r);
                }
              });
              // update datasets and persist cleaned subtasks
              try { recalcFromSubtasks(); } catch(e) {}
              try { saveHabit(cardEl); } catch(e) {}
            } catch (e) {}

            // animate back to original computed height and position
            gsap.to(cardEl, {
              y: 0,
              height: cardRect.height,
              duration: 0.45,
              ease: 'power2.inOut',
              onComplete: () => {
                try { cardEl.style.removeProperty('height'); if (cardEl.dataset.origInlineTransform) cardEl.style.transform = cardEl.dataset.origInlineTransform; else cardEl.style.removeProperty('transform'); if (cardEl.dataset.origInlineZ) cardEl.style.zIndex = cardEl.dataset.origInlineZ; else cardEl.style.removeProperty('z-index'); } catch(e){}

                // remove the bottom minimize button and restore bottom bar buttons
                try {
                  const statsBtn = document.querySelector('.btn-stats');
                  const leftBtn = document.getElementById('addBtn');
                  const bottom = document.querySelector('.minimize-bottom-btn');
                  if (bottom && bottom.parentNode) bottom.parentNode.removeChild(bottom);
                  if (leftBtn) gsap.to(leftBtn, { opacity: 1, duration: 0.28, ease: 'power1.out', pointerEvents: 'auto' });
                  if (statsBtn) gsap.to(statsBtn, { opacity: 1, duration: 0.28, ease: 'power1.out', pointerEvents: 'auto' });
                } catch(e){}
              }
            });
          });
        }

        // animate expansion (translateY + height)
        gsap.to(cardEl, { y: deltaY, height: targetHeight, duration: 0.45, ease: 'power2.out' });
      }

      // ======================================
      // CARD CLICK: Expand card according to position rules
      // ======================================
      card.addEventListener("click", async (e) => {
        // Ignore clicks coming from expanded subtask area or from subtask controls
        if (e.target.closest(".expand-area") || e.target.closest('.subtask') || e.target.closest('.subtasks') || e.target.closest('.add-subtask')) {
          return;
        }

        // If QR-Mode, do not toggle or expand
        if (card.dataset.qr === "true") return;

        // If there are no subtasks present, perform the original toggle behaviour
        const hasSubtasks = card.querySelectorAll('.subtask').length > 0;
        if (!hasSubtasks) {
          // GPS Check (if habit requires an address)
          const requiredAddress = card.dataset.location;
          if (requiredAddress && requiredAddress.length > 0) {
            e.stopPropagation();
            navigator.geolocation.getCurrentPosition(async (pos) => {
              const userLat = pos.coords.latitude;
              const userLon = pos.coords.longitude;

              const geo = await geocodeAddress(requiredAddress);
              if (!geo) { shake(card); return; }

              const dist = haversine(userLat, userLon, geo.lat, geo.lon);

              if (dist > 100) { shake(card); return; }

              // OK → Toggle
              proceedHabitToggle(card);

            }, () => shake(card));

            return;
          }

          // Normal toggle when no subtasks
          proceedHabitToggle(card);
          return;
        }

        // Otherwise (has subtasks) expand the card
        expandCard(card);
      });

      // ======================================
      // DOUBLE TAP → Progress Reset (für ALLE Habit-Typen)
      // ======================================
      let lastTap = 0;
      card.addEventListener("touchend", async (e) => {
        // PATCH 3: Ignore touches inside expanded subtask area or subtask controls
        if (e.target.closest(".expand-area") || e.target.closest('.subtask') || e.target.closest('.subtasks') || e.target.closest('.add-subtask')) {
          return;
        }
        const now = Date.now();
        if (now - lastTap < 300) {
          // Double Tap erkannt
          const habitId = card.dataset.habitId;

          // DB Reset
          const { error } = await supabaseClient
            .from("habits")
            .update({ progress: 0 })
            .eq("id", habitId);

          if (error) {
            console.error("doubleTap reset error:", error);
            return;
          }

          // Lokales Update
          card.dataset.progress = 0;
          card.dataset.active = "false";

          const input = card.querySelector(".card-input");
          card.style.background = "#e4e4e4";
          input.style.color = "#666";

          const counter = card.querySelector(".counter");
          const goal    = parseInt(card.dataset.goal) || 1;
          const isQR    = card.dataset.qr === "true";

          if (isQR) {
            // QR Habit → 0 KCAL
            counter.style.display = "block";
            counter.textContent = "0 KCAL";
          } else {
            // Normale Habits
            if (goal >= 2) {
              counter.style.display = "block";
              counter.textContent = "0/" + goal;
            } else {
              counter.style.display = "none";
            }
          }
        }
        lastTap = now;
      });
    }


    
    function proceedHabitToggle(card) {
      const input   = card.querySelector(".card-input");
      const counter = card.querySelector(".counter");

      if (!input.textContent.trim()) return;

      // If subtasks exist, they must all be completed first
      const hasSubtasks = card.querySelectorAll(".subtask").length > 0;
      const subtasksComplete = card.dataset.subtasksComplete === "true";

      if (hasSubtasks && !subtasksComplete) {
        shake(card);
        return;
      }

      let goal     = parseInt(card.dataset.goal) || 0;
      let progress = parseInt(card.dataset.progress) || 0;
      let active   = card.dataset.active === "true";
      const idx    = parseInt(card.dataset.index);

      if (goal <= 1) {
        if (active) {
          active   = false;
          progress = 0;
          card.style.background = "#e4e4e4";
          card.dataset.color    = "#e4e4e4";
          input.style.color     = "#666";
        } else {
          active   = true;
          progress = 1;

          let col = card.dataset.color;
          if (!col || col === "#e4e4e4") col = cycleColors[idx % cycleColors.length];

          card.style.background = col;
          card.dataset.color    = col;
          input.style.color     = darken(col);
        }
      } else {
        if (progress < goal) {
          progress += 1;
          active = true;

          let col = card.dataset.color;
          if (!col || col === "#e4e4e4") col = cycleColors[idx % cycleColors.length];

          card.style.background = col;
          card.dataset.color    = col;
          input.style.color     = darken(col);
        } else {
          return;
        }
      }

      card.dataset.progress = progress;
      card.dataset.active   = active ? "true" : "false";

      // Ensure subtitle/subtask colors follow the title color immediately
      try {
        const titleColor = input.style.color || darken(card.dataset.color || '#e4e4e4');
        card.querySelectorAll('.subtask-title').forEach(el => { el.style.color = titleColor; });
        card.querySelectorAll('.subtask i').forEach(icon => { icon.style.color = titleColor; });
        const divider = card.querySelector('.expand-divider'); if (divider) divider.style.background = titleColor;
      } catch (e) { /* ignore if elements missing */ }

      if (goal >= 2) {
        counter.style.display = "block";
        counter.textContent   = progress + "/" + goal;
      } else {
        counter.style.display = "none";
      }

      // Reset subtasks after successful completion
      const rows = card.querySelectorAll(".subtask");
      if (rows.length > 0) {
        rows.forEach(r => {
          r.dataset.done = "false";
          const icon = r.querySelector("i");
          if (icon) icon.setAttribute("data-lucide", "circle");
        });
        card.dataset.subtasksComplete = "false";
        lucide.createIcons();
      }

      saveHabit(card);
    }
    
    async function geocodeAddress(addr) {
      const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(addr)}`;
      const resp = await fetch(url);
      const json = await resp.json();

      if (!json || json.length === 0) return null;

      return {
        lat: parseFloat(json[0].lat),
        lon: parseFloat(json[0].lon)
      };
    }
    
    function haversine(lat1, lon1, lat2, lon2) {
      function toRad(x) { return x * Math.PI / 180; }

      const R = 6371000; // Meter
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);

      const a =
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
        Math.sin(dLon/2) * Math.sin(dLon/2);

      return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }

    async function saveHabit(card) {
      if (!currentUser) return;

      const habitId = card.dataset.habitId;
      const input   = card.querySelector(".card-input");
      const title = input.textContent.trim();
      const color   = card.dataset.color || "#e4e4e4";
      const progress  = parseInt(card.dataset.progress) || 0;
      const goal     = parseInt(card.dataset.goal)     || 0;

      if (!habitId) return;

      // collect up to 3 subtasks from the DOM
      const rows = card.querySelectorAll('.subtask');
      const updates = {
        title, color, progress, goal
      };

      // initialize sub fields to defaults
      updates.sub1_title = '';
      updates.sub1_progress = 0;
      updates.sub2_title = '';
      updates.sub2_progress = 0;
      updates.sub3_title = '';
      updates.sub3_progress = 0;

      Array.from(rows).slice(0,3).forEach((r, i) => {
        const ti = r.querySelector('.subtask-title');
        const titleText = ti ? ti.value || ti.textContent || ti.placeholder || '' : '';
        const done = r.dataset.done === 'true' ? 1 : 0;
        const idx = i + 1;
        updates[`sub${idx}_title`] = titleText;
        updates[`sub${idx}_progress`] = done;
      });

      const { error } = await supabaseClient
        .from("habits")
        .update(updates)
        .eq("id", habitId);

      if (error) console.error("saveHabit error:", error);
    }

    // Add-Button: erstellt nur DB-Datensatz, niemals lokal
    addBtnEl.addEventListener("click", async () => {
      if (addBtnEl.dataset.mode === "stats") {
        addBtnEl.dataset.mode = "main";
        statsOpen = false;
        gsap.to("#statsView",{top:"100svh",duration:0.42,ease:"power1.in"});
        refreshAddButtonIcon();
        return;
      }

      if (habits.length >= 3) return;

      if (!currentUser) {
        const { data } = await supabaseClient.auth.getUser();
        currentUser = data.user;
        if (!currentUser) return;
      }

      const { data, error } = await supabaseClient
        .from("habits")
        .insert({
          user_id: currentUser.id,
          title: "",
          color: "#e4e4e4",
          progress: 0,
          goal: 1,
          appear_once: false
        })
        .select()
        .single();

      if (error) {
        console.error("insert habit error:", error);
        return;
      }

      habits.push(data);
      const index = habits.length - 1;
      createCardFromHabit(data, index, 0);
      refreshAddButtonIcon();
    });

  async function loadOtherUser() {
    if (!currentUser) return null;

    const { data, error } = await supabaseClient
      .from("users_public")
      .select("id, display_name")
      .neq("id", currentUser.id)
      .limit(1);

    if (error) {
      console.error("loadOtherUser error:", error);
      return null;
    }

    return data && data.length > 0 ? data[0] : null;
  }

  async function loadHabitsForUser(userId) {
    const { data, error } = await supabaseClient
      .from("habits")
      .select(`id, user_id, title, color, progress, goal, location_address, qr_enabled, sub1_title, sub1_progress, sub2_title, sub2_progress, sub3_title, sub3_progress, inserted_at`)
      .eq("user_id", userId)
      .order("inserted_at", { ascending: true })
      .limit(3);

    if (error) {
      console.error("loadHabitsForUser error:", error);
      return [];
    }
    return data || [];
  }
  
  function barsHtml(habits) {
    let html = "";
    for (let i = 0; i < 3; i++) {
      const h = habits[i];

      if (!h) {
      html += `
        <div class="stat-bar" style="position:relative;">
          <div class="stat-fill" style="width:0%"></div>
        </div>`;
        continue;
      }

      const x = h.progress || 0;
      const y = h.goal     || 0;
      const rawTitle = h.title || "";
      const hasTitle = rawTitle.trim().length > 0;
      const color = h.color || "#e5e7eb";

      let percent = 0;

      // QR habit: max value = 21000 kcal
      if (h.qr_enabled === true || h.qr_enabled === "true") {
        const maxKcal = 21000;
        const kcal = parseInt(h.progress) || 0;
        percent = Math.min(100, Math.round((kcal / maxKcal) * 100));
      }
      else {
        if (y > 0) {
          percent = (y === 1)
            ? (x >= 1 ? 100 : 0)
            : Math.round((x / y) * 100);
        }
      }

      html += `
        <div class="stat-bar" style="position:relative;">

          <!-- Fortschrittsbalken -->
          <div style="
            position:absolute;
            inset:0;
            width:${percent}%;
            background:${color};
            border-radius:16px;
            z-index:1;
          "></div>

          <!-- Text nur wenn vorhanden -->
          <div style="
            position:relative;
            z-index:2;
            height:100%;
            display:flex;
            align-items:center;
            padding-left:12px;
            font-weight:700;
            color:var(--c-text);
            white-space:nowrap;
            overflow:hidden;
            text-overflow:ellipsis;
          ">
            ${hasTitle ? rawTitle : ""}
          </div>

        </div>
      `;
    }

    return html;
  }
    
    async function loadStreakForUser(userId) {
      if (!userId) return 0;

      const { data, error } = await supabaseClient
        .from("streak_view")
        .select("current_streak")
        .eq("user_id", userId)
        .maybeSingle();

      if (error) {
        console.error("loadStreakForUser error:", error);
        return 0;
      }

      return data?.current_streak ?? 0;
    }
    
    async function renderNotifications() {
      const rows = await loadNotifications(30);

      const itemsHtml = (rows.length > 0)
        ? rows.map(r => {
            const isUnread = !r.read_at;
            const title = (r.title || "").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            const body = (r.body || "").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            const opacity = isUnread ? 1 : 0.55;
            return `
              <div class="notification-item" style="opacity:${opacity};">
                <div style="font-weight:800; margin-bottom:4px;">${title}</div>
                <div style="font-weight:600;">${body}</div>
              </div>
            `;
          }).join("")
        : `
          <div class="notification-item">
            <div style="font-weight:800; margin-bottom:4px;">Willkommen</div>
            <div style="font-weight:600;">Hier erscheinen bald echte Benachrichtigungen.</div>
          </div>
          <div class="notification-item">
            <div style="font-weight:800; margin-bottom:4px;">Tipp</div>
            <div style="font-weight:600;">Du kannst später Push-Aktionen aus deinen Workflows auslösen.</div>
          </div>
        `;

      notificationsViewEl.innerHTML = `
        <div class="notification-title">Benachrichtigungen</div>
        ${itemsHtml}
      `;
    }

    async function renderStats(myHabits, otherHabits, otherUserData) {
      // --- Ensure otherUserData is loaded before rendering ---
      if (!otherUserData) {
        try {
          otherUserData = await loadOtherUser();
          otherUser = otherUserData; // keep global in sync
          if (otherUserData) {
            otherHabits = await loadHabitsForUser(otherUserData.id);
          }
        } catch (e) {
          console.error("Failed to load other user for stats rendering:", e);
        }
      }
      const myName = (
        currentUser?.user_metadata?.display_name ||
        currentUser?.email?.split("@")[0] ||
        "Du"
      );

      const myStreak = await loadStreakForUser(currentUser.id);
      const otherStreak = otherUserData
        ? await loadStreakForUser(otherUserData.id)
        : null;

      let html = "";

      // === Mein Name + Streak rechts perfekt bündig ===
      html += `
        <div style="
          display:flex;
          justify-content:space-between;
          align-items:flex-end;
          margin-bottom:20px;
        ">

          <!-- Name: klickbar / editierbar -->
          <div id="editableNameWrapper" style="display:flex; align-items:flex-end; gap:6px;">
            <div id="editableName" class="stats-name" style="line-height:1; margin:0; padding:0; cursor:pointer;">
              ${myName}
            </div>
          </div>

          <!-- Streak -->
          <div style="
            display:flex;
            align-items:flex-end;
            gap:6px;
            font-size:1.5rem;
            font-weight:700;
            line-height:1;
          ">
            ${
              otherUserData && myStreak !== otherStreak
                ? `<i data-lucide="${myStreak > otherStreak ? 'trophy' : 'turtle'}" style="width:22px; height:22px;"></i>`
                : ``
            }
            <span>${myStreak}</span>
          </div>

        </div>
      `;

      html += barsHtml(myHabits);

      // === Optional: anderer User ===
      if (otherUserData) {
        const otherName = otherUserData.display_name || "Freund:in";
        // otherStreak already loaded above

        html += `<div style="height:40px"></div>`;

        html += `
          <div style="
            display:flex;
            justify-content:space-between;
            align-items:flex-end;
            margin-bottom:20px;
          ">
            <div class="stats-name" style="
              line-height:1;
              margin:0;
              padding:0;
            ">${otherName}</div>

            <div style="
              display:flex;
              align-items:flex-end;
              gap:6px;
              font-size:1.5rem;
              font-weight:700;
              line-height:1;
            ">
              ${
                myStreak !== otherStreak
                  ? `<i data-lucide="${myStreak > otherStreak ? 'turtle' : 'trophy'}" style="width:22px; height:22px;"></i>`
                  : ``
              }
              <span>${otherStreak}</span>
            </div>
          </div>
        `;

        html += barsHtml(otherHabits);

        // Two buttons side-by-side with equal width
        html += `
          <div class="stats-reset-wrap" style="gap:12px;">
            <button id="statsCommitBtn" class="stats-reset-btn blue">
              <div class="stats-reset-progress" id="statsCommitProgress"></div>
              <div class="stats-reset-btn-content" id="statsCommitContent">
                <i data-lucide="check-circle-2"></i>
              </div>
            </button>
          </div>
        `;
      }

      statsViewEl.innerHTML = html;
      lucide.createIcons({ scope: statsViewEl });
      // --- NAME-EDITIERUNG AKTIVIEREN ---
      const editableName = document.getElementById("editableName");

      // --- STATS RESET & COMMIT BUTTONS (shared hold logic) ---
      const HOLD_DURATION = 5000;

      // ---------- COMMIT BUTTON ----------
      const statsCommitBtn = document.getElementById("statsCommitBtn");
      const statsCommitProgress = document.getElementById("statsCommitProgress");
      const statsCommitContent = document.getElementById("statsCommitContent");

      function setupHoldButton(btn, progressEl, contentEl, onExecute, hintText) {
        if (!btn) return;

        let holdTimer = null;
        let startTime = null;

        const resetUI = () => {
          progressEl.style.width = "0%";
          btn.classList.remove("hint");
          lucide.createIcons({ scope: contentEl });
        };

        const startHold = () => {
          startTime = Date.now();
          holdTimer = requestAnimationFrame(updateHold);
        };

        const updateHold = () => {
          const elapsed = Date.now() - startTime;
          const percent = Math.min(100, (elapsed / HOLD_DURATION) * 100);
          progressEl.style.width = percent + "%";

          if (elapsed >= HOLD_DURATION) {
            cancelAnimationFrame(holdTimer);
            onExecute().finally(resetUI);
          } else {
            holdTimer = requestAnimationFrame(updateHold);
          }
        };

        const cancelHold = () => {
          if (holdTimer) cancelAnimationFrame(holdTimer);
          resetUI();
        };

        btn.addEventListener("click", () => {
          btn.classList.add("hint");
          contentEl.textContent = hintText;
        });

        btn.addEventListener("mousedown", startHold);
        btn.addEventListener("touchstart", startHold);

        btn.addEventListener("mouseup", cancelHold);
        btn.addEventListener("mouseleave", cancelHold);
        btn.addEventListener("touchend", cancelHold);
        btn.addEventListener("touchcancel", cancelHold);
      }


      // ---------- COMMIT / STREAK EXECUTION ----------
      setupHoldButton(
        statsCommitBtn,
        statsCommitProgress,
        statsCommitContent,
        async () => {
          const users = otherUser
            ? [currentUser.id, otherUser.id]
            : [currentUser.id];

          for (const uid of users) {
            const habits = await loadHabitsForUser(uid);

            const allFull =
              habits.length === 3 &&
              habits.every(h => {
                if (h.qr_enabled === true || h.qr_enabled === "true") return false;
                const goal = h.goal || 0;
                return goal > 0 && h.progress >= goal;
              });

            const { data: streakRow, error: readErr } = await supabaseClient
              .from("streak_view")
              .select("current_streak, longest_streak")
              .eq("user_id", uid)
              .single();

            if (readErr) {
              console.error("streak read error", readErr);
              continue;
            }

            const current = streakRow?.current_streak ?? 0;
            const longest = streakRow?.longest_streak ?? 0;

            const nextCurrent = allFull ? current + 1 : 0;
            const nextLongest = Math.max(longest, nextCurrent);

            await supabaseClient
              .from("streak_view")
              .upsert(
                {
                  user_id: uid,
                  current_streak: nextCurrent,
                  longest_streak: nextLongest,
                  last_update: new Date().toISOString()
                },
                { onConflict: "user_id" }
              );

            // ➜ Progress IMMER zurücksetzen (RPC)
            await supabaseClient.rpc(
              "reset_progress_for_users",
              { uids: [uid] }
            );
          }

          // --- Create notification for the other user ---
          if (otherUser && otherUser.id && otherUser.id !== currentUser.id) {
            const title = "Streak-Update";
            const body =
              "Die andere Person hat ihren Tages-Commit abgeschlossen. Schau dir den aktuellen Stand an.";

            const { error: notifErr } = await supabaseClient
              .from("notification_message")
              .insert({
                user_id: otherUser.id,
                type: "streak_commit",
                title,
                body,
                created_at: new Date().toISOString()
              });

            if (notifErr) {
              console.error("notification_message insert error:", notifErr);
            }
          }

          // --- Create self praise notification for current user ---
          if (currentUser && currentUser.id) {
            const selfTitle = "Stark!";
            const selfBody =
              "Du hast deinen Tages-Commit erfolgreich abgeschlossen. Gute Arbeit – bleib dran.";

            const { error: selfNotifErr } = await supabaseClient
              .from("notification_message")
              .insert({
                user_id: currentUser.id,
                type: "streak_commit",
                title: selfTitle,
                body: selfBody,
                created_at: new Date().toISOString()
              });

            if (selfNotifErr) {
              console.error("self notification_message insert error:", selfNotifErr);
            }
          }

          await safeLoadHabits();
          await refreshStatsLive();
        },
        "5 Sekunden halten"
      );

      editableName.addEventListener("click", () => {
        const current = editableName.textContent.trim();

        // Input erzeugen
        editableName.innerHTML = `
          <input id="nameEditInput"
                 type="text"
                 value="${current}"
                 style="
                   font-size:2rem;
                   font-weight:700;
                   border:none;
                   outline:none;
                   background:transparent;
                   border-bottom:2px solid #ccc;
                   width:100%;
                 "
          />
        `;

        const input = document.getElementById("nameEditInput");
        input.focus();
        input.setSelectionRange(current.length, current.length);

        async function save() {
          const newName = input.value.trim();
          if (!newName || newName === current) {
            editableName.textContent = current;
            return;
          }

          const { error } = await supabaseClient.auth.updateUser({
            data: { display_name: newName }
          });

          if (error) {
            console.error("Name update error:", error);
            editableName.textContent = current;
            return;
          }

          // UI aktualisieren
          editableName.textContent = newName;

          // Stats aktualisieren (optional)
          await refreshStatsLive();
        }

        input.addEventListener("blur", save);
        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            save();
          }
        });
      });
      lucide.createIcons();
    }

  async function refreshStatsLive() {
    if (!currentUser) return;

    const myHabits    = await loadHabitsForUser(currentUser.id);
    const otherHabits = otherUser ? await loadHabitsForUser(otherUser.id) : [];
    renderStats(myHabits, otherHabits, otherUser);
  }

    statsBtnEl.addEventListener("click", async () => {

      // Close notifications if open
      gsap.to("#notificationsView", {
        top: "100svh",
        duration: 0.42,
        ease: "power1.in"
      });

      addBtnEl.dataset.mode = "stats";
      statsOpen = true;

      const myHabits = habits;
      let otherHabits = [];
      let otherUserData = otherUser;

      if (!otherUserData) {
        otherUserData = await loadOtherUser();
        otherUser = otherUserData;
      }

      if (otherUserData) {
        otherHabits = await loadHabitsForUser(otherUserData.id);
      }

      await renderStats(myHabits, otherHabits, otherUserData);

      gsap.to("#statsView", {
        top: "0svh",
        duration: 0.42,
        ease: "power1.out"
      });

      refreshAddButtonIcon();
    });

  // === Shake Detection + UNO-Wiggle/Hide ===

  let lastShakeTime = 0;
  const SHAKE_THRESHOLD = 18; // ggf. anpassen

  function setupShakeDetection() {
    if (typeof window === "undefined") return;
    if (!("DeviceMotionEvent" in window)) return;

    if (typeof DeviceMotionEvent !== "undefined" &&
        typeof DeviceMotionEvent.requestPermission === "function") {
      document.body.addEventListener("click", function reqOnce() {
        DeviceMotionEvent.requestPermission().catch(()=>{}).finally(()=>{
          document.body.removeEventListener("click", reqOnce);
        });
      });
    }

    window.addEventListener("devicemotion", handleDeviceMotion, false);
  }

  function handleDeviceMotion(event) {
    const acc = event.accelerationIncludingGravity || event.acceleration;
    if (!acc) return;

    const x = acc.x || 0;
    const y = acc.y || 0;
    const z = acc.z || 0;
    const magnitude = Math.sqrt(x*x + y*y + z*z);

    const now = Date.now();
    if (magnitude > SHAKE_THRESHOLD && now - lastShakeTime > 1200) {
      lastShakeTime = now;
      onShakeDetected();
    }
  }

  function onShakeDetected() {
    if (!habits || habits.length === 0) return;
    if (deletePanelVisible) return;

    showDeletePanelAndAnimateCards();
  }

  function showDeletePanelAndAnimateCards() {
    deletePanelVisible = true;
    clearTimeout(deleteTimeout);

    const cards = document.querySelectorAll(".card");
    const buttonsRow = document.querySelector(".buttons-row");
    if (!buttonsRow || cards.length === 0) return;

    const buttonsRect = buttonsRow.getBoundingClientRect();
    let panelTopBase = null;

    cards.forEach((card, idx) => {
      const rect = card.getBoundingClientRect();
      const targetTop = buttonsRect.top - rect.height / 2; // Karte halb hinter Buttons
      const dy = targetTop - rect.top;

      if (idx === 0) {
        panelTopBase = targetTop;
      }

      const tl = gsap.timeline();
      tl.to(card, { rotation:-2, duration:0.08, ease:"power1.out" })
        .to(card, { rotation:2, repeat:4, yoyo:true, duration:0.08, ease:"sine.inOut" })
        .to(card, { rotation:0, y:dy, duration:0.38, ease:"power2.out" }, "-=0.08");
    });

    // Panel anzeigen und direkt oberhalb der obersten Karte positionieren
    deletePanel.style.display = "flex";
    deletePanel.style.opacity = "0";

    requestAnimationFrame(() => {
      const panelHeight = deletePanel.offsetHeight || 24;
      let panelTop = 12;
      if (panelTopBase !== null) {
        panelTop = panelTopBase - panelHeight - 8;
        if (panelTop < 8) panelTop = 8;
      }
      deletePanel.style.top = panelTop + "px";

      gsap.to(deletePanel, {
        opacity:1,
        y:0,
        duration:0.25,
        ease:"power1.out"
      });
    });

    // nach 5 Sekunden Inaktivität wieder zurück animieren (ohne Löschen)
    deleteTimeout = setTimeout(() => {
      reverseShakeAnimation();
    }, 5000);
  }

  function reverseShakeAnimation() {
    if (!deletePanelVisible) return;
    deletePanelVisible = false;
    clearTimeout(deleteTimeout);

    const cards = document.querySelectorAll(".card");

    cards.forEach(card => {
      const tl = gsap.timeline();
      tl.to(card, {
          y: "-10",
          rotation: -2,
          duration: 0.12,
          ease: "power1.out"
        })
        .to(card, {
          y: 0,
          rotation: 0,
          duration: 0.28,
          ease: "power2.inOut"
        });
    });

    gsap.to(deletePanel, {
      opacity:0,
      y:4,
      duration:0.22,
      ease:"power1.in",
      onComplete: () => {
        deletePanel.style.display = "none";
        deletePanel.style.y = 0;
      }
    });
  }

  async function deleteAllHabits() {
    clearTimeout(deleteTimeout);

    if (currentUser && habits && habits.length > 0) {
      const ids = habits.map(h => h.id);
      const { error } = await supabaseClient
        .from("habits")
        .update({ progress: 0 })
        .in("id", ids);

      if (error) {
        console.error("resetAllHabits error:", error);
      }
    }

    // Lokale Daten aktualisieren
    habits = habits.map(h => ({ ...h, progress: 0 }));

    clearAllSlots();
    habits.forEach((habit, i) => {
      createCardFromHabit(habit, i, 0);
    });
    refreshAddButtonIcon();

    reverseShakeAnimation();
  }

  deleteAllBtn.addEventListener("click", () => {
    deleteAllHabits();
  });

  deletePanel.addEventListener("click", () => {
    // Optional: hier könnte man das Timeout abbrechen etc.
  });

  // Login-Kreis schwebend animieren
  startLoginCircleFloat();

  /*
    SQL zum Sicherstellen, dass die Spalte "color" existiert:

    ALTER TABLE public.habits
    ADD COLUMN IF NOT EXISTS color text DEFAULT '#e4e4e4';

    Aktiv-Status wird logisch abgeleitet über:
      progress > 0  => aktiv
      progress = 0  => inaktiv
  */
    
    async function requestAllPermissions() {
      // Notifications
      if (Notification.permission !== "granted") {
        await Notification.requestPermission();
      }

      // Motion
      if (typeof DeviceMotionEvent !== "undefined" &&
          typeof DeviceMotionEvent.requestPermission === "function") {
        await DeviceMotionEvent.requestPermission().catch(()=>{});
      }

      // Geo
      navigator.geolocation.getCurrentPosition(()=>{}, ()=>{}, {
        enableHighAccuracy: true
      });
    }

    // requestAllPermissions();   // Removed as per instructions
    
    function urlBase64ToUint8Array(base64String) {
      const padding = '='.repeat((4 - base64String.length % 4) % 4);
      const base64 = (base64String + padding)
        .replace(/-/g, '+')
        .replace(/_/g, '/');

      const rawData = atob(base64);
      const outputArray = new Uint8Array(rawData.length);

      for (let i = 0; i < rawData.length; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
      }
      return outputArray;
    }

    async function subscribeUserToPush() {
      const reg = await navigator.serviceWorker.ready;

      const vapidKey = urlBase64ToUint8Array("BIuQ1Oi-yAKNjlbzj8r_wUjBY9Q1GRKzr7ZM_CM3ZDZOXHm0HllkPnX4s7H6AEKqIBpDvTdHqgLgo7VjpGW68f0");

      const sub = await reg.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: vapidKey
      });

      const { error } = await supabaseClient
        .from("push_subscriptions")
        .insert({
          user_id: currentUser.id,
          endpoint: sub.endpoint,
          p256dh: btoa(String.fromCharCode(...new Uint8Array(sub.getKey("p256dh")))),
          auth: btoa(String.fromCharCode(...new Uint8Array(sub.getKey("auth"))))
        });

      if (error) console.error("push subscribe error", error);
    }
    
     (async () => {
        await requestAllPermissions();
      await subscribeUserToPush();
    })();
    
    function getQRParam() {
      const params = new URLSearchParams(window.location.search);
      return params.get("qr"); // z.B. ?qr=ABC123
    }
    

    // === QR Info Modal Handler ===
function showQRInfo(title, kcal, d1, d2, d3) {
  return new Promise(resolve => {
    document.getElementById("qrInfoTitle").textContent = title || "";
    document.getElementById("qrInfoKcal").textContent = `${kcal} KCAL`;

    document.getElementById("qrInfoDate1").innerHTML =
      `<i data-lucide="hand-helping" style="width:20px;height:20px;"></i> ${d1 || "-"}`;

    document.getElementById("qrInfoDate2").innerHTML =
      `<i data-lucide="snowflake" style="width:20px;height:20px;"></i> ${d2 || "-"}`;

    document.getElementById("qrInfoDate3").innerHTML =
      `<i data-lucide="calendar-clock" style="width:20px;height:20px;"></i> ${d3 || "-"}`;

    lucide.createIcons();

    const scr = document.getElementById("qrInfoScreen");
    scr.style.display = "flex";

    const cards = document.querySelectorAll(".card");
    const infoBox = document.getElementById("qrInfoBox");

    // Neues, stabileres Ziel-Y berechnet den Abstand anhand der tatsächlichen Position der InfoBox
    const infoRect = infoBox.getBoundingClientRect();
    const safeOffset = 40; // zusätzlicher Platz, damit die Karten garantiert unter die Box rutschen

    cards.forEach(card => {
      const cardRect = card.getBoundingClientRect();
      const targetY = (infoRect.bottom + safeOffset) - cardRect.top;

      gsap.to(card, { y: targetY, duration: 0.42, ease: "power2.out" });
    });

    const okBtn = document.getElementById("qrInfoOK");
    const cancelBtn = document.getElementById("qrInfoCancel");

    function resetCards() {
      scr.style.display = "none";
      cards.forEach(card => {
        gsap.to(card, { y: 0, duration: 0.42, ease: "power2.out" });
      });
    }

    okBtn.onclick = () => {
      resetCards();
      resolve(true);
    };

    cancelBtn.onclick = () => {
      resetCards();
      resolve(false);
    };
  });
}
    
    function isToday(dateStr) {
      if (!dateStr) return false;
      const d = new Date(dateStr);
      const today = new Date();

      return (
        d.getFullYear() === today.getFullYear() &&
        d.getMonth() === today.getMonth() &&
        d.getDate() === today.getDate()
      );
    }
    
async function processQRFlow(qrId) {
  try {
    if (!qrId) return;

    // URL cleanup
    if (window.history && window.history.replaceState) {
      const cleanUrl = window.location.origin + window.location.pathname;
      window.history.replaceState({}, "", cleanUrl);
    }

    // Ensure user
    if (!currentUser) {
      const { data } = await supabaseClient.auth.getUser();
      currentUser = data?.user || null;
      if (!currentUser) return;
    }

    // Load QR row
    const { data: qrRow, error: qrErr } = await supabaseClient
      .from("qr_codes")
      .select("*")
      .eq("code", qrId)
      .single();

    if (qrErr || !qrRow) return;

    const kcal = parseInt(qrRow.kcal_value) || 0;
    if (kcal <= 0) return;

    // Daily limit
    if (isToday(qrRow.last_scanned)) {
      return;
    }

    // Load QR-enabled habit
    const { data: habit, error: hErr } = await supabaseClient
      .from("habits")
      .select("*")
      .eq("user_id", currentUser.id)
      .eq("qr_enabled", true)
      .limit(1)
      .maybeSingle();

    if (hErr || !habit) return;

    // Confirmation dialog
    const ok = await showQRInfo(
      qrRow.internal_note,
      kcal,
      qrRow.date_manufactured,
      qrRow.date_cooled,
      qrRow.date_planned
    );
    if (!ok) return;

    // Add kcal
    const newProgress = (parseInt(habit.progress) || 0) + kcal;

    const { error: updErr } = await supabaseClient
      .from("habits")
      .update({ progress: newProgress })
      .eq("id", habit.id);

    if (updErr) return;

    // Update last scanned
    const today = new Date().toISOString().substring(0, 10);

    await supabaseClient
      .from("qr_codes")
      .update({ last_scanned: today })
      .eq("id", qrRow.id);

    // Reload UI
    await safeLoadHabits();
    showAppAfterDataLoaded();

  } catch (err) {
    console.error("processQRFlow fatal error:", err);
  }
}
    

  
    
</script>

<!-- QR INFO SCREEN (Text, no modal look) -->
<div id="qrInfoScreen" style="
  position:fixed;
  inset:0;
  background:transparent;
  display:none;
  justify-content:center;
  align-items:center;
  z-index:999998;
  pointer-events:none;
">
  <div id="qrInfoBox" style="
    pointer-events:auto;
    text-align:center;
    font-size:22px;
    font-weight:700;
    color:var(--c-text);
    background:var(--c-card);
    line-height:1.4;
  ">
  <div id="qrInfoTitle" style="
    font-size:20px;
    font-weight:700;
    margin-bottom:10px;
  "></div>
    <div id="qrInfoKcal"></div>

    <div style="margin-top:12px; font-size:18px; font-weight:600;">
      <div id="qrInfoDate1" style="display:flex; align-items:center; gap:8px; justify-content:center;"></div>
      <div id="qrInfoDate2" style="display:flex; align-items:center; gap:8px; justify-content:center; margin-top:6px;"></div>
      <div id="qrInfoDate3" style="display:flex; align-items:center; gap:8px; justify-content:center; margin-top:6px;"></div>
    </div>

    <div style="display:flex; justify-content:center; gap:16px; margin-top:24px;">
      <button id="qrInfoOK" style="
        padding:12px 22px;
        border-radius:12px;
        border:none;
        background:#000;
        color:white;
        font-size:16px;
        font-weight:600;
      ">OK</button>

      <button id="qrInfoCancel" style="
        padding:12px 22px;
        border-radius:12px;
        border:none;
        background:#ef4444;
        color:white;
        font-size:16px;
        font-weight:600;
      ">Abbrechen</button>
    </div>
  </div>
</div>

<!-- QR CONFIRMATION MODAL -->
<div id="qrConfirmOverlay" style="
  position:fixed;
  inset:0;
  background:rgba(0,0,0,0.35);
  backdrop-filter:blur(2px);
  display:none;
  justify-content:center;
  align-items:center;
  z-index:999999;
">
  <div id="qrConfirmBox" style="
    background:var(--c-card);
    color:var(--c-text);
    padding:24px;
    border-radius:20px;
    width:80%;
    max-width:340px;
    text-align:center;
    box-shadow:0 6px 20px rgba(0,0,0,0.2);
  ">
    <div id="qrConfirmText" style="
      font-size:18px;
      font-weight:600;
      margin-bottom:24px;
    ">
      Soll der Wert hinzugefügt werden?
    </div>

    <div style="display:flex; justify-content:center; gap:16px;">
      <button id="qrConfirmYes" style="
        flex:1;
        padding:12px;
        border-radius:12px;
        border:none;
        background:#000;
        color:white;
        font-size:16px;
        font-weight:600;
      ">Ja</button>

      <button id="qrConfirmNo" style="
        flex:1;
        padding:12px;
        border-radius:12px;
        border:none;
        background:#ef4444;
        color:#ffffff;
        font-size:16px;
        font-weight:600;
      ">Nein</button>
    </div>
  </div>
</div>

<script>
if ("serviceWorker" in navigator) {
  // Only register service worker on secure origins or localhost
  if (location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
    window.addEventListener("load", async () => {
      try {
        // dev override: if URL contains ?sw=0 or localStorage swDisabled, unregister existing SWs
        const urlParams = new URLSearchParams(window.location.search);
        const swDisabled = urlParams.get('sw') === '0' || localStorage.getItem('swDisabled') === '1';
        if (swDisabled && navigator.serviceWorker) {
          const regs = await navigator.serviceWorker.getRegistrations();
          for (const r of regs) await r.unregister();
          console.info('Service workers unregistered (dev override)');
          return;
        }

        const reg = await navigator.serviceWorker.register('/habits/sw.js');
        // immediately check for updates
        try { await reg.update(); } catch(e) { /* ignore */ }

        // If a new SW is waiting, tell it to skipWaiting so it activates immediately
        if (reg.waiting) {
          try { reg.waiting.postMessage({ type: 'SKIP_WAITING' }); } catch(e){}
        }

        // Listen for updates found and when installed -> trigger skipWaiting
        reg.addEventListener('updatefound', () => {
          const installing = reg.installing;
          if (!installing) return;
          installing.addEventListener('statechange', () => {
            if (installing.state === 'installed' && reg.waiting) {
              try { reg.waiting.postMessage({ type: 'SKIP_WAITING' }); } catch(e){}
            }
          });
        });

        // When the controlling worker changes (new SW activated), reload the page to get fresh assets
        navigator.serviceWorker.addEventListener('controllerchange', () => {
          try {
            if (!window.__swReloading) {
              window.__swReloading = true;
              window.location.reload();
            }
          } catch (e) {}
        });

      } catch (err) {
        console.error('SW registration failed:', err);
      }
    });
  } else {
    console.info('Service worker not registered: insecure origin', location.protocol);
  }
}
    
    function setupPushRealtime() {
      if (!currentUser) return;

      // Ensure permission
      if (Notification.permission !== "granted") {
        Notification.requestPermission().then(res => {
          if (res !== "granted") {
            console.warn("Notifications not granted");
            return;
          }
        });
      }

      supabaseClient
        .channel('push-info-channel')
        .on(
          'postgres_changes',
          {
            event: 'INSERT',
            schema: 'public',
            table: 'push_info',
            filter: `user_id=eq.${currentUser.id}`
          },
          (payload) => {
            const data = payload.new;
            if (!data) return;

            try {
              new Notification(data.title || "Neue Nachricht", {
                body: data.body || ""
              });
            } catch (e) {
              console.error("Notification error:", e);
            }
          }
        )
        .subscribe();
    }

    // Nach Login starten:
    setupPushRealtime();
    
    
    if (currentUser) {
      supabaseClient
        .channel('push-info-channel')
        .on(
          'postgres_changes',
          {
            event: 'INSERT',
            schema: 'public',
            table: 'push_info',
            filter: `user_id=eq.${currentUser.id}`
          },
          (payload) => {
            console.log("📨 PUSH via Realtime empfangen:", payload);

            const data = payload.new;
            if (!data) return;

            try {
              new Notification(data.title || "Neue Nachricht", {
                body: data.body || ""
              });
              console.log("🔔 Notification erzeugt:", data.title, data.body);

            } catch (e) {
              console.error("❌ Notification error:", e);
            }
          }
        )
        .subscribe();
    }
      
      async function checkMedalScreen() {
        if (!currentUser) return;

        const today = new Date();
        const isMonday = today.getDay() === 1; // Montag

        if (!isMonday) return;

        const { data, error } = await supabaseClient
          .from("streak_view")
          .select("current_streak, showMedal")
          .eq("user_id", currentUser.id)
          .maybeSingle();

        if (error || !data) return;

        if (parseInt(data.showMedal) === 7) return;

        const streak = data.current_streak || 0;

        const medalScreen = document.getElementById("medalScreen");
        const medalText   = document.getElementById("medalText");
        const medalOkBtn  = document.getElementById("medalOkBtn");
        const medalImage  = document.getElementById("medalImage");

        // Erfolg: showMedal = 1
        if (parseInt(data.showMedal) === 1) {
          medalImage.src = "https://raw.githubusercontent.com/lillyapp/habits/refs/heads/main/firstplace.png";
          medalText.textContent =
            `Yeah! Du hast eine Woche mehr geschafft! Dein Streak ist bei ${streak}.`;
        }
        // Misserfolg: showMedal = 0
        else {
          medalImage.src = "https://raw.githubusercontent.com/lillyapp/habits/refs/heads/main/cry.png";
          medalText.textContent =
            "Dein Streak wurde nicht erweitert.\nDu schaffst es!";
        }

        medalScreen.style.display = "flex";

        medalOkBtn.onclick = async () => {
          medalScreen.style.display = "none";

          // Nach OK immer showMedal = 7 setzen
          await supabaseClient
            .from("streak_view")
            .update({ showMedal: 7 })
            .eq("user_id", currentUser.id);
        };
      }
      
</script>

</body>
</html>
  

  <style>
    /* Expanded card: move counter to top-right */
    .card.expanded .counter {
      position: absolute;
      top: 24px;
      right: 24px;
      bottom: auto;
    }
  </style>
