<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Consistency</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <link rel="apple-touch-icon" href="https://raw.githubusercontent.com/lillyapp/habits/refs/heads/main/3FC2E555-7142-43BE-83DE-E5ED7A123793.png">

      <link rel="manifest" href="/habits/manifest.json">
      
      <meta name="apple-mobile-web-app-capable" content="yes">
      <meta name="mobile-web-app-capable" content="yes">
      
          
  <!-- Lucide -->
  <script src="https://unpkg.com/lucide@latest"></script>
  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- GSAP -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">

  <style>
    :root {
      --page-padding: 16px;
      --card-height: calc((100svh - 16px*5 - 60px - env(safe-area-inset-bottom)) / 3);
      --stats-name-size: 1.8rem;
      --stats-streak-size: 1.8rem;
      --stats-avatar-size: 38px;
    }
      
      :root {
        --c-bg: #ffffff;
        --c-text: #000000;
        --c-card: #e4e4e4;
        --c-skeleton: #cfd4db;
        --c-skeleton-soft: #dfe3e8;
        color-scheme: light dark;
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --c-bg: #000000;
          --c-text: #ffffff;
          --c-card: #1e1e1e;
          --c-skeleton: #3a3a3a;
          --c-skeleton-soft: #2f2f2f;
          color-scheme: dark;
        }
      }

    * {
      margin:0;
      padding:0;
      box-sizing:border-box;
      user-select:none;
      -webkit-user-select:none;
    }

    body {
      margin:0;
      padding:0;
      font-family: "SF Pro", "SF Pro Text", "SF Pro Display", -apple-system, "Helvetica Neue", "Segoe UI", "Poppins", sans-serif;
      background: var(--c-bg);
        color: var(--c-text);
      height:100svh;
      overflow:hidden;
    }

    /* Dark Mode Enhancements */
    .card {
      background: var(--c-card);
      color: var(--c-text);
    }

    .card-face.back {
      background: var(--c-card);
      color: var(--c-text);
    }

    .login-input {
      background: var(--c-card);
      color: var(--c-text);
    }

    #loginScreen {
      background: var(--c-bg);
      color: var(--c-text);
    }

    #statsView {
      background: var(--c-bg);
      color: var(--c-text);
    }

    .stat-bar {
      background: var(--c-card);
    }

    .stat-fill {
      color: var(--c-text);
    }

    #deletePanel {
      background: var(--c-card);
      color: var(--c-text);
    }

    .btn-plus {
      background: none !important;
      border: none !important;
      color: var(--c-text) !important;
    }

    .btn-stats {
      background: none !important;
      border: none !important;
      color: var(--c-text) !important;
    }

    #qrInfoBox {
      color: var(--c-text);
      background: var(--c-card);
    }

    /* LOGIN */
    #loginScreen {
      position:absolute;
      inset:0;
      display:none;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      padding:20px;
      z-index:20;
      background: var(--c-bg);
      color: var(--c-text);
      opacity:1;
      transition:opacity 0.4s ease;
    }

    @keyframes pulse {
      0% {transform:scale(1);}
      50%{transform:scale(1.06);}
      100%{transform:scale(1);}
    }

    #loginCircle {
      width:30px;
      height:30px;
      background: #ffffff;
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.08);
      border-radius:50%;
      animation:pulse 2.2s ease-in-out infinite;
      position: relative;
      overflow: hidden;
    }


    #loginHeadline {
      margin-top:28px;
      font-size:26px;
      font-weight:700;
      text-align:center;
      color: var(--c-text);
    }

    /* Intro progress screen */
    #introProgressScreen {
      position: fixed;
      inset: 0;
      background: var(--c-bg);
      color: var(--c-text);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 28px 20px 34px;
      text-align: center;
      z-index: 25;
      opacity: 0;
    }

    #introProgressScreen h2 {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 12px;
    }

    #introProgressLayout {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      width: 100%;
    }

    #introProgressMessage {
      display: block;
      max-width: 420px;
      text-align: justify;
      text-justify: inter-word;
      line-height: 1.4;
    }

    #introProgressChart {
      width: min(260px, 70vw);
      aspect-ratio: 1 / 1;
      position: relative;
      margin: 18px 0 16px;
    }

    #introProgressChart svg {
      width: 100%;
      height: 100%;
      display: block;
      position: relative;
      z-index: 2;
    }

    #introStreakCenter {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 3;
    }

    #introStreakValue {
      font-size: 36px;
      font-weight: 700;
      line-height: 1;
    }

    .intro-ring-track {
      fill: none;
      stroke: var(--c-card);
      stroke-width: 12;
    }

    .intro-ring {
      fill: none;
      stroke-width: 12;
      stroke-linecap: round;
      transform: rotate(-90deg);
      transform-origin: 50% 50%;
    }

    #introProgressMessage {
      margin-top: 8px;
      font-size: 16px;
      font-weight: 500;
      color: var(--c-text);
    }

    .has-sf-pro #introHeadline {
      font-size: 32px;
    }

    .has-sf-pro #introProgressMessage {
      font-weight: 600;
    }

    .intro-compare {
      margin-top: 8px;
    }

    .intro-compare-highlight {
      position: relative;
      display: inline-block;
      padding-bottom: 2px;
    }

    .intro-compare-underline {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      height: 2px;
      background: currentColor;
      transform: scaleX(0);
      transform-origin: left;
    }

    #introContinueBtn {
      margin-top: 24px;
      padding: 14px 26px;
      border-radius: 20px;
      border: none;
      background: var(--c-text);
      color: var(--c-bg);
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
    }

    #introConfetti {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
    }

    @media (min-width: 768px) {
      #introProgressLayout {
        flex-direction: row;
        align-items: center;
        justify-content: center;
        gap: 28px;
        text-align: left;
      }

      #introProgressMessage {
        max-width: 320px;
        text-align: justify;
        text-justify: inter-word;
      }

      #introProgressChart {
        margin: 0;
        width: 240px;
      }
    }

    .intro-confetti-piece {
      position: absolute;
      width: 8px;
      height: 14px;
      opacity: 0.9;
    }

    /* rolling-text styles removed */

    #loginButtonBar {
      width:100%;
      max-width:400px;
      display:flex;
      gap:14px;
      margin-top:50px;
    }

    .btn {
      flex:1;
      padding:14px;
      border-radius:20px;
      border:none;
      font-size:17px;
      cursor:pointer;
    }

    #btnLogin    {
      background: var(--c-text);
      color: var(--c-bg);
    }
    #btnRegister {
      background: var(--c-card);
      color: var(--c-text);
    }

    #loginForm {
      width:100%;
      max-width:400px;
      display:none;
      flex-direction:column;
      gap:12px;
      margin-top:30px;
    }

    .login-input {
      padding:12px;
      border:none;
      border-radius:12px;
      background: var(--c-card);
      color: var(--c-text);
    }

    #loginError {
      margin-top:12px;
      color: var(--c-text);
      font-size:14px;
      display:none;
      text-align:center;
    }

    /* MAIN PAGE (Habit-Kl√∂tze) */
    #appPage {
      position:absolute;
      inset:0;
      display:none;
      opacity:0;
    }

    .page {
      height:100%;
      display:flex;
      flex-direction:column;
      padding:16px;
      padding-bottom:140px;
      gap:16px;
    }

    .cards {
      flex:1;
      display:flex;
      flex-direction:column;
      gap:16px;
    }

    .slot {
      position:relative;
      min-height:var(--card-height);
      perspective:1200px;
    }

    .card {
      position:absolute;
      inset:0;
      border-radius:24px;
      background: var(--c-card);
      padding:24px;
      transform-style:preserve-3d;
      cursor:pointer;
      opacity:0;
      transition:transform 0.25s linear;
      height:100%;
    }

    .card-face {
      position:absolute;
      inset:0;
      backface-visibility:hidden;
      border-radius:24px;
      padding:24px;
    }

      .card-face.front {
        background:transparent;
        display:flex;
        flex-direction:column;
        justify-content:flex-start;
      }

    .back {
      background: var(--c-card);
      transform:rotateY(180deg);
      display:flex;
      flex-direction:row;
      justify-content:space-between;
      padding:24px;
    }

    .half {
      width:50%;
      display:flex;
      justify-content:center;
      align-items:center;
      font-size:2rem;
      font-weight:800;
      color:#777;
    }
    .quarter {
      width:25%;
      display:flex;
      justify-content:center;
      align-items:center;
      font-size:1.6rem;
      font-weight:800;
      color:#777;
    }

      .card-input {
        width: 100%;
        max-width: calc(100% - 90px);
        font-size: 2rem;
        font-weight: 800;
        border: none;
        background: transparent;
        outline: none;
        color: var(--c-text);
        margin-top: 6px;
        margin-bottom: 0;
        line-height: 1.1;
        white-space: normal;      /* neuer Umbruch */
        word-wrap: break-word;    /* W√∂rter umbrechen */
        min-height: 2.4rem;       /* Platz f√ºr min. 1 Zeile */
      }

      .card-input:empty::before {
        content: attr(data-placeholder);
        color: var(--c-text);
      }

    .counter-wrap {
      position: absolute;
      bottom: 24px;
      right: 24px;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 2;
    }

    .counter {
      padding: 4px 12px;
      border-radius: 999px;
      font-size: 1.2rem;
      font-weight: 700;
      display: none;

      /* Light Mode */
      background: #ffffff;
      color: #000000;
      border: 2px solid #000000;
    }

    .card-flip-btn {
      width: 28px;
      height: 28px;
      border-radius: 999px;
      border: 2px solid currentColor;
      background: transparent;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 0;
      cursor: pointer;
    }

    .card-flip-btn svg {
      width: 16px;
      height: 16px;
    }

    .card-flip-back {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 30px;
      height: 30px;
      border-radius: 999px;
      border: none;
      background: transparent;
      color: #666;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .card-flip-back svg {
      width: 18px;
      height: 18px;
    }

    @media (prefers-color-scheme: dark) {
      .counter {
        background: #ffffff !important;
        color: #000000 !important;
        border: 2px solid #000000 !important;
      }
    }

    /* Bottom Buttons (Plus/Haus + Stats) */
    .buttons-row {
      position:fixed;
      left:0;
      right:0;
      bottom:0;
      padding:0 16px calc(16px + env(safe-area-inset-bottom));
      height:calc(60px + env(safe-area-inset-bottom));
      background:transparent; /* Karten bleiben dahinter sichtbar */
      display:flex;
      gap:12px;
      z-index:9999;
      pointer-events:none;
    }

    .btn-half {
      flex:1;
      height:60px;
      border-radius:999px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:1.5rem;
      border:none !important;
      background:none !important;
      box-shadow:none !important;
      outline:none !important;
      cursor:pointer;
      pointer-events:auto;
      color: var(--c-text) !important;
    }

    .desktop-workspace {
      width:100%;
    }

    .desktop-left,
    .desktop-right {
      width:100%;
    }

    .desktop-divider {
      display:none;
    }

    .desktop-actions {
      display:none;
    }

    @media (min-width: 768px) {
      :root {
        --stats-name-size: 1.6rem;
        --stats-streak-size: 1.6rem;
        --stats-avatar-size: 32px;
      }

      #appPage {
        padding:32px 24px;
      }

      .desktop-workspace {
        width:min(940px, 100%);
        margin:0 auto;
        display:grid;
        grid-template-columns:minmax(0, 1fr) 1px minmax(0, 1fr);
        --desktop-gap: 32px;
        --desktop-divider: 1px;
        gap:var(--desktop-gap);
        align-items:stretch;
        padding:60px 20px 24px;
        box-sizing:border-box;
      }

      .desktop-left {
        display:flex;
        flex-direction:column;
        gap:16px;
        align-items:stretch;
        align-self:stretch;
      }

      .desktop-right {
        display:flex;
        flex-direction:column;
        margin-top:0;
      }

      .desktop-left {
        min-width:0;
      }

      .desktop-right {
        min-width:0;
      }

      .desktop-divider {
        display:block;
        background:#d4d4d4;
        border-radius:999px;
        height:100%;
        align-self:stretch;
      }

      .desktop-actions {
        display:flex;
        align-items:center;
        gap:10px;
        position:relative;
      }

      .desktop-icon-btn {
        width:44px;
        height:44px;
        border-radius:999px;
        border:none;
        background:transparent;
        color:var(--c-text);
        display:inline-flex;
        align-items:center;
        justify-content:center;
        cursor:pointer;
        box-shadow:none;
        padding:0;
      }

      .desktop-icon-btn svg {
        width:22px;
        height:22px;
      }


      .desktop-reminder-popover {
        position:absolute;
        left:0;
        top:-10px;
        transform:translateY(-100%);
        min-width:0;
        max-width:none;
        width:max-content;
        background:var(--c-card);
        color:var(--c-text);
        border-radius:16px;
        padding:14px 16px;
        box-shadow:none;
        display:none;
        z-index:5;
      }

      .desktop-reminder-popover.is-open {
        display:block;
      }

      .desktop-reminder-title {
        font-size:0.95rem;
        font-weight:800;
        margin-bottom:6px;
        display:flex;
        align-items:center;
        gap:8px;
      }

      .desktop-reminder-text {
        font-size:0.9rem;
        font-weight:500;
        line-height:1.35;
        white-space:nowrap;
      }


      .page {
        padding:0;
        padding-bottom:0;
        gap:12px;
        flex:1;
      }

      .cards {
        flex:1;
        height:auto;
        display:flex;
        flex-direction:column;
      }

      .slot {
        min-height:0;
        height: var(--desktop-slot-height, 180px);
        flex:0 0 var(--desktop-slot-height, 180px);
      }

      .card {
        padding:20px;
        border-radius:20px;
      }

      .card-face,
      .back {
        padding:20px;
        border-radius:20px;
      }

      .card-input {
        font-size:1.7rem;
      }

      .counter {
        font-size:1rem;
        padding:4px 10px;
      }

      .card-flip-btn {
        display:inline-flex;
      }

      .card-flip-back {
        display:inline-flex;
      }

      .stats-name {
        font-size:var(--stats-name-size);
      }

      .stats-avatar {
        width:var(--stats-avatar-size);
        height:var(--stats-avatar-size);
      }

      .stat-bar {
        height:48px;
      }

      .stat-calendar {
        --cal-day: 24px;
        --cal-gap: 6px;
      }

      .notification-title {
        font-size:1.7rem;
        margin-bottom:18px;
      }

      .notification-item {
        font-size:0.95rem;
        padding:12px 14px;
      }

      .buttons-row {
        display:none;
      }

      #statsView {
        position:relative;
        left:auto;
        right:auto;
        top:0;
        bottom:auto;
        padding:0;
        overflow:visible;
        transform:none;
        pointer-events:auto;
      }
    }

    /* Stats View */
    #statsView {
      position:fixed;
      left:0;
      right:0;
      top:100svh;
      bottom:0;
      background: var(--c-bg);
      padding:24px;
      padding-bottom:140px;
      overflow-y:auto;
      z-index:50;
    }

    .stats-name { font-size:var(--stats-name-size); font-weight:800; margin-bottom:20px; }
    .stats-streak {
      display:flex;
      align-items:flex-end;
      gap:6px;
      font-size:var(--stats-streak-size);
      font-weight:700;
      line-height:1;
    }
    .stats-streak-icon {
      width:0.9em;
      height:0.9em;
    }
    .stat-item { margin-bottom:18px; }
    .stats-panel-toggle {
      border:none;
      background:transparent;
      color:var(--c-text);
      width:32px;
      height:32px;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
    }
    .stats-user-panel.is-collapsed {
      display:none;
    }
    .stat-bar {
      width:100%;
      height:56px;
      background: transparent;
      border-radius:16px;
      overflow:hidden;
      padding:6px 0;
      box-sizing:border-box;
    }
    .stat-bar.is-clickable { cursor:pointer; }
    .stat-bar[data-owner="other"] .stat-icon-btn { cursor:default; }
    .stat-bar[data-owner="other"] .stat-icon-options { display:none; }
    .stat-bar-inner {
      display:flex;
      align-items:center;
      gap:8px;
      height:100%;
      padding:0;
    }
    .stat-icon-btn,
    .stat-icon-option {
      width:32px;
      height:32px;
      border-radius:0;
      border:none;
      background:transparent;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      color:var(--c-text);
      cursor:pointer;
      flex:0 0 auto;
    }
    .stat-icon-btn {
      margin-left:-6px;
    }
    .stat-icon-btn i,
    .stat-icon-option i {
      width:18px;
      height:18px;
    }
    .stat-icon-options {
      display:flex;
      align-items:center;
      gap:6px;
      width:0;
      opacity:0;
      overflow:hidden;
      pointer-events:none;
      transition:width 0.18s ease, opacity 0.18s ease;
    }
    .stat-bar.is-icon-open .stat-icon-options {
      width:76px;
      opacity:1;
      pointer-events:auto;
    }
    .stat-trend {
      margin-bottom:18px;
    }
    .stat-trend-chart {
      width:100%;
      height:140px;
      background:var(--c-card);
      border-radius:16px;
      padding:12px;
      box-sizing:border-box;
    }
    .stat-trend svg {
      width:100%;
      height:100%;
      display:block;
    }
    .stat-trend path {
      fill:none;
      stroke-width:3;
      stroke-linecap:round;
      stroke-linejoin:round;
    }
    .reliability-chart {
      margin-bottom:10px;
    }
    .reliability-summary {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
      font-size:0.78rem;
      font-weight:700;
      color:var(--c-text);
    }
    .reliability-summary-left,
    .reliability-summary-right {
      opacity:0.9;
      white-space:nowrap;
    }
    .reliability-summary-center {
      opacity:0.75;
      font-size:0.72rem;
      font-weight:600;
      text-align:center;
      flex:1;
    }
    .reliability-chart-svg {
      width:100%;
      height:auto;
      display:block;
      background:var(--c-card);
      border-radius:14px;
      padding:4px;
    }
    .reliability-axis-label {
      fill:var(--c-text);
      fill-opacity:0.55;
      font-size:11px;
      font-weight:600;
    }
    .reliability-grid {
      stroke:var(--c-text);
      stroke-opacity:0.12;
      stroke-width:1;
    }
    .reliability-line {
      fill:none;
      stroke-width:3;
      stroke-linecap:round;
      stroke-linejoin:round;
    }
    .reliability-line-secondary {
      opacity:0.45;
      stroke-width:2;
    }
    .reliability-line-primary {
      opacity:0.98;
      stroke-width:4;
    }
    .reliability-legend {
      display:grid;
      grid-template-columns:repeat(2, minmax(0, 1fr));
      gap:8px 12px;
      margin-top:10px;
    }
    .reliability-legend-item {
      display:flex;
      align-items:center;
      gap:7px;
      min-width:0;
      font-size:0.75rem;
      font-weight:600;
      color:var(--c-text);
      opacity:0.9;
    }
    .reliability-legend-dot {
      width:8px;
      height:8px;
      border-radius:999px;
      flex:0 0 auto;
    }
    .reliability-legend-label {
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .reliability-help {
      margin-top:10px;
      padding:10px 12px;
      border-radius:12px;
      background:var(--c-card);
      color:var(--c-text);
      font-size:0.72rem;
      line-height:1.35;
      opacity:0.88;
    }
    .reliability-help-row + .reliability-help-row {
      margin-top:5px;
    }
    .stat-bar-track {
      position:relative;
      flex:1;
      height:100%;
      border-radius:12px;
      overflow:hidden;
      background: var(--c-card);
    }
    .stat-bar-label {
      position:relative;
      z-index:2;
      height:100%;
      display:flex;
      align-items:center;
      padding-left:12px;
      font-weight:700;
      color:var(--c-text);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .stat-fill {
      height:100%;
      width:0;
      padding-left:12px;
      display:flex;
      align-items:center;
      font-weight:700;
      border-radius:16px;
      background: var(--c-card);
      color: var(--c-text);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    @keyframes loadingBrightnessPulse {
      0% {
        filter: brightness(0.9);
        opacity: 0.62;
      }
      50% {
        filter: brightness(1.12);
        opacity: 0.92;
      }
      100% {
        filter: brightness(0.9);
        opacity: 0.62;
      }
    }

    .card.is-loading-skeleton {
      opacity: 1 !important;
      pointer-events: none;
      background: var(--c-skeleton-soft);
      animation: loadingBrightnessPulse 1.35s ease-in-out infinite;
    }

    .card.is-loading-skeleton .card-face {
      background: transparent;
      padding: 24px;
    }

    .card-skeleton-title {
      width: 62%;
      height: 30px;
      border-radius: 10px;
      background: var(--c-skeleton);
      margin-top: 6px;
    }

    .card-skeleton-chip {
      width: 70px;
      height: 28px;
      border-radius: 999px;
      background: var(--c-skeleton);
    }

    .stat-bar-track.is-loading-skeleton {
      background: var(--c-skeleton-soft);
    }

    .stat-progress.is-loading-skeleton {
      width: 100% !important;
      background: var(--c-skeleton) !important;
      animation: loadingBrightnessPulse 1.35s ease-in-out infinite;
    }

    .stat-icon-skeleton {
      width: 20px;
      height: 20px;
      border-radius: 999px;
      background: var(--c-skeleton);
      opacity: 0.85;
      margin-left: 2px;
      flex: 0 0 auto;
    }

    .stat-bar-label.stat-bar-label-skeleton {
      color: transparent;
      width: 58%;
      height: 18px;
      border-radius: 8px;
      background: var(--c-skeleton);
      margin: 0 0 0 12px;
      align-self: center;
    }

    .stat-calendar {
      --cal-day: 28px;
      --cal-gap: 8px;
      max-height:0;
      overflow:hidden;
      opacity:0;
      transform:translateY(-6px);
      transition:max-height 0.28s ease, opacity 0.28s ease, transform 0.28s ease;
      margin-top:8px;
      padding:0;
      display:flex;
      flex-direction:column;
      align-items:stretch;
      width:100%;
    }

    .stat-calendar.is-open {
      max-height:220px;
      opacity:1;
      transform:translateY(0);
    }

    .stat-calendar-header {
      font-size:0.95rem;
      font-weight:700;
    }

    .stat-calendar-header-row {
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin-bottom:8px;
      gap:10px;
      width:100%;
    }

    .stat-cal-nav {
      width:28px;
      height:28px;
      border-radius:999px;
      border:none;
      background:var(--c-card);
      color:var(--c-text);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
    }

    .stat-calendar-grid {
      display:grid;
      grid-template-columns:repeat(7, minmax(0, 1fr));
      justify-items:center;
      gap:var(--cal-gap);
      width:100%;
    }

    .stat-day {
      width:var(--cal-day);
      height:var(--cal-day);
      border-radius:999px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:0.75rem;
      font-weight:700;
      color:var(--c-bg);
      letter-spacing:0.2px;
    }

    .stat-day.inactive {
      background:var(--c-card);
      color:var(--c-text);
    }


    .stats-name-row {
      display:flex;
      align-items:flex-end;
      gap:10px;
    }

    .stats-avatar {
      width:var(--stats-avatar-size);
      height:var(--stats-avatar-size);
      border-radius:999px;
      object-fit:cover;
      flex-shrink:0;
      background:#d1d5db;
    }

    /* D√ºnner Delete-Balken √ºber der obersten Karte */
    #deletePanel {
      position:fixed;
      left:16px;
      right:16px;
      top:12px; /* wird per JS genauer √ºber der obersten Karte platziert */
      background: var(--c-card);
      border-radius:999px;
      box-shadow:0 8px 20px rgba(0,0,0,0.12);
      padding:6px 12px;
      display:none;
      align-items:center;
      justify-content:center;
      gap:8px;
      z-index:10000;
      font-size:12px;
    }

    #deletePanelText {
      font-weight:500;
      white-space:nowrap;
    }

    #deleteAllBtn {
      padding:4px 10px;
      border-radius:999px;
      border:1px solid #d4d4d4;
      background:#f3f3f3;
      color:#ef4444;
      font-weight:600;
      font-size:12px;
      cursor:pointer;
      flex-shrink:0;
    }
      
      .front-header {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .expand-area {
        margin-top: 12px;
      }

      .expand-divider {
        width: 100%;
        height: 2px;
        margin: 12px 0;
        opacity: 0.35;
      }

      .subtask {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
      }

      .subtask i {
        width: 22px;
        height: 22px;
        cursor: pointer;
        flex-shrink: 0;
      }

      .subtask i {
        color: inherit;
      }

      .subtask-title {
        font-size: 1.05rem;
        font-weight: 600;
        background: transparent;
        border: none;
        outline: none;
        flex: 1;
        user-select: text;
        -webkit-user-select: text;
        cursor: text;
      }

      /* Make the placeholder inherit a CSS variable set on the input by JS */
      .subtask-title::placeholder {
        color: var(--ph, #666);
        opacity: 0.85;
      }

      .add-subtask {
        margin-top: 8px;
        opacity: 0.6;
        cursor: pointer;
      }

      /* --- Clickable subtask icons fix --- */
      /* --- Clickable subtask icons fix --- */
      /* Ensure the icon element and all nested SVG parts accept pointer events,
         including on touch devices. Use !important to override any inline
         attributes lucide might add. */
      .subtask i,
      .subtask i svg,
      .subtask i * {
        pointer-events: auto !important;
        touch-action: manipulation;
        -webkit-user-select: none;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        cursor: pointer;
      }
      
      #notificationsView {
        position: fixed;
        left: 0;
        right: 0;
        top: 100svh;
        bottom: 0;
        background: var(--c-bg);
        color: var(--c-text);
        padding: 24px;
        padding-bottom: 140px;
        overflow-y: auto;
        z-index: 55;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .reminder-pane {
        width: min(440px, 92vw);
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        align-items: stretch;
        gap: 20px;
        position: relative;
      }

      .reminder-header {
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 80px;
        padding-top: 8px;
      }

      .reminder-close {
        position: fixed;
        right: calc(16px + env(safe-area-inset-right));
        top: calc(16px + env(safe-area-inset-top));
        z-index: 1000;
        width: 36px;
        height: 36px;
        border-radius: 999px;
        border: none;
        background: transparent;
        color: var(--c-text);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        opacity: 0;
        pointer-events: none;
      }

      .reminder-close svg {
        width: 20px;
        height: 20px;
      }

      .reminder-status {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        opacity: 0;
        transform: translateY(-6px);
        transition: opacity 0.2s ease, transform 0.2s ease;
      }

      .reminder-status.is-complete {
        opacity: 1;
        transform: translateY(0);
      }

      .reminder-status svg {
        width: 32px;
        height: 32px;
        color: #1f9e57;
      }

      .reminder-status-title {
        font-size: 1.2rem;
        font-weight: 700;
        text-align: center;
      }

      .reminder-list {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
        text-align: left;
      }

      .reminder-item {
        width: 100%;
        display: inline-flex;
        align-items: center;
        gap: 12px;
        padding: 8px 0;
        border: none;
        background: transparent;
        color: var(--c-text);
        font-size: 1.05rem;
        font-weight: 600;
        cursor: pointer;
        opacity: 0.5;
      }

      .reminder-item.is-selected {
        color: var(--c-text);
        opacity: 1;
      }

      .reminder-item.is-partial {
        color: var(--c-text);
        opacity: 0.8;
      }

      .reminder-emoji {
        font-size: 1.35rem;
        line-height: 1;
      }

      .reminder-count {
        margin-left: auto;
        font-size: 0.95rem;
        font-weight: 700;
        letter-spacing: 0.02em;
        opacity: 0.8;
      }

      .notification-title {
        font-size: 2rem;
        font-weight: 700;
        margin-bottom: 24px;
      }

      .notification-item {
        background: var(--c-card);
        border-radius: 16px;
        padding: 14px 16px;
        margin-bottom: 12px;
        font-weight: 600;
      }
      
      .avatar-picker-overlay {
        position:fixed;
        inset:0;
        background:var(--c-bg);
        display:none;
        align-items:center;
        justify-content:center;
        z-index:999996;
      }

      .avatar-picker-card {
        width:min(520px, 90vw);
        color:var(--c-text);
        text-align:center;
      }

      .avatar-picker-title {
        font-size:1.1rem;
        font-weight:700;
        margin-bottom:16px;
      }

      .avatar-picker-grid {
        display:flex;
        justify-content:center;
        gap:14px;
        flex-wrap:wrap;
      }

      .avatar-picker-btn {
        width:64px;
        height:64px;
        border-radius:999px;
        border:2px solid transparent;
        padding:0;
        background:transparent;
        cursor:pointer;
        overflow:hidden;
      }

      .avatar-picker-btn img {
        width:100%;
        height:100%;
        object-fit:cover;
        display:block;
      }
    /* ================================
       Hide streak indicators (visual only)
       ================================ */
    .streak,
    .streak-value,
    .streak-counter,
    [data-streak],
    #streakView,
    #streakCounter,
    .streak-badge {
      display: none !important;
    }
  </style>
  <!-- Counter positioning fix for expanded/front mode -->
  <!-- (removed previous override, see below for new state-based CSS) -->
  <!-- Dynamic theme-color for Safari, PWA, Chrome -->
  <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
  <meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">

  <!-- Safari PWA status bar -->
  <meta name="apple-mobile-web-app-status-bar-style" content="default" media="(prefers-color-scheme: light)">
  <meta name="apple-mobile-web-app-status-bar-style" content="black" media="(prefers-color-scheme: dark)">
</head>
<body>

<!-- LOGIN -->
<div id="loginScreen">
    <div id="loginCircle">
      <div id="loginOrbLayer" aria-hidden="true">
        <div class="login-orb orb-1"></div>
        <div class="login-orb orb-2"></div>
        <div class="login-orb orb-3"></div>
        <div class="login-orb orb-4"></div>
        <div class="login-orb orb-5"></div>
        <div class="login-orb orb-6"></div>
        <div class="login-orb orb-7"></div>
        <div class="login-orb orb-8"></div>
        <div class="login-orb orb-9"></div>
      </div>
    </div>
  <div id="loginHeadline">Wir versuchen dich anzumelden</div>

  <div id="loginButtonBar" style="display:none;">
    <button class="btn" id="btnLogin">Login</button>
    <button class="btn" id="btnRegister">Registrieren</button>
  </div>

  <div id="loginForm">
    <input id="loginName" class="login-input" placeholder="Name" type="text" style="display:none;" />
    <input id="loginEmail" class="login-input" placeholder="E-Mail" type="email" />
    <input id="loginPassword" class="login-input" placeholder="Passwort" type="password" />
    <div id="forgotPw" style="
      display:none;
      text-align:center;
      margin-top:-6px;
      font-size:14px;
      color:#555;
      text-decoration:underline;
      cursor:pointer;
    ">
      Passwort vergessen?
    </div>
    <button class="btn" id="loginOkBtn">OK</button>
  </div>

  <div id="loginError"></div>
</div>

<!-- INTRO PROGRESS SCREEN -->
<div id="introProgressScreen" aria-hidden="true">
  <div id="introConfetti"></div>
  <h2 id="introHeadline">Dein Fortschritt</h2>
  <div id="introProgressLayout">
    <div id="introProgressChart" aria-hidden="true">
      <svg viewBox="0 0 200 200" role="img" aria-label="Fortschrittsringe">
        <circle class="intro-ring-track ring-1" cx="100" cy="100" r="70"></circle>
        <circle class="intro-ring-track ring-2" cx="100" cy="100" r="52"></circle>
        <circle class="intro-ring-track ring-3" cx="100" cy="100" r="34"></circle>

        <circle class="intro-ring ring-1" cx="100" cy="100" r="70"></circle>
        <circle class="intro-ring ring-2" cx="100" cy="100" r="52"></circle>
        <circle class="intro-ring ring-3" cx="100" cy="100" r="34"></circle>
      </svg>
      <div id="introStreakCenter">
        <div id="introStreakValue">0</div>
      </div>
    </div>
    <div id="introProgressMessage">Du hast es bald geschafft! Bleib dran.</div>
  </div>
  <button id="introContinueBtn">Weiter</button>
</div>

<!-- MAIN HABIT PAGE (3 Kl√∂tze) -->
<div id="appPage">
    <!-- WEEKLY MEDAL SCREEN -->
    <div id="medalScreen" style="
      position:fixed;
      inset:0;
      background:var(--c-bg);
      color:var(--c-text);
      display:none;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      z-index:999995;
      padding:20px;
      text-align:center;
    ">
      <img id="medalImage" src="https://raw.githubusercontent.com/lillyapp/habits/refs/heads/main/firstplace.png" style="
        width:140px;
        height:140px;
        margin-bottom:28px;
      " />

      <div id="medalText" style="
        font-size:22px;
        font-weight:700;
        margin-bottom:34px;
        line-height:1.3;
      "></div>

      <button id="medalOkBtn" style="
        padding:14px 28px;
        border-radius:20px;
        border:none;
        background: var(--c-text);
        color: var(--c-bg);
        font-size:17px;
        font-weight:600;
      ">OK</button>
    </div>
    <div class="desktop-workspace">
      <div class="desktop-left">
      <div class="desktop-actions">
        <button id="remindersDesktopBtn" class="desktop-icon-btn" aria-label="Reminders">
          <i data-lucide="cookie"></i>
        </button>
        <div id="desktopReminderPopover" class="desktop-reminder-popover" aria-hidden="true">
          <div class="desktop-reminder-title">
            <i data-lucide="sparkles"></i>
            <span id="desktopReminderTitle">Reminders</span>
          </div>
          <div class="desktop-reminder-text" id="desktopReminderBody">
            Keine neuen Reminders.
          </div>
        </div>
        <button id="logoutDesktopBtn" class="desktop-icon-btn" aria-label="Abmelden">
          <i data-lucide="door-closed-locked"></i>
        </button>
      </div>
      <div class="page">
        <div class="cards">
          <div class="slot" id="slot1"></div>
          <div class="slot" id="slot2"></div>
          <div class="slot" id="slot3"></div>
        </div>
      </div>
    </div>
    <div class="desktop-divider"></div>
    <div class="desktop-right">
      <div id="statsView"></div>
    </div>
  </div>

  <div class="buttons-row">
    <button class="btn-half btn-plus" id="addBtn" data-mode="main">
      <i data-lucide="plus"></i>
    </button>

    <button class="btn-half btn-bell" id="bellBtn">
      <i data-lucide="cookie"></i>
    </button>

    <button class="btn-half btn-stats" id="statsBtn">
      <i data-lucide="chart-bar-stacked"></i>
    </button>
  </div>

  <div id="notificationsView"></div>
  <!-- D√ºnner Shake-Delete-Balken -->
  <div id="deletePanel">
    <span id="deletePanelText">Klicke hier, um alle Habits zu l√∂schen.</span>
    <button id="deleteAllBtn">L√∂schen</button>
  </div>
</div>

  <div id="avatarPickerOverlay" class="avatar-picker-overlay" aria-hidden="true">
  <div class="avatar-picker-card">
    <div class="avatar-picker-title">Bitte w√§hle deinen Avatar</div>
    <div class="avatar-picker-grid">
      <button class="avatar-picker-btn" data-avatar="https://raw.githubusercontent.com/lillyapp/lillyapp/main/avatar01.png">
        <img src="https://raw.githubusercontent.com/lillyapp/lillyapp/main/avatar01.png" alt="Avatar 01">
      </button>
      <button class="avatar-picker-btn" data-avatar="https://raw.githubusercontent.com/lillyapp/lillyapp/main/avatar02.png">
        <img src="https://raw.githubusercontent.com/lillyapp/lillyapp/main/avatar02.png" alt="Avatar 02">
      </button>
      <button class="avatar-picker-btn" data-avatar="https://raw.githubusercontent.com/lillyapp/lillyapp/main/avatar03.png">
        <img src="https://raw.githubusercontent.com/lillyapp/lillyapp/main/avatar03.png" alt="Avatar 03">
      </button>
      <button class="avatar-picker-btn" data-avatar="https://raw.githubusercontent.com/lillyapp/lillyapp/main/avatar04.png">
        <img src="https://raw.githubusercontent.com/lillyapp/lillyapp/main/avatar04.png" alt="Avatar 04">
      </button>
    </div>
  </div>
</div>

<script>
    lucide.createIcons();

    const supabaseClient = supabase.createClient(
      "https://gglgenarpskajkaanknk.supabase.co",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdnbGdlbmFycHNrYWprYWFua25rIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMwODA2NzAsImV4cCI6MjA3ODY1NjY3MH0.phVPaPpkiXJ0ncbRiBChpVBtY8gv0sm_MjlCJJnaSt4"
    );

    const loginScreen   = document.getElementById("loginScreen");
    const loginForm     = document.getElementById("loginForm");
    const loginError    = document.getElementById("loginError");
    const appPage       = document.getElementById("appPage");
    const introProgressScreen = document.getElementById("introProgressScreen");
    const introHeadline = document.getElementById("introHeadline");
    const introProgressMessage = document.getElementById("introProgressMessage");
    const introContinueBtn = document.getElementById("introContinueBtn");
    const introConfetti = document.getElementById("introConfetti");
    const introRings = Array.from(document.querySelectorAll(".intro-ring"));
    const introStreakValue = document.getElementById("introStreakValue");
    const btnLogin      = document.getElementById("btnLogin");
    const btnRegister   = document.getElementById("btnRegister");
    const loginOkBtn    = document.getElementById("loginOkBtn");
    const loginName     = document.getElementById("loginName");
    const loginEmail    = document.getElementById("loginEmail");
    const loginPassword = document.getElementById("loginPassword");
    const forgotPw = document.getElementById("forgotPw");
    const addBtnEl      = document.getElementById("addBtn");
    const statsBtnEl    = document.getElementById("statsBtn");
    const statsViewEl   = document.getElementById("statsView");
    const deletePanel   = document.getElementById("deletePanel");
    const deleteAllBtn  = document.getElementById("deleteAllBtn");
    const bellBtnEl = document.getElementById("bellBtn");
    const notificationsViewEl = document.getElementById("notificationsView");
    const remindersDesktopBtn = document.getElementById("remindersDesktopBtn");
    const desktopReminderPopover = document.getElementById("desktopReminderPopover");
    const desktopReminderTitle = document.getElementById("desktopReminderTitle");
    const desktopReminderBody = document.getElementById("desktopReminderBody");
    const logoutDesktopBtn = document.getElementById("logoutDesktopBtn");
    const avatarPickerOverlay = document.getElementById("avatarPickerOverlay");
    const avatarPickerButtons = document.querySelectorAll(".avatar-picker-btn");

    const loginHeadlineMessages = [
      "Wie motiviert bist du heute?",
      "Gro√üartiges steht dir bevor ...",
      "Heute wird ein guter Tag.",
      "Kleine Schritte, gro√üe Wirkung.",
      "Bereit f√ºr deinen n√§chsten Schritt?",
      "Zeit f√ºr ein bisschen Fortschritt.",
      "Du bist n√§her dran, als du denkst."
    ];
   
    const reminderChecklistItems = [
      { id: "salmon", emoji: "üç£", label: "Lachsfilet" },
      { id: "bread-1", emoji: "üçû", label: "2x Brot mit Belag (Fr√ºhst√ºck)" },
      { id: "soup", emoji: "üç≤", label: "Mittagessen" },
      { id: "bread-2", emoji: "üçû", label: "2x Brot mit Belag (Abendessen)" },
      { id: "quark", emoji: "ü•õ", label: "Speisequark", target: 2, dbIds: ["quark", "quark-2"] },
      { id: "creatine", emoji: "üçö", label: "5g Kreatin" }
    ];
    const reminderChecklistState = new Set();
    const HABIT_ICON_TYPES = ["brain", "dumbbell", "shapes"];

    const isDesktopView = () => window.matchMedia("(min-width: 768px)").matches;

  document.addEventListener("DOMContentLoaded", () => {
    if (loginHeadlineMessages.length && loginHeadline) {
      const idx = Math.floor(Math.random() * loginHeadlineMessages.length);
      loginHeadline.textContent = loginHeadlineMessages[idx];
    }

    function detectFont(fontName) {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      if (!ctx) return false;
      const text = "abcdefghijklmnopqrstuvwxyz0123456789";
      ctx.font = "16px monospace";
      const baseline = ctx.measureText(text).width;
      ctx.font = `16px "${fontName}", monospace`;
      const width = ctx.measureText(text).width;
      return width !== baseline;
    }

    if (
      detectFont("SF Pro") ||
      detectFont("SF Pro Text") ||
      detectFont("SF Pro Display")
    ) {
      document.body.classList.add("has-sf-pro");
    }

    refreshBellIcon();
    checkForAppUpdate();
    window.addEventListener("resize", () => {
      if (currentUser) ensureDesktopStats();
      updateDesktopLayoutHeights();
      alignDesktopStatsTop();
      alignDesktopDividerHeight();
    });

    document.addEventListener("click", (e) => {
      if (!isDesktopView() || !desktopReminderPopover) return;
      if (desktopReminderPopover.classList.contains("is-open")) {
        const inside = desktopReminderPopover.contains(e.target);
        const isBell = remindersDesktopBtn && remindersDesktopBtn.contains(e.target);
        if (!inside && !isBell) {
          desktopReminderPopover.classList.remove("is-open");
          desktopReminderPopover.setAttribute("aria-hidden", "true");
        }
      }
    });
  });

    const slotOrder = ["slot3","slot2","slot1"];

    let habits      = [];
    let currentUser = null;
    let authMode    = "login";
    let statsOpen   = false;
    let otherUser   = null;
    let introFlowDone = false;
    const dataCache = {
      habits: new Map(),
      streak: new Map(),
      otherUser: { value: null, ts: 0 }
    };
    const CACHE_TTL = {
      habits: 5000,
      streak: 10000,
      otherUser: 30000
    };

    // unread badge comes from DB
    let unreadNotificationCount = 0;

    // ================================
    // Notification bell polling
    // ================================
    let notificationPollTimer = null;

    function startNotificationPolling(intervalMs = 8000) {
      stopNotificationPolling();
      notificationPollTimer = setInterval(async () => {
        if (!currentUser) return;
        await loadUnreadNotificationCount();
        refreshBellIcon();
      }, intervalMs);
    }

    function stopNotificationPolling() {
      if (notificationPollTimer) {
        clearInterval(notificationPollTimer);
        notificationPollTimer = null;
      }
    }

    const avatarOptions = [
      "https://raw.githubusercontent.com/lillyapp/lillyapp/main/avatar04.png",
      "https://raw.githubusercontent.com/lillyapp/lillyapp/main/avatar01.png",
      "https://raw.githubusercontent.com/lillyapp/lillyapp/main/avatar02.png",
      "https://raw.githubusercontent.com/lillyapp/lillyapp/main/avatar03.png"
    ];

    function isSpeisequarkTitle(title) {
      return typeof title === "string" && title.toLowerCase().includes("speisequark");
    }

    function normalizeHabitIcon(iconType) {
      return HABIT_ICON_TYPES.includes(iconType) ? iconType : "brain";
    }

    function enforceSpeisequarkGoal(card, title) {
      if (!card || card.dataset.qr === "true") return false;
      if (!isSpeisequarkTitle(title)) return false;

      let changed = false;
      let progress = parseInt(card.dataset.progress) || 0;
      const goal = parseInt(card.dataset.goal) || 0;

      if (goal !== 2) {
        card.dataset.goal = 2;
        changed = true;
      }

      if (progress > 2) {
        progress = 2;
        card.dataset.progress = 2;
        changed = true;
      }

      const numArea = card.querySelector("#numArea");
      if (numArea) numArea.textContent = "2";

      const counter = card.querySelector(".counter");
      if (counter) {
        counter.style.display = "block";
        counter.textContent = progress + "/2";
      }

      return changed;
    }

    function getAvatarUrl(userData) {
      return userData?.avatar_url || avatarOptions[0];
    }

    function showAvatarPicker() {
      if (!avatarPickerOverlay) return;
      avatarPickerOverlay.style.display = "flex";
      avatarPickerOverlay.setAttribute("aria-hidden", "false");
    }

    function hideAvatarPicker() {
      if (!avatarPickerOverlay) return;
      avatarPickerOverlay.style.display = "none";
      avatarPickerOverlay.setAttribute("aria-hidden", "true");
    }

    async function ensureAvatarSelected() {
      const avatarUrl = currentUser?.user_metadata?.avatar_url;
      if (!avatarUrl) showAvatarPicker();
    }

    // Push/Notification capability
    const supportsPush = (
      "serviceWorker" in navigator &&
      "PushManager" in window &&
      "Notification" in window
    );
    const PUSH_API_BASE = "https://habits-push-worker.9dgw4nf86r.workers.dev";
    let pushVapidPublicKeyCache = null;

    const APP_VERSION = 1;

    let deleteTimeout = null;
    let deletePanelVisible = false;
    const PERM_KEYS = {
      notifications: "perm_notifications_asked_v1",
      motion: "perm_motion_asked_v1"
    };

    const cycleColors = [
      "#ef4444","#f97316","#f59e0b","#eab308","#84cc16","#22c55e",
      "#10b981","#14b8a6","#06b6d4","#0ea5e9","#3b82f6","#6366f1",
      "#8b5cf6","#a855f7","#d946ef","#ec4899","#f43f5e","#dc2626",
      "#ea580c","#ca8a04","#4d7c0f","#15803d","#047857","#0f766e",
      "#0369a1","#1d4ed8","#4338ca","#6d28d9","#7e22ce","#be185d"
    ];

    // ================================
    // Motivational notification texts
    // ================================

    // When the user is behind (passive-aggressive but caring)
    const MOTIVATION_TEXTS_TRAILING = [
      "Heute war noch Luft nach oben. Morgen z√§hlt wieder.",
      "Du wei√üt selbst: Du kannst das besser. Und du wirst es zeigen.",
      "Nicht schlimm. Aber wir beide wissen, dass da mehr drin ist.",
      "Ein kleiner H√§nger ist kein R√ºckschritt. Aufstehen lohnt sich.",
      "Du bist nicht raus ‚Äì du bist nur kurz langsamer.",
      "Das Ziel ist noch da. Es wartet geduldig auf dich.",
      "Kein Drama. Aber auch kein Grund stehenzubleiben.",
      "Andere ziehen vorbei ‚Äì noch. Das ist kein Urteil.",
      "Du hast schon bewiesen, dass du es kannst.",
      "Morgen ist ein verdammt guter Zeitpunkt, um zur√ºckzukommen."
    ];

    // When the user is leading (positive reinforcement)
    const MOTIVATION_TEXTS_LEADING = [
      "Stark. Genau so entsteht Konstanz.",
      "Du f√ºhrst ‚Äì und zwar verdient.",
      "Das sieht nach echter Routine aus.",
      "Sehr gut. Das ist kein Zufall mehr.",
      "Du setzt gerade den Ma√üstab.",
      "Sauber durchgezogen. Respekt.",
      "So f√ºhlt sich Dranbleiben an.",
      "Du machst es vor. Weiter so.",
      "Konsequent. Und genau deshalb vorne.",
      "Das ist Momentum. Nutz es."
    ];

    // Helper to get a random text from a pool
    function pickRandomMotivationText(pool) {
      if (!Array.isArray(pool) || pool.length === 0) return "";
      return pool[Math.floor(Math.random() * pool.length)];
    }

    async function requestNotificationPermissionOnce() {
      if (!supportsPush) return;
      if (localStorage.getItem(PERM_KEYS.notifications) === "1") {
        await ensurePushInfoRow();
        if (Notification.permission === "granted") {
          await registerPushSubscription();
        }
        return;
      }

      const res = await Notification.requestPermission();
      localStorage.setItem(PERM_KEYS.notifications, "1");
      await ensurePushInfoRow();

      if (res === "granted") {
        await registerPushSubscription();
      }
    }

    async function requestMotionPermissionOnce() {
      if (localStorage.getItem(PERM_KEYS.motion) === "1") return;

      if (typeof DeviceMotionEvent !== "undefined" &&
          typeof DeviceMotionEvent.requestPermission === "function") {
        await DeviceMotionEvent.requestPermission().catch(() => {});
      }

      localStorage.setItem(PERM_KEYS.motion, "1");
    }

    async function requestIntroPermissionsOnce() {
      await requestNotificationPermissionOnce();
      await requestMotionPermissionOnce();
    }

    function closeNotificationsPane() {
      if (addBtnEl.dataset.mode !== "notifications") return;
      addBtnEl.dataset.mode = "main";
      const closeBtn = document.getElementById("reminderCloseBtn");
      if (closeBtn) {
        closeBtn.style.opacity = "0";
        closeBtn.style.pointerEvents = "none";
      }
      gsap.to("#notificationsView", {
        top: "100svh",
        duration: 0.42,
        ease: "power1.in",
        delay: 0.4,
        onStart: () => setLoginOrbsPaused(true),
        onComplete: () => setLoginOrbsPaused(false)
      });
      refreshAddButtonIcon();
    }
    
    addBtnEl.addEventListener("click", async () => {

      // --- Close Notifications ---
      if (addBtnEl.dataset.mode === "notifications") {
        closeNotificationsPane();
        return;
      }

      // --- Close Stats ---
      if (addBtnEl.dataset.mode === "stats") {
        addBtnEl.dataset.mode = "main";
        statsOpen = false;
        const closeBtn = document.getElementById("reminderCloseBtn");
        if (closeBtn) {
          closeBtn.style.opacity = "0";
          closeBtn.style.pointerEvents = "none";
        }
        gsap.to("#statsView", {
          top: "100svh",
          duration: 0.42,
          ease: "power1.in",
          delay: 0.4,
          onStart: () => setLoginOrbsPaused(true),
          onComplete: () => setLoginOrbsPaused(false)
        });
        refreshAddButtonIcon();
        return;
      }

      // --- Normal Add Habit ---
      if (habits.length >= 3) return;

      if (!currentUser) {
        const { data } = await supabaseClient.auth.getUser();
        currentUser = data.user;
        if (!currentUser) return;
      }

      const { data, error } = await supabaseClient
        .from("habits")
        .insert({
          user_id: currentUser.id,
          title: "",
          color: "#e4e4e4",
          progress: 0,
          goal: 1,
          appear_once: false,
          icon_type: "brain"
        })
        .select()
        .single();

      if (error) {
        console.error("insert habit error:", error);
        return;
      }

      habits.push(data);
      createCardFromHabit(data, habits.length - 1, 0);
      refreshAddButtonIcon();
    });
    
    bellBtnEl.addEventListener("click", async () => {

      // keep DB in sync even if already decided
      if (supportsPush) {
        await ensurePushInfoRow();
        if (Notification.permission === "granted") {
          await registerPushSubscription();
        }
      }

      // Update badge before opening
      await loadUnreadNotificationCount();
      refreshBellIcon();

      await renderNotifications();
      lucide.createIcons({ scope: notificationsViewEl });

      statsOpen = false;
      addBtnEl.dataset.mode = "notifications";

      if (isDesktopView()) {
        gsap.to("#notificationsView", {
          top: "0svh",
          duration: 0.42,
          ease: "power1.out",
          delay: 0.4,
          onStart: () => setLoginOrbsPaused(true),
          onComplete: () => setLoginOrbsPaused(false)
        });
        gsap.to("#statsView", {
          top: "100svh",
          duration: 0.42,
          ease: "power1.in",
          delay: 0.4
        });
      } else {
        gsap.to("#notificationsView", {
          top: "0svh",
          duration: 0.42,
          ease: "power1.out",
          delay: 0.4,
          onStart: () => setLoginOrbsPaused(true),
          onComplete: () => setLoginOrbsPaused(false)
        });
        gsap.to("#statsView", {
          top: "100svh",
          duration: 0.42,
          ease: "power1.in",
          delay: 0.4
        });
      }

      const closeBtn = document.getElementById("reminderCloseBtn");
      if (closeBtn) {
        closeBtn.style.opacity = "1";
        closeBtn.style.pointerEvents = "auto";
      }

      refreshAddButtonIcon();

      // Mark as read after opening
      await markAllNotificationsRead();
      await loadUnreadNotificationCount();
      refreshBellIcon();
    });

    if (remindersDesktopBtn) {
      remindersDesktopBtn.addEventListener("click", async (e) => {
        e.stopPropagation();
        bellBtnEl.click();
      });
    }

    if (desktopReminderPopover) {
      desktopReminderPopover.addEventListener("click", (e) => {
        e.stopPropagation();
        toggleDesktopReminderPopover();
      });
    }

    if (logoutDesktopBtn) {
      logoutDesktopBtn.addEventListener("click", async () => {
        stopNotificationPolling();
        try {
          await supabaseClient.auth.signOut();
        } catch (e) {
          console.error("logout error:", e);
        }
        window.location.reload();
      });
    }

    if (avatarPickerButtons && avatarPickerButtons.length) {
      avatarPickerButtons.forEach(btn => {
        btn.addEventListener("click", async () => {
          if (!currentUser) return;
          const avatarUrl = btn.dataset.avatar;
          if (!avatarUrl) return;

          const { error } = await supabaseClient.auth.updateUser({
            data: { avatar_url: avatarUrl }
          });

          if (error) {
            console.error("avatar update error:", error);
            return;
          }

          currentUser.user_metadata = {
            ...(currentUser.user_metadata || {}),
            avatar_url: avatarUrl
          };

          hideAvatarPicker();
          await refreshStatsLive();
        });
      });
    }

    if (introContinueBtn) {
      introContinueBtn.addEventListener("click", async () => {
        await proceedAfterIntro();
      });
    }


    function darken(hex, f=0.55) {
      let r = parseInt(hex.slice(1,3),16)*f|0;
      let g = parseInt(hex.slice(3,5),16)*f|0;
      let b = parseInt(hex.slice(5,7),16)*f|0;
      return `rgb(${r},${g},${b})`;
    }

    function updateLoginOrbsFromHabits() {
      const layer = document.getElementById("loginOrbLayer");
      if (!layer) return;
      const orbs = layer.querySelectorAll(".login-orb");
      const fallbackColors = ["#ff2d55", "#34c759", "#0a84ff"];
      orbs.forEach((orb, idx) => {
        const color = habits[idx % 3]?.color || fallbackColors[idx % 3] || "#ffffff";
        orb.style.background = color;
      });
      requestAnimationFrame(() => {
        layer.style.opacity = "1";
      });
    }

    function setLoginOrbsPaused(isPaused) {
      document.body.classList.toggle("login-orbs-paused", !!isPaused);
    }

    function escapeHtml(value) {
      return String(value || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function getIntroRingData() {
      const fallbackColors = ["#ff2d55", "#34c759", "#0a84ff"];
      const data = [];
      for (let i = 0; i < 3; i++) {
        const habit = habits[i];
        const progress = habit ? parseInt(habit.progress) || 0 : 0;
        const rawGoal = habit ? habit.goal : 0;
        const goal = (rawGoal === null || rawGoal === undefined) ? 0 : parseInt(rawGoal) || 0;
        const color = habit?.color || fallbackColors[i];
        data.push({ progress, goal, color });
      }
      return data;
    }

    function animateIntroRings(ringData) {
      if (!introRings.length) return;
      introRings.forEach((ring, idx) => {
        const { progress, goal, color } = ringData[idx] || {};
        const pct = goal > 0 ? Math.min(progress / goal, 1) : 0;
        const r = ring.r.baseVal.value;
        const circumference = 2 * Math.PI * r;
        ring.style.stroke = color || "#ffffff";
        ring.style.strokeDasharray = `${circumference}`;
        ring.style.strokeDashoffset = `${circumference * (1 - pct)}`;
      });
    }


    function launchIntroConfetti() {
      if (!introConfetti || !introProgressScreen) return;
      introConfetti.innerHTML = "";
      const colors = ["#ff2d55", "#34c759", "#0a84ff", "#ffd60a", "#ff9f0a"];
      const rect = introProgressScreen.getBoundingClientRect();
      const pieces = 70;
      for (let i = 0; i < pieces; i++) {
        const piece = document.createElement("div");
        piece.className = "intro-confetti-piece";
        piece.style.background = colors[i % colors.length];
        piece.style.left = `${Math.random() * rect.width}px`;
        piece.style.top = `${-20 - Math.random() * 40}px`;
        introConfetti.appendChild(piece);

        const drift = (Math.random() - 0.5) * 120;
        gsap.to(piece, {
          y: rect.height + 60,
          x: drift,
          rotation: Math.random() * 360,
          duration: 1.8 + Math.random() * 1.2,
          ease: "power1.in",
          delay: Math.random() * 0.35,
          onComplete: () => piece.remove()
        });
      }
    }

    async function showIntroProgressScreen() {
      if (!introProgressScreen) {
        showAppAfterDataLoaded();
        return;
      }

      introFlowDone = false;
      updateLoginOrbsFromHabits();
      const ringData = getIntroRingData();
      const allComplete = ringData.every(item => item.goal > 0 && item.progress >= item.goal);
      const streakValue = currentUser ? await loadStreakForUser(currentUser.id) : 0;
      const fallbackName = currentUser?.email ? currentUser.email.split("@")[0] : "da";
      const displayName = currentUser?.user_metadata?.display_name || fallbackName;
      const habitIds = habits.map(h => h.id).filter(Boolean);
      const monthlyCounts = await loadHabitDayCountsForMonth(habitIds);
      let compareLine = "";
      let compareShouldUnderline = false;

      if (introStreakValue) {
        introStreakValue.textContent = `${streakValue}`;
      }

      if (introHeadline) {
        introHeadline.textContent = `Hallo ${displayName}, lass uns kurz auf deinen Fortschritt schauen.`;
      }

      try {
        let otherUserData = otherUser;
        if (!otherUserData) {
          otherUserData = await loadOtherUser();
          otherUser = otherUserData;
        }

        if (otherUserData) {
          const otherHabits = await loadHabitsForUser(otherUserData.id);
          const myTotal = ringData.reduce((sum, item) => {
            const goal = item.goal || 0;
            const pct = goal > 0 ? Math.min(item.progress / goal, 1) : 0;
            return sum + pct;
          }, 0);
          const otherTotal = otherHabits.reduce((sum, habit) => {
            const progress = parseInt(habit.progress) || 0;
            const rawGoal = habit.goal;
            const goal = (rawGoal === null || rawGoal === undefined) ? 0 : parseInt(rawGoal) || 0;
            const pct = goal > 0 ? Math.min(progress / goal, 1) : 0;
            return sum + pct;
          }, 0);
          let compareWord = "gleichm√§√üig produktiv";
          if (myTotal > otherTotal) {
            compareWord = "produktiver";
          } else if (myTotal < otherTotal) {
            compareWord = "weniger produktiv";
          }
          const otherName = escapeHtml(otherUserData.display_name || "User2");
          compareShouldUnderline = compareWord === "produktiver" || compareWord === "weniger produktiv";
          const compareWordHtml = compareShouldUnderline
            ? `<span class="intro-compare-highlight">${compareWord}<span class="intro-compare-underline"></span></span>`
            : compareWord;
          if (compareWord === "gleichm√§√üig produktiv") {
            compareLine = `Du und ${otherName} sind gleichm√§√üig produktiv.`;
          } else {
            compareLine = `Du bist gerade ${compareWordHtml} als ${otherName}.`;
          }
        } else {
          compareLine = "Du bist gerade produktiv im Vergleich zu User2.";
        }
      } catch (err) {
        console.error("intro comparison error:", err);
      }

      if (introProgressMessage) {
        const parts = habits.map(habit => {
          const title = habit?.title ? escapeHtml(habit.title) : "Habit";
          const count = monthlyCounts[habit.id] || 0;
          const color = habit?.color || "var(--c-text)";
          return `<span style="color:${color}">${count}x ${title}</span>`;
        });
        const compareHtml = compareLine ? `<div class="intro-compare">${compareLine}</div>` : "";
        introProgressMessage.innerHTML = `Du hast diesen Monat ${parts.join(", ")} erledigt. Man merkt schon fast Konsistenz.${compareHtml}`;
        if (compareShouldUnderline) {
          const underlineEl = introProgressMessage.querySelector(".intro-compare-underline");
          if (underlineEl) underlineEl.style.transform = "scaleX(1)";
        }
      }

      introProgressScreen.style.display = "flex";
      introProgressScreen.setAttribute("aria-hidden", "false");
      introProgressScreen.style.opacity = "1";

      if (loginScreen && loginScreen.style.display !== "none") {
        gsap.to(loginScreen, {
          opacity: 0,
          duration: 0.35,
          ease: "sine.inOut",
          onComplete: () => { loginScreen.style.display = "none"; }
        });
      }

      animateIntroRings(ringData);
    }
    

    function showAppAfterDataLoaded() {
      updateLoginOrbsFromHabits();
      appPage.style.display = "block";
      gsap.fromTo(appPage, { opacity:0 }, {
        opacity:1,
        duration:0.5,
        ease:"sine.inOut"
      });

      if (introProgressScreen) {
        gsap.to(introProgressScreen, {
          opacity: 0,
          duration: 0.3,
          ease: "sine.inOut",
          onComplete: () => {
            introProgressScreen.style.display = "none";
            introProgressScreen.setAttribute("aria-hidden", "true");
            introProgressScreen.style.opacity = "";
          }
        });
      }

      if (loginScreen) {
        gsap.to(loginScreen, {
          opacity:0,
          duration:0.45,
          ease:"sine.inOut",
          onComplete: () => { loginScreen.style.display = "none"; }
        });
      }
    }

    async function proceedAfterIntro() {
      if (introFlowDone) return;
      introFlowDone = true;
      await requestIntroPermissionsOnce();
      showAppAfterDataLoaded();
      await ensureDesktopStats();
      await ensureAvatarSelected();
      await checkMedalScreen();
      const qr = getQRParam();
      if (qr) await processQRFlow(qr);
    }

    function updateDesktopLayoutHeights() {
      const isDesktop = window.matchMedia("(min-width: 768px)").matches;
      const leftCol = document.querySelector(".desktop-left");
      const cardsEl = document.querySelector(".desktop-left .cards");
      const actionsEl = document.querySelector(".desktop-actions");
      const workspaceEl = document.querySelector(".desktop-workspace");

      if (!leftCol || !cardsEl || !workspaceEl) return;
      if (!isDesktop) {
        cardsEl.style.height = "";
        cardsEl.style.removeProperty("--desktop-slot-height");
        workspaceEl.style.height = "";
        return;
      }

      const gap = parseFloat(getComputedStyle(leftCol).rowGap || getComputedStyle(leftCol).gap || 0);
      const actionsHeight = actionsEl ? actionsEl.getBoundingClientRect().height : 0;
      const cardsGap = parseFloat(getComputedStyle(cardsEl).rowGap || getComputedStyle(cardsEl).gap || 0);

      let statsHeight = statsViewEl ? statsViewEl.scrollHeight : 0;
      if (statsViewEl) {
        const bars = statsViewEl.querySelectorAll(".stat-bar");
        const lastBar = bars.length ? bars[bars.length - 1] : null;
        if (lastBar) {
          const statsRect = statsViewEl.getBoundingClientRect();
          const barRect = lastBar.getBoundingClientRect();
          statsHeight = Math.max(0, barRect.bottom - statsRect.top);
        }
      }

      workspaceEl.style.height = `${statsHeight}px`;
      const target = Math.max(0, statsHeight - actionsHeight - gap);
      const slotHeight = Math.max(120, (target - cardsGap * 2) / 3);
      const totalCardsHeight = slotHeight * 3 + cardsGap * 2;

      cardsEl.style.setProperty("--desktop-slot-height", `${slotHeight}px`);
      cardsEl.style.height = `${totalCardsHeight}px`;
    }

    function alignDesktopDividerHeight() {
      const isDesktop = window.matchMedia("(min-width: 768px)").matches;
      const dividerEl = document.querySelector(".desktop-divider");
      if (!dividerEl || !statsViewEl) return;

      if (!isDesktop) {
        dividerEl.style.height = "";
        return;
      }

      const statsRect = statsViewEl.getBoundingClientRect();
      const bars = statsViewEl.querySelectorAll(".stat-bar");
      const lastBar = bars.length ? bars[bars.length - 1] : null;

      let height = statsViewEl.scrollHeight;
      if (lastBar) {
        const barRect = lastBar.getBoundingClientRect();
        height = Math.max(0, barRect.bottom - statsRect.top);
      }
      dividerEl.style.height = `${height}px`;
    }

    function alignDesktopStatsTop() {
      const isDesktop = window.matchMedia("(min-width: 768px)").matches;
      if (!isDesktop || !statsViewEl || !remindersDesktopBtn) {
        if (statsViewEl) statsViewEl.style.marginTop = "";
        return;
      }

      const workspaceEl = document.querySelector(".desktop-workspace");
      if (!workspaceEl) return;

      const workspaceRect = workspaceEl.getBoundingClientRect();
      const btnRect = remindersDesktopBtn.getBoundingClientRect();
      const statsRect = statsViewEl.getBoundingClientRect();

      const desiredTop = btnRect.top - workspaceRect.top;
      const currentTop = statsRect.top - workspaceRect.top;
      const offset = desiredTop - currentTop;

      statsViewEl.style.marginTop = `${offset}px`;
    }
    
    async function ensureDesktopStats() {
      const isDesktop = window.matchMedia("(min-width: 768px)").matches;
      if (isDesktop) {
        statsOpen = true;
        if (statsViewEl) {
          statsViewEl.style.position = "relative";
          statsViewEl.style.top = "0";
          statsViewEl.style.bottom = "auto";
          statsViewEl.style.left = "auto";
          statsViewEl.style.right = "auto";
        }
        await refreshStatsLive();
        updateDesktopLayoutHeights();
        alignDesktopStatsTop();
        alignDesktopDividerHeight();
      } else if (statsViewEl) {
        statsViewEl.style.position = "";
        statsViewEl.style.top = "100svh";
        statsViewEl.style.bottom = "0";
        statsViewEl.style.left = "0";
        statsViewEl.style.right = "0";
        statsViewEl.style.marginTop = "";
        alignDesktopDividerHeight();
      }
    }

    // === Passwort-Reset-Funktionen (m√ºssen VOR dem Login-Block stehen) ===
    function showPasswordResetLink() {
      forgotPw.style.display = "block";
    }

    function hidePasswordResetLink() {
      forgotPw.style.display = "none";
    }

// LOGIN
// LOGIN-MODUS AUSW√ÑHLEN
btnLogin.onclick = () => {
  authMode = "login";
  loginName.style.display = "none";
  hidePasswordResetLink();

  loginForm.style.display = "flex";
  loginEmail.value = "";
  loginPassword.value = "";
  loginError.style.display = "none";
};

btnRegister.onclick = () => {
  authMode = "register";
  loginName.style.display = "block";
  hidePasswordResetLink();

  loginForm.style.display = "flex";
  loginEmail.value = "";
  loginPassword.value = "";
  loginName.value = "";
  loginError.style.display = "none";
};

// Passwort vergessen
forgotPw.onclick = () => {
  authMode = "reset";
  loginName.style.display = "none";
  showPasswordResetLink();

  loginForm.style.display = "flex";
  loginPassword.style.display = "none";   // Passwort verstecken
  loginError.style.display = "none";
};
    
    loginOkBtn.onclick = async () => {
      loginError.style.display = "none";

      const email    = loginEmail.value.trim();
      const password = loginPassword.value.trim();
      const name     = loginName.value.trim();

      if (!email || (!password && authMode !== "reset") || (authMode === "register" && !name)) {
        loginError.textContent = "Bitte alles ausf√ºllen.";
        loginError.style.display = "block";
        return;
      }

      let error;

      if (authMode === "login") {
        ({ error } = await supabaseClient.auth.signInWithPassword({ email, password }));
      }

      else if (authMode === "register") {
        const { error: signUpErr } = await supabaseClient.auth.signUp({
          email,
          password,
          options: { data: { display_name: name } }
        });
        error = signUpErr;
      }

      else if (authMode === "reset") {
        const { error: resetErr } = await supabaseClient.auth.resetPasswordForEmail(email, {
          redirectTo: window.location.href
        });

        if (resetErr) {
          loginError.textContent = resetErr.message;
          loginError.style.display = "block";
        } else {
          loginError.textContent = "E-Mail zum Zur√ºcksetzen gesendet.";
          loginError.style.display = "block";
        }
        return;
      }

      if (error) {
        loginError.textContent = error.message;
        loginError.style.display = "block";
        return;
      }

      const { data } = await supabaseClient.auth.getUser();
      currentUser = data.user;
      await ensurePushInfoRow();
      await loadUnreadNotificationCount();
      refreshBellIcon();
      startNotificationPolling();

      setupRealtime();
      setupShakeDetection();
      renderInitialLoadingSkeletons();

      await checkStreakResetGate();
      await checkReminderResetDaily();
      await safeLoadHabits();
      const subline = document.getElementById("loginSubline");
      if (subline) subline.style.display = "none";
      await proceedAfterIntro();
    };

    // === AUTOLOGIN + QR FLOW ===
    (async () => {
      const { data } = await supabaseClient.auth.getUser();

      if (data.user) {
        currentUser = data.user;
        await ensurePushInfoRow();
        await loadUnreadNotificationCount();
        refreshBellIcon();
        startNotificationPolling();

        setupRealtime();
        setupShakeDetection();
        renderInitialLoadingSkeletons();

        await checkStreakResetGate();
        await checkReminderResetDaily();
        await safeLoadHabits();
        await proceedAfterIntro();
      } else {
        // Kein Autologin m√∂glich ‚Üí Login anbieten
        const headline = document.getElementById("loginHeadline");
        const btnBar   = document.getElementById("loginButtonBar");

        if (loginScreen) {
          loginScreen.style.display = "flex";
          loginScreen.style.opacity = "1";
        }
        if (headline) headline.textContent = "Bitte melde dich an";
        if (btnBar)   btnBar.style.display = "flex";
      }
    })();
    

    function setupRealtime() {
      supabaseClient.channel('habits-realtime')
        .on(
          'postgres_changes',
          { event: '*', schema: 'public', table: 'habits' },
          async () => {
            if (statsOpen) await refreshStatsLive();
          }
        )
        .on(
          'postgres_changes',
          { event: '*', schema: 'public', table: 'streak_view' },
          async () => {
            if (statsOpen) await refreshStatsLive();
          }
        )
        .subscribe();
    }

    // ---------- TEIL 1: Nur-Server-Load + Initialisierung ----------
    async function safeLoadHabits() {
      if (!currentUser) {
        const { data } = await supabaseClient.auth.getUser();
        currentUser = data.user;
        if (!currentUser) return;
      }

      const { data, error } = await supabaseClient
        .from("habits")
        .select(`id, user_id, title, color, progress, goal, icon_type, location_address, qr_enabled, sub1_title, sub1_progress, sub2_title, sub2_progress, sub3_title, sub3_progress, inserted_at`)
        .eq("user_id", currentUser.id)
        .order("inserted_at", { ascending: true })
        .limit(3);

      if (error) {
        console.error("safeLoadHabits error:", error);
        return;
      }

      const rows = data || [];

      if (rows.length === 0) {
        await createInitialHabits();   // exakt 3 in DB anlegen
        return safeLoadHabits();       // danach erneut laden
      }

      habits = rows;

      clearAllSlots();
      const baseDelay = 0.0;
      habits.forEach((habit, i) => {
        const delay = baseDelay + (habits.length - 1 - i) * 0.12;
        createCardFromHabit(habit, i, delay);
      });

      refreshAddButtonIcon();
    }

    async function createInitialHabits() {
      if (!currentUser) return;

      const inserts = Array.from({ length: 3 }).map(() => ({
        user_id: currentUser.id,
        title: "",
        color: "#e4e4e4",
        progress: 0,
        goal: 1,
        appear_once: false,
        icon_type: "brain"
      }));

      const { error } = await supabaseClient.from("habits").insert(inserts);
      if (error) console.error("createInitialHabits error:", error);
    }

    function clearAllSlots() {
      slotOrder.forEach(id => { document.getElementById(id).innerHTML = ""; });
    }

    function renderStatsLoadingSkeleton() {
      if (!statsViewEl) return;

      const isDesktop = window.matchMedia("(min-width: 768px)").matches;
      if (isDesktop) {
        statsOpen = true;
        statsViewEl.style.position = "relative";
        statsViewEl.style.top = "0";
        statsViewEl.style.bottom = "auto";
        statsViewEl.style.left = "auto";
        statsViewEl.style.right = "auto";
      } else {
        statsViewEl.style.position = "";
        statsViewEl.style.top = "100svh";
        statsViewEl.style.bottom = "0";
        statsViewEl.style.left = "0";
        statsViewEl.style.right = "0";
      }

      const bars = Array.from({ length: 3 }).map(() => `
        <div class="stat-item">
          <div class="stat-bar" style="position:relative;">
            <div class="stat-bar-inner">
              <span class="stat-icon-skeleton"></span>
              <div class="stat-bar-track is-loading-skeleton">
                <div class="stat-progress is-loading-skeleton" style="
                  position:absolute;
                  inset:0;
                  border-radius:12px;
                  z-index:1;
                "></div>
                <div class="stat-bar-label stat-bar-label-skeleton">.</div>
              </div>
            </div>
          </div>
        </div>
      `).join("");

      statsViewEl.innerHTML = bars;
      updateDesktopLayoutHeights();
      alignDesktopStatsTop();
      alignDesktopDividerHeight();
    }

    function renderInitialLoadingSkeletons() {
      clearAllSlots();

      slotOrder.forEach(id => {
        const slot = document.getElementById(id);
        if (!slot) return;

        slot.innerHTML = `
          <div class="card is-loading-skeleton">
            <div class="card-face front">
              <div class="card-skeleton-title"></div>
              <div class="counter-wrap">
                <div class="card-skeleton-chip"></div>
              </div>
            </div>
          </div>
        `;
      });

      renderStatsLoadingSkeleton();

      appPage.style.display = "block";
      appPage.style.opacity = "1";

      if (loginScreen && loginScreen.style.display !== "none") {
        gsap.to(loginScreen, {
          opacity: 0,
          duration: 0.25,
          ease: "sine.inOut",
          onComplete: () => { loginScreen.style.display = "none"; }
        });
      }
    }

    function refreshAddButtonIcon() {
      const addBtn = addBtnEl;

      if (addBtn.dataset.mode === "notifications") {
        addBtn.innerHTML = '<i data-lucide="house-heart"></i>';
        lucide.createIcons();
        return;
      }

      if (addBtn.dataset.mode === "stats") {
        addBtn.innerHTML = '<i data-lucide="house-heart"></i>';
        lucide.createIcons();
        return;
      }

      if (habits.length < 3) {
        addBtn.innerHTML = '<i data-lucide="plus"></i>';
      } else {
        addBtn.innerHTML = '<i data-lucide="house-heart"></i>';
      }

      lucide.createIcons();
    }

    
    // -------------------------------
    // Notifications / Push (DB-backed)
    // -------------------------------

    async function ensurePushInfoRow() {
      if (!currentUser) return;
      const uid = currentUser.id;

      const permission_state =
        !supportsPush ? "unsupported" :
        (Notification.permission === "granted" ? "granted" :
         Notification.permission === "denied" ? "denied" : "unknown");

      const { error } = await supabaseClient
        .from("push_info")
        .upsert({
          user_id: uid,
          permission_state,
          platform_capabilities: {
            supportsPush,
            userAgent: navigator.userAgent || ""
          }
        });

      if (error) console.error("push_info upsert error:", error);
    }
    
    async function loadUnreadNotificationCount() {
      if (!currentUser) return 0;
      const uid = currentUser.id;

      const { count, error } = await supabaseClient
        .from("notification_message")
        .select("id", { count: "exact", head: true })
        .eq("user_id", uid)
        .is("read_at", null);

      if (error) {
        console.error("unread count error:", error);
        return 0;
      }

      unreadNotificationCount = count || 0;
      return unreadNotificationCount;
    }

    async function loadNotifications(limit = 30) {
      if (!currentUser) return [];
      const uid = currentUser.id;

      const { data, error } = await supabaseClient
        .from("notification_message")
        .select("id, type, title, body, payload, created_at, read_at")
        .eq("user_id", uid)
        .order("created_at", { ascending: false })
        .limit(limit);

      if (error) {
        console.error("loadNotifications error:", error);
        return [];
      }
      return data || [];
    }

    async function markAllNotificationsRead() {
      if (!currentUser) return;
      const uid = currentUser.id;

      const { error } = await supabaseClient
        .from("notification_message")
        .update({ read_at: new Date().toISOString() })
        .eq("user_id", uid)
        .is("read_at", null);

      if (error) {
        console.error("markAllNotificationsRead error:", error);
        return;
      }

      unreadNotificationCount = 0;
    }

    async function fetchPushVapidPublicKey() {
      if (pushVapidPublicKeyCache) return pushVapidPublicKeyCache;
      const res = await fetch(`${PUSH_API_BASE}/vapid-public-key`, { method: "GET" });
      if (!res.ok) throw new Error(`vapid-public-key request failed (${res.status})`);
      const data = await res.json();
      if (!data?.publicKey) throw new Error("vapid-public-key missing publicKey");
      pushVapidPublicKeyCache = data.publicKey;
      return pushVapidPublicKeyCache;
    }

    // NOTE: Push subscription requires HTTPS (or localhost). It will not work on file://
    async function registerPushSubscription() {
      if (!supportsPush) return;
      if (!currentUser) return;
      if (Notification.permission !== "granted") return;

      try {
        const reg = await navigator.serviceWorker.register("/habits/sw.js");
        const publicKey = await fetchPushVapidPublicKey();
        let sub = await reg.pushManager.getSubscription();
        if (!sub) {
          sub = await reg.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: urlBase64ToUint8Array(publicKey)
          });
        }

        const res = await fetch(`${PUSH_API_BASE}/subscribe`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            userId: currentUser.id,
            subscription: sub.toJSON()
          })
        });

        if (!res.ok) {
          const body = await res.text();
          throw new Error(`worker /subscribe failed (${res.status}): ${body}`);
        }
      } catch (e) {
        console.error("registerPushSubscription error:", e);
      }
    }
    
    
    function refreshBellIcon() {
      if (!bellBtnEl) return;

      const icon = "cookie";

      bellBtnEl.innerHTML = `<i data-lucide="${icon}"></i>`;
      lucide.createIcons({ scope: bellBtnEl });

      if (remindersDesktopBtn) {
        remindersDesktopBtn.innerHTML = `<i data-lucide="${icon}"></i>`;
        lucide.createIcons({ scope: remindersDesktopBtn });
      }

    }

    async function toggleDesktopReminderPopover() {
      if (!desktopReminderPopover) return;
      const isOpen = desktopReminderPopover.classList.contains("is-open");

      if (isOpen) {
        if (window.gsap) {
          gsap.to(desktopReminderPopover, {
            opacity: 0,
            scale: 0.98,
            duration: 0.18,
            ease: "power1.in",
            onComplete: () => {
              desktopReminderPopover.classList.remove("is-open");
              desktopReminderPopover.setAttribute("aria-hidden", "true");
              desktopReminderPopover.style.opacity = "";
              desktopReminderPopover.style.transform = "";
            }
          });
        } else {
          desktopReminderPopover.classList.remove("is-open");
          desktopReminderPopover.setAttribute("aria-hidden", "true");
        }
        return;
      }

      const rows = await loadNotifications(1);
      const row = rows && rows.length ? rows[0] : null;
      const title = row?.title || "Reminders";
      const body = row?.body || "Keine neuen Reminders.";

      if (desktopReminderTitle) desktopReminderTitle.textContent = title;
      if (desktopReminderBody) desktopReminderBody.textContent = body;

      desktopReminderPopover.classList.add("is-open");
      desktopReminderPopover.setAttribute("aria-hidden", "false");
      lucide.createIcons({ scope: desktopReminderPopover });

      if (window.gsap) {
        gsap.fromTo(desktopReminderPopover, { opacity: 0, scale: 0.98 }, {
          opacity: 1,
          scale: 1,
          duration: 0.22,
          ease: "power2.out"
        });
      }

      await markAllNotificationsRead();
      await loadUnreadNotificationCount();
      refreshBellIcon();
    }

    function createCardFromHabit(habit, index, delay = 0) {
      const slot = document.getElementById(slotOrder[index]);
      const card = document.createElement("div");
      card.className = "card";

      const rawGoal   = habit.goal;
      let goal      = (rawGoal === null || rawGoal === undefined) ? 1 : rawGoal;
      const progress  = parseInt(habit.progress) || 0;
      const dbColor   = habit.color || "#e4e4e4";
      const addr      = habit.location_address || "";
      const qrEnabled = habit.qr_enabled || false;
      const lastScanned = habit.last_scanned || null;
      const scannedToday = isToday(lastScanned);
      const iconType = normalizeHabitIcon(habit.icon_type);

      if (!qrEnabled && isSpeisequarkTitle(habit.title)) {
        goal = 2;
      }

      card.dataset.index    = index;
      card.dataset.habitId  = habit.id;
      card.dataset.goal     = goal;
      card.dataset.progress = progress;
      card.dataset.color    = dbColor;
      card.dataset.iconType = iconType;
      card.dataset.location = addr;
      card.dataset.qr       = qrEnabled ? "true" : "false";
      // subtask data (persisted columns)
      card.dataset.sub1_title = habit.sub1_title || "";
      card.dataset.sub1_progress = habit.sub1_progress || 0;
      card.dataset.sub2_title = habit.sub2_title || "";
      card.dataset.sub2_progress = habit.sub2_progress || 0;
      card.dataset.sub3_title = habit.sub3_title || "";
      card.dataset.sub3_progress = habit.sub3_progress || 0;

      const isActive = progress > 0;
      card.dataset.active = isActive ? "true" : "false";

      // --- HTML ---
      card.innerHTML = `
      <div class="card-face front">
        <div class="front-header">
          <div class="card-input" contenteditable="true" data-placeholder="Titel eingeben..."></div>
          <div class="counter-wrap">
            <div class="counter counter-kcal" style="display:none;"></div>
            <button class="card-flip-btn" aria-label="Karte umdrehen">
              <i data-lucide="eye"></i>
            </button>
          </div>
        </div>

        <div class="expand-area" style="display:none;">
          <div class="expand-divider"></div>
          <div class="subtasks"></div>
          <div class="add-subtask">
            <i data-lucide="plus-circle"></i>
          </div>
        </div>
      </div>

        <div class="card-face back">
          <button class="card-flip-back" aria-label="Zur√ºck">
            <i data-lucide="corner-up-left"></i>
          </button>

          <!-- GPS AREA -->
          <div class="quarter" id="gpsArea">
            <div style="display:flex; flex-direction:column; align-items:center; gap:4px;">
              <i data-lucide="map-pin" style="width:28px;height:28px;color:#777;"></i>

              <div class="gps-address-line1" style="
                font-size:0.7rem;
                color:#555;
                text-align:center;
                line-height:1;
                display:none;
              "></div>

              <div class="gps-address-line2" style="
                font-size:0.7rem;
                color:#555;
                text-align:center;
                line-height:1;
                display:none;
              "></div>
            </div>
          </div>

          <!-- UNDO / DECREMENT AREA -->
          <div class="quarter" id="undoArea">
            <div style="display:flex; flex-direction:column; align-items:center; gap:4px;">
              <i data-lucide="timer-reset" style="width:28px;height:28px;color:#777;"></i>
            </div>
          </div>

          <!-- SQUARES-SUBTRACT AREA -->
          <div class="quarter" id="collapseArea">
            <div style="display:flex; flex-direction:column; align-items:center; gap:4px;">
              <i data-lucide="squares-subtract" style="width:28px;height:28px;color:#777;"></i>
            </div>
          </div>

          <!-- Counter & GPS Input -->
          <div class="quarter" id="numAreaWrapper">
            <div id="numArea">0</div>

            <input 
              id="gpsInput"
              type="text"
              placeholder="Adresse eingeben..."
              style="
                display:none;
                width:100%;
                padding:6px;
                border-radius:12px;
                border:1px solid #ccc;
                font-size:0.9rem;
              "
            />
          </div>

        </div>
      `;

      slot.appendChild(card);
      lucide.createIcons();

      // --- DOM REFS ---
      const input   = card.querySelector(".card-input");
      const counter = card.querySelector(".counter");
      const flipBtn = card.querySelector(".card-flip-btn");
      const isQR = qrEnabled;
      const kcalTarget = 21000;

      if (isQR) {
        counter.style.display = "block";
        counter.textContent = `${parseInt(progress)} KCAL`;
      } else {
        const goal = parseInt(card.dataset.goal) || 1;
        if (goal >= 2) {
          counter.style.display = "block";
          counter.textContent = `${progress}/${goal}`;
        } else {
          counter.style.display = "none";
        }
      }
      const numArea = card.querySelector("#numArea");

      const line1 = card.querySelector(".gps-address-line1");
      const line2 = card.querySelector(".gps-address-line2");


      // === Titel ===
      input.textContent = habit.title || "";

      // === Adresse anzeigen ===
      if (addr) {
        const parts = addr.split(",");
        line1.textContent = (parts[0] || "").trim();
        line2.textContent = (parts[1] || "").trim();
        line1.style.display = "block";
        line2.style.display = "block";
      } else {
        line1.style.display = "none";
        line2.style.display = "none";
      }


      // === Counter ===
      numArea.textContent = goal;
      if (goal >= 2) {
        counter.style.display = "block";
        counter.textContent = progress + "/" + goal;
      } else {
        counter.style.display = "none";
      }

      const enforced = enforceSpeisequarkGoal(card, input.textContent);

      // === Farben ===
      const progValue = parseInt(progress) || 0;

      if (progValue > 0) {
        card.style.background = dbColor;
        input.style.color     = darken(dbColor);
        card.dataset.active   = "true";
      } else {
        card.style.background = "#e4e4e4";
        input.style.color     = "#666";
        card.dataset.active   = "false";
        card.dataset.color    = "#e4e4e4";
      }
      if (flipBtn) flipBtn.style.color = input.style.color || "#666";

      // === Animation ===
      gsap.fromTo(card, { opacity:0 }, {
        opacity:1,
        duration:0.4,
        ease:"power1.out",
        delay
      });
      
      if (qrEnabled) {
        const kcalProgress = parseInt(progress) || 0;
        counter.style.display = "block";
        counter.textContent = `${kcalProgress} KCAL`;
      }
      
      attachCardLogic(card);

      if (enforced) {
        saveHabit(card);
      }
    }

    function shake(card) {
      gsap.fromTo(card,
        { x:-10 },
        { x:10, duration:0.1, repeat:3, yoyo:true, ease:"power1.inOut",
          onComplete: () => { card.style.transform = ""; }
        }
      );
    }
    
    function attachCardLogic(card) {
      const input     = card.querySelector(".card-input");
      const counter   = card.querySelector(".counter");
      const gpsArea   = card.querySelector("#gpsArea");
      const numArea   = card.querySelector("#numArea");
      const gpsInput  = card.querySelector("#gpsInput");
      const undoArea  = card.querySelector("#undoArea");
      const collapseArea = card.querySelector("#collapseArea");
      const flipBtn = card.querySelector(".card-flip-btn");
      const flipBackBtn = card.querySelector(".card-flip-back");

      let swipeStartX = 0;
      let swipeEndX   = 0;

      // ======================================
      // SWIPE FRONT/BACK
      // ======================================
      card.addEventListener("touchstart",(e)=>{
        swipeStartX = e.touches[0].clientX;
        swipeEndX   = swipeStartX;
      });

      card.addEventListener("touchmove",(e)=>{
        swipeEndX = e.touches[0].clientX;
      });

      card.addEventListener("touchend",()=>{
        const dx = swipeEndX - swipeStartX;

        if (dx < -40 && !card.style.transform.includes("180deg")){
          gsap.to(card,{ rotationY:180, duration:0.48, ease:"sine.inOut" });
        }
        if (dx > 40 && card.style.transform.includes("180deg")){
          gsap.to(card,{ rotationY:0, duration:0.48, ease:"sine.inOut" });
        }
      });

      if (flipBtn) {
        flipBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          if (isDesktopView()) {
            card.style.transform = "rotateY(180deg)";
          } else {
            gsap.to(card,{ rotationY:180, duration:0.48, ease:"sine.inOut" });
          }
        });
      }

      if (flipBackBtn) {
        flipBackBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          if (isDesktopView()) {
            card.style.transform = "rotateY(0deg)";
          } else {
            gsap.to(card,{ rotationY:0, duration:0.48, ease:"sine.inOut" });
          }
        });
      }

      // ======================================
      // NUMMER / GOAL √ÑNDERN (NICHT BEI QR)
      // ======================================
      numArea.addEventListener("click",(e)=>{
        e.stopPropagation();

        // QR-Mode deaktiviert die Goal-√Ñnderung
        if (card.dataset.qr === "true") return;
        if (isSpeisequarkTitle(input.textContent)) {
          numArea.textContent = "2";
          return;
        }

        let y = parseInt(card.dataset.goal) || 0;
        y = (y + 1) % 8;

        card.dataset.goal = y;
        numArea.textContent = y;

        let x = parseInt(card.dataset.progress) || 0;
        if (x > y) {
          x = y;
          card.dataset.progress = x;
        }

        if (y >= 2) {
          counter.style.display = "block";
          counter.textContent   = x + "/" + y;
        } else {
          counter.style.display = "none";
        }

        saveHabit(card);
      });

      // ======================================
      // GPS EINGABE
      // ======================================
      gpsArea.addEventListener("click", (e) => {
        e.stopPropagation();

        gsap.to(card, { rotationY:180, duration:0.48, ease:"sine.inOut" });

        gpsInput.style.display = "block";
        numArea.style.display = "none";

        gpsInput.value = card.dataset.location || "";
        gpsInput.focus();
      });

      gpsInput.addEventListener("blur", async () => {
        const addr = gpsInput.value.trim();
        card.dataset.location = addr;

        gpsInput.style.display = "none";
        numArea.style.display = "flex";

        const habitId = card.dataset.habitId;
        if (habitId) {
          const { error } = await supabaseClient
            .from("habits")
            .update({ location_address: addr })
            .eq("id", habitId);

          if (error) console.error("GPS address save error:", error);
        }
      });

      // ======================================
      // UNDO / DECREMENT PROGRESS BY 1
      // ======================================
      if (undoArea) {
        undoArea.addEventListener("click", async (e) => {
          e.stopPropagation();

          let progress = parseInt(card.dataset.progress) || 0;
          if (progress <= 0) return;

          progress -= 1;
          card.dataset.progress = progress;

          const goal = parseInt(card.dataset.goal) || 1;
          const counter = card.querySelector(".counter");

          if (goal >= 2) {
            counter.style.display = "block";
            counter.textContent = progress + "/" + goal;
          } else {
            if (progress <= 0) counter.style.display = "none";
          }

          if (progress <= 0) {
            card.dataset.active = "false";
            card.style.background = "#e4e4e4";
            const input = card.querySelector(".card-input");
            input.style.color = "#666";
            card.dataset.color = "#e4e4e4";
          }

          const habitId = card.dataset.habitId;
          if (!habitId) return;

          const { error } = await supabaseClient
            .from("habits")
            .update({ progress })
            .eq("id", habitId);

          if (error) {
            console.error("decrement progress error:", error);
          } else {
            syncHabitDayForProgress(habitId, progress);
          }
        });
      }

      // ======================================
      // EXPAND CARD (SQUARES-SUBTRACT)
      // ======================================
      if (collapseArea) {
        collapseArea.addEventListener("click", (e) => {
          e.stopPropagation();

            // rotate to front then delegate to expandCard which handles minimize/button behavior
            gsap.to(card, { rotationY: 0, duration: 0.45, ease: "sine.inOut", onComplete: () => {
              expandCard(card);
            }});
        });
      }

      // ======================================
      // SUBTASKS (refactored, delegation-based)
      // ======================================
      const subtasksWrap = card.querySelector(".subtasks");
      const addSubtaskBtn = card.querySelector(".add-subtask");

      function recalcFromSubtasks() {
        const rows = subtasksWrap.querySelectorAll(".subtask");
        if (rows.length === 0) { card.dataset.subtasksComplete = "false"; return; }

        const allDone = Array.from(rows).every(r => r.dataset.done === "true");
        card.dataset.subtasksComplete = allDone ? "true" : "false";
      }

      function createSubtask(title = "") {
        const existingCount = subtasksWrap.querySelectorAll('.subtask').length;
        if (existingCount >= 3) return null;

        const row = document.createElement("div");
        row.className = "subtask";
        row.dataset.done = "false";

        row.innerHTML = `
          <button class="subtask-toggle" aria-pressed="false" style="background:transparent;border:none;padding:0;margin-right:8px;display:flex;align-items:center;">
            <i data-lucide="circle"></i>
          </button>
          <input class="subtask-title" placeholder="Unteraufgabe..." value="${title}">
        `;

        const inputEl = row.querySelector(".subtask-title");

        inputEl.addEventListener("click", e => e.stopPropagation());
        inputEl.addEventListener("pointerdown", e => e.stopPropagation());
        inputEl.addEventListener("touchstart", e => e.stopPropagation());
        inputEl.addEventListener("blur", (e) => { recalcFromSubtasks(); saveHabit(card); });

        subtasksWrap.appendChild(row);
        syncSubtaskColors();
        lucide.createIcons({ scope: row });
        recalcFromSubtasks();
        return row;
      }

      // Delegated handlers: stop pointerdown/touchstart to prevent card handlers
      // (long-press / touchstart on the card) and handle pointerup to toggle.
      subtasksWrap.addEventListener('pointerdown', (e) => {
        const btn = e.target.closest('.subtask-toggle');
        if (!btn) return;
        e.stopPropagation();
        e.preventDefault && e.preventDefault();
      });
      subtasksWrap.addEventListener('touchstart', (e) => {
        const btn = e.target.closest('.subtask-toggle');
        if (!btn) return;
        e.stopPropagation();
      });

      // Delegated handler: handle pointerup on container so rendered SVGs are caught
      subtasksWrap.addEventListener('pointerup', (e) => {
        const btn = e.target.closest('.subtask-toggle');
        if (!btn) return;
        e.stopPropagation();
        e.preventDefault && e.preventDefault();

        const row = btn.closest('.subtask');
        if (!row) return;

        const allRows = Array.from(subtasksWrap.querySelectorAll('.subtask'));
        const allDoneBefore = allRows.length > 0 && allRows.every(r => r.dataset.done === 'true');

        // Toggle this row
        const wasDone = row.dataset.done === 'true';
        row.dataset.done = wasDone ? 'false' : 'true';

        // Update icon visual
        const newIconName = wasDone ? 'circle' : 'circle-check';
        btn.innerHTML = `<i data-lucide="${newIconName}"></i>`;
        btn.setAttribute('aria-pressed', row.dataset.done === 'true' ? 'true' : 'false');
        lucide.createIcons({ scope: btn });

        // color the newly rendered icon to match the card title color
        try {
          const titleColor = card.querySelector('.card-input')?.style.color || darken(card.dataset.color || '#e4e4e4');
          const sv = btn.querySelector('svg');
          if (sv) {
            sv.style.color = titleColor;
            sv.setAttribute('stroke', titleColor);
            sv.setAttribute('fill', 'none');
            sv.querySelectorAll('*').forEach(el => { try { el.setAttribute('stroke', titleColor); if (!el.getAttribute('fill') || el.getAttribute('fill') === 'none') el.setAttribute('fill','none'); } catch(e){} });
          }
        } catch(e){}

        // Recompute after toggle
        const allDoneAfter = allRows.every(r => (r === row ? row.dataset.done === 'true' : r.dataset.done === 'true'));

        // If subtasks exist, only change main progress when full completion state changes
        try {
          const cardEl = card;
          const goal = parseInt(cardEl.dataset.goal) || 1;
          let progress = parseInt(cardEl.dataset.progress) || 0;
          let active = cardEl.dataset.active === 'true';

          if (!allDoneBefore && allDoneAfter) {
            // became fully completed -> increment progress by one step
            if (goal <= 1) {
              if (!active) {
                progress = 1;
                active = true;
                const idx = parseInt(cardEl.dataset.index);
                let col = cardEl.dataset.color;
                if (!col || col === '#e4e4e4') col = cycleColors[idx % cycleColors.length];
                cardEl.style.background = col;
                cardEl.dataset.color = col;
                const inputElTitle = cardEl.querySelector('.card-input');
                if (inputElTitle) inputElTitle.style.color = darken(col);
              }
            } else {
              if (progress < goal) {
                progress += 1;
                active = true;
                const idx = parseInt(cardEl.dataset.index);
                let col = cardEl.dataset.color;
                if (!col || col === '#e4e4e4') col = cycleColors[idx % cycleColors.length];
                cardEl.style.background = col;
                cardEl.dataset.color = col;
                const inputElTitle = cardEl.querySelector('.card-input');
                if (inputElTitle) inputElTitle.style.color = darken(col);
              }
            }
          }

          if (allDoneBefore && !allDoneAfter) {
            // became not fully completed -> decrement progress by one step
            if (goal <= 1) {
              if (active) {
                progress = 0;
                active = false;
                cardEl.style.background = '#e4e4e4';
                cardEl.dataset.color = '#e4e4e4';
                const inputElTitle = cardEl.querySelector('.card-input');
                if (inputElTitle) inputElTitle.style.color = '#666';
              }
            } else {
              if (progress > 0) {
                progress = Math.max(0, progress - 1);
                if (progress === 0) {
                  active = false;
                  cardEl.style.background = '#e4e4e4';
                  cardEl.dataset.color = '#e4e4e4';
                  const inputElTitle = cardEl.querySelector('.card-input');
                  if (inputElTitle) inputElTitle.style.color = '#666';
                }
              }
            }
          }

          cardEl.dataset.progress = progress;
          cardEl.dataset.active = active ? 'true' : 'false';

          // Update counter UI
          const counterEl = cardEl.querySelector('.counter');
          if (counterEl) {
            if (parseInt(cardEl.dataset.goal) >= 2) {
              counterEl.style.display = 'block';
              counterEl.textContent = progress + '/' + (parseInt(cardEl.dataset.goal) || 1);
            } else {
              counterEl.style.display = (progress > 0) ? 'block' : 'none';
              if (progress > 0) counterEl.textContent = progress;
            }
          }

          // Persist both subtask states and main progress
          saveHabit(cardEl);
          syncHabitDayForProgress(cardEl.dataset.habitId, progress);
        } catch (err) {
          console.error('subtask progress sync error', err);
        }

        recalcFromSubtasks();
      });

      if (addSubtaskBtn) {
        addSubtaskBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          // enforce max 3 subtasks
          const count = subtasksWrap.querySelectorAll('.subtask').length;
          if (count >= 3) return;
          const r = createSubtask("");
          if (r) {
            // immediately focus the input for quick editing
            const inp = r.querySelector('.subtask-title');
            if (inp) inp.focus();
          }
        });
      }

      // Load persisted subtasks from dataset (if any)
      (function loadSubtasksFromDataset(){
        const subs = [
          { title: card.dataset.sub1_title || '', prog: parseInt(card.dataset.sub1_progress) || 0 },
          { title: card.dataset.sub2_title || '', prog: parseInt(card.dataset.sub2_progress) || 0 },
          { title: card.dataset.sub3_title || '', prog: parseInt(card.dataset.sub3_progress) || 0 }
        ];

        subs.forEach(s => {
          if (s.title && s.title.trim().length > 0) {
            const row = createSubtask(s.title);
            if (row && s.prog > 0) {
              row.dataset.done = 'true';
              const btn = row.querySelector('.subtask-toggle');
              if (btn) {
                  btn.innerHTML = `<i data-lucide="circle-check"></i>`;
                  btn.setAttribute('aria-pressed','true');
                  lucide.createIcons({ scope: btn });
                  try {
                    const titleColor = card.querySelector('.card-input')?.style.color || darken(card.dataset.color || '#e4e4e4');
                    const sv = btn.querySelector('svg');
                    if (sv) { sv.style.color = titleColor; sv.setAttribute('stroke', titleColor); sv.setAttribute('fill','none'); sv.querySelectorAll('*').forEach(el=>{ try{ el.setAttribute('stroke', titleColor); if(!el.getAttribute('fill')||el.getAttribute('fill')==='none') el.setAttribute('fill','none'); }catch(e){} }); }
                  } catch(e){}
                }
            }
          }
        });
        recalcFromSubtasks();

        // If no persisted subtasks, leave the UI available so users can add new ones.
        // Previously we hid the entire subtask UI when columns were empty ‚Äî that prevented
        // creating new subtasks. Keep expand-area/add-subtask visible on expand, but
        // do not auto-create rows here.
      })();

      function syncSubtaskColors() {
        // Use the actual title color (it may be a darkened variant of the
        // background color or a fallback like "#666"). This ensures subtitles
        // match the visible title color exactly.
        const titleEl = card.querySelector('.card-input');
        const titleColor = (titleEl && titleEl.style && titleEl.style.color)
          ? titleEl.style.color
          : darken(card.dataset.color || '#e4e4e4');
        const flipBtn = card.querySelector('.card-flip-btn');
        if (flipBtn) flipBtn.style.color = titleColor;

        card.querySelectorAll('.subtask-title').forEach(el => {
          el.style.color = titleColor;
          // also set placeholder color via CSS variable so ::placeholder matches
          el.style.setProperty('--ph', titleColor);
        });

        card.querySelectorAll('.subtask i').forEach(icon => {
          icon.style.color = titleColor;
        });

        // Ensure rendered SVGs use the same stroke/fill color as the title
        card.querySelectorAll('.subtask i svg').forEach(svg => {
          try {
            svg.style.color = titleColor;
            svg.setAttribute('stroke', titleColor);
            // keep fill none for outline icons; checked icons will still show stroke color
            svg.setAttribute('fill', 'none');
            // also update nested paths if lucide inserted them
            svg.querySelectorAll('*').forEach(el => {
              if (el.setAttribute) {
                el.setAttribute('stroke', titleColor);
                // avoid forcing fill on shapes that might be intended to be filled
                if (!el.getAttribute('fill') || el.getAttribute('fill') === 'none') {
                  el.setAttribute('fill', 'none');
                }
              }
            });
          } catch (e) {}
        });

        const divider = card.querySelector('.expand-divider');
        if (divider) divider.style.background = titleColor;

        // Color the add-subtask plus icon to match title color as well
        const addIconWrap = card.querySelector('.add-subtask i');
        if (addIconWrap) {
          try {
            addIconWrap.style.color = titleColor;
            const sv = addIconWrap.querySelector('svg');
            if (sv) {
              sv.style.color = titleColor;
              sv.setAttribute('stroke', titleColor);
              sv.setAttribute('fill', 'none');
              sv.querySelectorAll('*').forEach(el => { try { el.setAttribute('stroke', titleColor); if (!el.getAttribute('fill') || el.getAttribute('fill') === 'none') el.setAttribute('fill','none'); } catch(e){} });
            }
          } catch (e) {}
        }
      }

      // apply colors immediately so icons (plus-circle etc.) match the title on first render
      try { syncSubtaskColors(); } catch (e) { /* ignore */ }

      input.addEventListener("blur", syncSubtaskColors);

      // ======================================
      // LONG-PRESS FARBE
      // ======================================
      let pressTimer = null;
      let pressInterval = null;
      let lastColor = null;

      card.addEventListener("touchstart",()=>{
        clearTimeout(pressTimer);
        clearInterval(pressInterval);
        lastColor = null;

        pressTimer = setTimeout(()=>{
          if (card.dataset.active === "true") {
            let i = 0;
            pressInterval = setInterval(()=>{
              const col = cycleColors[i % cycleColors.length];
              card.style.background = col;
              card.dataset.color    = col;
              input.style.color     = darken(col);
              syncSubtaskColors();
              lastColor = col;
              i++;
            },900);
          }
        },300);
      });

      card.addEventListener("touchend",()=>{
        clearTimeout(pressTimer);
        clearInterval(pressInterval);
        if (lastColor) saveHabit(card);
      });

      // ======================================
      // TITLE SAVE
      // ======================================
      input.addEventListener("blur", ()=> { saveHabit(card); });
      input.addEventListener("keydown", (e)=>{
        if(e.key==="Enter"){ e.preventDefault(); input.blur(); }
      });

      // CARD EXPAND: helper to expand a card based on its vertical position
      function expandCard(cardEl) {
        if (!cardEl) return;
        if (cardEl.classList.contains('expanded')) return;

        const allCards = Array.from(document.querySelectorAll('.card'));
        if (allCards.length === 0) return;

        const rects = allCards.map(c => ({ c, rect: c.getBoundingClientRect(), top: c.getBoundingClientRect().top }));
        const sorted = rects.slice().sort((a,b) => a.top - b.top);
        const topRect = sorted[0].rect;
        const bottomRect = sorted[sorted.length - 1].rect;
        const cardRect = cardEl.getBoundingClientRect();

        const isTop = Math.abs(cardRect.top - topRect.top) < 4;
        const isBottom = Math.abs(cardRect.top - bottomRect.top) < 4;

        let targetTop = cardRect.top;
        let targetHeight = bottomRect.bottom - cardRect.top;

        if (isTop) {
          // top card: expand down to bottom of bottom card
          targetTop = cardRect.top;
          targetHeight = bottomRect.bottom - cardRect.top;
        } else if (!isTop && !isBottom) {
          // middle card: expand from top of top card to bottom of bottom card
          targetTop = topRect.top;
          targetHeight = bottomRect.bottom - topRect.top;
        } else if (isBottom) {
          // bottom card: expand upward to top of top card
          targetTop = topRect.top;
          targetHeight = cardRect.bottom - topRect.top;
        }

        const deltaY = targetTop - cardRect.top;

        // hide other cards
        allCards.forEach(c => {
          if (c !== cardEl) {
            gsap.to(c, { opacity: 0, duration: 0.25, ease: 'power1.out', pointerEvents: 'none' });
          }
        });

        // store original inline styles for restore
        cardEl.dataset.origInlineHeight = cardEl.style.height || '';
        cardEl.dataset.origInlineTransform = cardEl.style.transform || '';
        cardEl.dataset.origInlineZ = cardEl.style.zIndex || '';

        const expandArea = cardEl.querySelector('.expand-area');
        if (expandArea) expandArea.style.display = 'block';

        cardEl.style.zIndex = '9999';
        cardEl.classList.add('expanded');

        // add minimize button if missing ‚Äî place it in the center of the bottom buttons row
        const buttonsRow = document.querySelector('.buttons-row');
        let bottomMin = buttonsRow ? buttonsRow.querySelector('.minimize-bottom-btn') : null;
        if (!bottomMin && buttonsRow) {
          bottomMin = document.createElement('button');
          bottomMin.className = 'minimize-bottom-btn';
          // transparent background, no shadow, icon will be white
          bottomMin.style.cssText = 'flex:0 0 60px; width:60px; height:60px; margin:0; border-radius:999px; background:transparent; border:none; display:flex; align-items:center; justify-content:center; cursor:pointer; z-index:10002; pointer-events:auto;';
          bottomMin.innerHTML = '<i data-lucide="minimize-2"></i>';
          // insert between addBtnEl and statsBtnEl
          const statsBtn = document.querySelector('.btn-stats');
          if (statsBtn && statsBtn.parentNode) statsBtn.parentNode.insertBefore(bottomMin, statsBtn);
          else if (buttonsRow) buttonsRow.appendChild(bottomMin);
          lucide.createIcons({ scope: bottomMin });

          // ensure it receives pointer events
          bottomMin.addEventListener('pointerdown', ev => { ev.stopPropagation(); });
          bottomMin.addEventListener('touchstart', ev => { ev.stopPropagation(); });
          bottomMin.addEventListener('touchend', ev => { ev.stopPropagation(); ev.preventDefault && ev.preventDefault(); try { bottomMin.click(); } catch(e){} });
        }

        // set icon color to white (no background button).
        // Also force the generated SVG stroke/fill to white in case lucide injected explicit attributes.
        if (bottomMin) {
          const icon = bottomMin.querySelector('i');
          if (icon) icon.style.color = '#fff';
          const svg = bottomMin.querySelector('svg');
          if (svg) {
            try {
              svg.style.color = '#fff';
              svg.setAttribute('stroke', '#fff');
              svg.setAttribute('fill', 'none');
              svg.setAttribute('stroke-width', svg.getAttribute('stroke-width') || '2');
              svg.style.width = svg.style.width || '22px';
              svg.style.height = svg.style.height || '22px';
            } catch (e) {}
          }
        }

        // hide the existing left/right bottom buttons with animation
        try {
          const addBtn = document.querySelector('.btn-plus');
          const homeBtn = document.querySelector('.btn-plus, .btn-half.btn-plus');
          const statsBtn = document.querySelector('.btn-stats');
          const leftBtn = document.getElementById('addBtn') || homeBtn;
          if (leftBtn) gsap.to(leftBtn, { opacity: 0, duration: 0.28, ease: 'power1.out', pointerEvents: 'none' });
          if (statsBtn) gsap.to(statsBtn, { opacity: 0, duration: 0.28, ease: 'power1.out', pointerEvents: 'none' });
        } catch (e) {}

        // attach handler to bottomMin
        if (bottomMin && !bottomMin.dataset.handler) {
          bottomMin.dataset.handler = '1';
          bottomMin.addEventListener('click', (e) => {
            e.stopPropagation(); e.preventDefault && e.preventDefault();

            // restore other cards
            allCards.forEach(c => {
              if (c !== cardEl) {
                gsap.to(c, { opacity: 1, duration: 0.28, ease: 'power1.out', pointerEvents: 'auto' });
              }
            });

            // hide expand area
            if (expandArea) expandArea.style.display = 'none';

            cardEl.classList.remove('expanded');

            // Before collapsing: remove placeholder/empty subtasks so they are not saved
            try {
              const subRows = Array.from(cardEl.querySelectorAll('.subtask'));
              subRows.forEach(r => {
                const ti = r.querySelector('.subtask-title');
                const titleText = (ti ? (ti.value || ti.textContent || ti.placeholder || '') : '').trim();
                if (!titleText || titleText.toLowerCase().includes('unteraufgabe')) {
                  r.parentNode && r.parentNode.removeChild(r);
                }
              });
              // update datasets and persist cleaned subtasks
              try { recalcFromSubtasks(); } catch(e) {}
              try { saveHabit(cardEl); } catch(e) {}
            } catch (e) {}

            // animate back to original computed height and position
            gsap.to(cardEl, {
              y: 0,
              height: cardRect.height,
              duration: 0.45,
              ease: 'power2.inOut',
              onComplete: () => {
                try { cardEl.style.removeProperty('height'); if (cardEl.dataset.origInlineTransform) cardEl.style.transform = cardEl.dataset.origInlineTransform; else cardEl.style.removeProperty('transform'); if (cardEl.dataset.origInlineZ) cardEl.style.zIndex = cardEl.dataset.origInlineZ; else cardEl.style.removeProperty('z-index'); } catch(e){}

                // remove the bottom minimize button and restore bottom bar buttons
                try {
                  const statsBtn = document.querySelector('.btn-stats');
                  const leftBtn = document.getElementById('addBtn');
                  const bottom = document.querySelector('.minimize-bottom-btn');
                  if (bottom && bottom.parentNode) bottom.parentNode.removeChild(bottom);
                  if (leftBtn) gsap.to(leftBtn, { opacity: 1, duration: 0.28, ease: 'power1.out', pointerEvents: 'auto' });
                  if (statsBtn) gsap.to(statsBtn, { opacity: 1, duration: 0.28, ease: 'power1.out', pointerEvents: 'auto' });
                } catch(e){}
              }
            });
          });
        }

        // animate expansion (translateY + height)
        gsap.to(cardEl, { y: deltaY, height: targetHeight, duration: 0.45, ease: 'power2.out' });
      }

      // ======================================
      // CARD CLICK: Expand card according to position rules
      // ======================================
      card.addEventListener("click", async (e) => {
        // Ignore clicks coming from expanded subtask area or from subtask controls
        if (e.target.closest(".expand-area") || e.target.closest('.subtask') || e.target.closest('.subtasks') || e.target.closest('.add-subtask')) {
          return;
        }

        // If QR-Mode, do not toggle or expand
        if (card.dataset.qr === "true") return;

        // If there are no subtasks present, perform the original toggle behaviour
        const hasSubtasks = card.querySelectorAll('.subtask').length > 0;
        if (!hasSubtasks) {
          // GPS Check (if habit requires an address)
          const requiredAddress = card.dataset.location;
          if (requiredAddress && requiredAddress.length > 0) {
            e.stopPropagation();
            navigator.geolocation.getCurrentPosition(async (pos) => {
              const userLat = pos.coords.latitude;
              const userLon = pos.coords.longitude;

              const geo = await geocodeAddress(requiredAddress);
              if (!geo) { shake(card); return; }

              const dist = haversine(userLat, userLon, geo.lat, geo.lon);

              if (dist > 100) { shake(card); return; }

              // OK ‚Üí Toggle
              proceedHabitToggle(card);

            }, () => shake(card));

            return;
          }

          // Normal toggle when no subtasks
          proceedHabitToggle(card);
          return;
        }

        // Otherwise (has subtasks) expand the card
        expandCard(card);
      });

      // ======================================
      // DOUBLE TAP ‚Üí Progress Reset (f√ºr ALLE Habit-Typen)
      // ======================================
      let lastTap = 0;
      card.addEventListener("touchend", async (e) => {
        // PATCH 3: Ignore touches inside expanded subtask area or subtask controls
        if (e.target.closest(".expand-area") || e.target.closest('.subtask') || e.target.closest('.subtasks') || e.target.closest('.add-subtask')) {
          return;
        }
        const now = Date.now();
        if (now - lastTap < 300) {
          // Double Tap erkannt
          const habitId = card.dataset.habitId;

          // DB Reset
          const { error } = await supabaseClient
            .from("habits")
            .update({ progress: 0 })
            .eq("id", habitId);

          if (error) {
            console.error("doubleTap reset error:", error);
            return;
          }

          // Lokales Update
          card.dataset.progress = 0;
          card.dataset.active = "false";

          const input = card.querySelector(".card-input");
          card.style.background = "#e4e4e4";
          input.style.color = "#666";

          const counter = card.querySelector(".counter");
          const goal    = parseInt(card.dataset.goal) || 1;
          const isQR    = card.dataset.qr === "true";

          if (isQR) {
            // QR Habit ‚Üí 0 KCAL
            counter.style.display = "block";
            counter.textContent = "0 KCAL";
          } else {
            // Normale Habits
            if (goal >= 2) {
              counter.style.display = "block";
              counter.textContent = "0/" + goal;
            } else {
              counter.style.display = "none";
            }
          }

          syncHabitDayForProgress(habitId, 0);
        }
        lastTap = now;
      });
    }


    
    async function proceedHabitToggle(card) {
      const input   = card.querySelector(".card-input");
      const counter = card.querySelector(".counter");
      const flipBtn = card.querySelector(".card-flip-btn");

      if (!input.textContent.trim()) return;

      // If subtasks exist, they must all be completed first
      const hasSubtasks = card.querySelectorAll(".subtask").length > 0;
      const subtasksComplete = card.dataset.subtasksComplete === "true";

      if (hasSubtasks && !subtasksComplete) {
        shake(card);
        return;
      }

      enforceSpeisequarkGoal(card, input.textContent);

      let goal     = parseInt(card.dataset.goal) || 0;
      let progress = parseInt(card.dataset.progress) || 0;
      let active   = card.dataset.active === "true";
      const idx    = parseInt(card.dataset.index);

      if (goal <= 1) {
        if (active) {
          active   = false;
          progress = 0;
          card.style.background = "#e4e4e4";
          card.dataset.color    = "#e4e4e4";
          input.style.color     = "#666";
        } else {
          active   = true;
          progress = 1;

          let col = card.dataset.color;
          if (!col || col === "#e4e4e4") col = cycleColors[idx % cycleColors.length];

          card.style.background = col;
          card.dataset.color    = col;
          input.style.color     = darken(col);
        }
      } else {
        if (progress < goal) {
          progress += 1;
          active = true;

          let col = card.dataset.color;
          if (!col || col === "#e4e4e4") col = cycleColors[idx % cycleColors.length];

          card.style.background = col;
          card.dataset.color    = col;
          input.style.color     = darken(col);
        } else {
          return;
        }
      }
      if (flipBtn) flipBtn.style.color = input.style.color || "#666";

      card.dataset.progress = progress;
      card.dataset.active   = active ? "true" : "false";

      // Ensure subtitle/subtask colors follow the title color immediately
      try {
        const titleColor = input.style.color || darken(card.dataset.color || '#e4e4e4');
        card.querySelectorAll('.subtask-title').forEach(el => { el.style.color = titleColor; });
        card.querySelectorAll('.subtask i').forEach(icon => { icon.style.color = titleColor; });
        const divider = card.querySelector('.expand-divider'); if (divider) divider.style.background = titleColor;
        if (flipBtn) flipBtn.style.color = titleColor;
      } catch (e) { /* ignore if elements missing */ }

      if (goal >= 2) {
        counter.style.display = "block";
        counter.textContent   = progress + "/" + goal;
      } else {
        counter.style.display = "none";
      }

      // Reset subtasks after successful completion
      const rows = card.querySelectorAll(".subtask");
      if (rows.length > 0) {
        rows.forEach(r => {
          r.dataset.done = "false";
          const icon = r.querySelector("i");
          if (icon) icon.setAttribute("data-lucide", "circle");
        });
        card.dataset.subtasksComplete = "false";
        lucide.createIcons();
      }

      await saveHabit(card);
      syncHabitDayForProgress(card.dataset.habitId, progress);
    }
    
    async function geocodeAddress(addr) {
      const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(addr)}`;
      const resp = await fetch(url);
      const json = await resp.json();

      if (!json || json.length === 0) return null;

      return {
        lat: parseFloat(json[0].lat),
        lon: parseFloat(json[0].lon)
      };
    }
    
    function haversine(lat1, lon1, lat2, lon2) {
      function toRad(x) { return x * Math.PI / 180; }

      const R = 6371000; // Meter
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);

      const a =
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
        Math.sin(dLon/2) * Math.sin(dLon/2);

      return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }

    async function saveHabit(card) {
      if (!currentUser) return;

      const habitId = card.dataset.habitId;
      const input   = card.querySelector(".card-input");
      const title = input.textContent.trim();
      const color   = card.dataset.color || "#e4e4e4";
      let progress  = parseInt(card.dataset.progress) || 0;
      let goal     = parseInt(card.dataset.goal)     || 0;

      if (!habitId) return;

      if (enforceSpeisequarkGoal(card, title)) {
        progress = parseInt(card.dataset.progress) || 0;
        goal = parseInt(card.dataset.goal) || 0;
      }

      // collect up to 3 subtasks from the DOM
      const rows = card.querySelectorAll('.subtask');
      const updates = {
        title, color, progress, goal
      };

      // initialize sub fields to defaults
      updates.sub1_title = '';
      updates.sub1_progress = 0;
      updates.sub2_title = '';
      updates.sub2_progress = 0;
      updates.sub3_title = '';
      updates.sub3_progress = 0;

      Array.from(rows).slice(0,3).forEach((r, i) => {
        const ti = r.querySelector('.subtask-title');
        const titleText = ti ? ti.value || ti.textContent || ti.placeholder || '' : '';
        const done = r.dataset.done === 'true' ? 1 : 0;
        const idx = i + 1;
        updates[`sub${idx}_title`] = titleText;
        updates[`sub${idx}_progress`] = done;
      });

      const { error } = await supabaseClient
        .from("habits")
        .update(updates)
        .eq("id", habitId);

      if (error) console.error("saveHabit error:", error);
      invalidateHabitsCache(currentUser?.id);
    }

    // Add-Button: erstellt nur DB-Datensatz, niemals lokal
    addBtnEl.addEventListener("click", async () => {
      if (addBtnEl.dataset.mode === "stats") {
        addBtnEl.dataset.mode = "main";
        statsOpen = false;
        gsap.to("#statsView",{top:"100svh",duration:0.42,ease:"power1.in"});
        refreshAddButtonIcon();
        return;
      }

      if (habits.length >= 3) return;

      if (!currentUser) {
        const { data } = await supabaseClient.auth.getUser();
        currentUser = data.user;
        if (!currentUser) return;
      }

      const { data, error } = await supabaseClient
        .from("habits")
        .insert({
          user_id: currentUser.id,
          title: "",
          color: "#e4e4e4",
          progress: 0,
          goal: 1,
          appear_once: false,
          icon_type: "brain"
        })
        .select()
        .single();

      if (error) {
        console.error("insert habit error:", error);
        return;
      }

      habits.push(data);
      const index = habits.length - 1;
      createCardFromHabit(data, index, 0);
      refreshAddButtonIcon();
    });

  async function loadOtherUser() {
    if (!currentUser) return null;

    const { data, error } = await supabaseClient
      .from("users_public")
      .select("id, display_name, avatar_url")
      .neq("id", currentUser.id)
      .limit(1);

    if (error) {
      console.error("loadOtherUser error:", error);
      return null;
    }

    return data && data.length > 0 ? data[0] : null;
  }

  function getCached(map, key, ttl) {
    const entry = map.get(key);
    if (!entry) return null;
    if ((Date.now() - entry.ts) > ttl) return null;
    return entry.data;
  }

  function setCached(map, key, data) {
    map.set(key, { ts: Date.now(), data });
  }

  function invalidateHabitsCache(userId) {
    if (!userId) return;
    dataCache.habits.delete(userId);
  }

  async function loadOtherUserCached() {
    if (!currentUser) return null;
    const cached = dataCache.otherUser.value;
    if (cached && (Date.now() - dataCache.otherUser.ts) <= CACHE_TTL.otherUser) {
      return cached;
    }
    const fresh = await loadOtherUser();
    dataCache.otherUser = { value: fresh, ts: Date.now() };
    return fresh;
  }

  async function loadHabitsForUser(userId) {
    const { data, error } = await supabaseClient
      .from("habits")
      .select(`id, user_id, title, color, progress, goal, icon_type, location_address, qr_enabled, sub1_title, sub1_progress, sub2_title, sub2_progress, sub3_title, sub3_progress, inserted_at`)
      .eq("user_id", userId)
      .order("inserted_at", { ascending: true })
      .limit(3);

    if (error) {
      console.error("loadHabitsForUser error:", error);
      return [];
    }
    return data || [];
  }

  async function loadHabitsForUserCached(userId) {
    const cached = getCached(dataCache.habits, userId, CACHE_TTL.habits);
    if (cached) return cached;
    const fresh = await loadHabitsForUser(userId);
    setCached(dataCache.habits, userId, fresh);
    return fresh;
  }
  
  let statsCalendarOffset = 0;
  let statsCalendarData = {};
  let statsCalendarHabits = {
    myHabits: [],
    otherHabits: [],
    otherUserId: null
  };
  let iconPickerTimer = null;

  async function checkForAppUpdate() {
    try {
      if (!window.location || window.location.protocol === "file:") return;
      const { data, error } = await supabaseClient
        .from("version")
        .select("version_number")
        .order("version_number", { ascending: false })
        .limit(1)
        .maybeSingle();

      if (error || !data) return;

      const latest = parseFloat(data.version_number);
      if (!Number.isFinite(latest)) return;
      if (latest <= APP_VERSION) return;

      const url = new URL(window.location.href);
      const paramVer = parseFloat(url.searchParams.get("v"));
      if (Number.isFinite(paramVer) && paramVer === latest) return;

      if ("serviceWorker" in navigator) {
        const reg = await navigator.serviceWorker.getRegistration();
        if (reg) await reg.update();
      }

      localStorage.setItem("update_notice_version", String(latest));
      url.searchParams.set("v", String(latest));
      window.location.replace(url.toString());
    } catch (e) {
      console.error("checkForAppUpdate error:", e);
    }
  }

  function getLocalDateString(dateObj = new Date()) {
    const tzOffset = dateObj.getTimezoneOffset() * 60000;
    return new Date(dateObj - tzOffset).toISOString().slice(0, 10);
  }

  function getWeekdayName(dateObj = new Date()) {
    const days = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
    return days[dateObj.getDay()];
  }

  function getWeekRange(dateObj = new Date()) {
    const date = new Date(dateObj);
    const day = date.getDay();
    const diffToMonday = (day + 6) % 7;
    date.setDate(date.getDate() - diffToMonday);
    date.setHours(0, 0, 0, 0);
    const start = new Date(date);
    const end = new Date(date);
    end.setDate(end.getDate() + 7);
    return { start, end };
  }

  async function performStreakResetForUser(uid) {
    const habits = await loadHabitsForUser(uid);

    const allFull =
      habits.length === 3 &&
      habits.every(h => {
        if (h.qr_enabled === true || h.qr_enabled === "true") return false;
        const goal = h.goal || 0;
        return goal > 0 && h.progress >= goal;
      });

    const { data: streakRow, error: readErr } = await supabaseClient
      .from("streak_view")
      .select("current_streak, longest_streak")
      .eq("user_id", uid)
      .single();

    if (readErr) {
      console.error("streak read error", readErr);
      return;
    }

    const current = streakRow?.current_streak ?? 0;
    const longest = streakRow?.longest_streak ?? 0;

    const nextCurrent = allFull ? current + 1 : 0;
    const nextLongest = Math.max(longest, nextCurrent);

    await supabaseClient
      .from("streak_view")
      .upsert(
        {
          user_id: uid,
          current_streak: nextCurrent,
          longest_streak: nextLongest,
          last_update: new Date().toISOString()
        },
        { onConflict: "user_id" }
      );

    await supabaseClient.rpc(
      "reset_progress_for_users",
      { uids: [uid] }
    );
  }

  async function checkStreakResetGate() {
    const { start, end } = getWeekRange();
    const startStr = getLocalDateString(start);
    const endStr = getLocalDateString(end);

    const { error } = await supabaseClient.rpc("check_streak_reset_weekly", {
      start_date: startStr,
      end_date: endStr
    });

    if (error) {
      console.error("checkStreakResetGate rpc error:", error);
    }
  }

  async function checkReminderResetDaily() {
    const day = getLocalDateString();
    const { error } = await supabaseClient.rpc("check_reminder_reset_daily", {
      current_day: day
    });

    if (error) {
      console.error("checkReminderResetDaily rpc error:", error);
    }
  }

  async function loadReminderClicksForDay(uid) {
    if (!uid) return;
    const day = getLocalDateString();
    const { data, error } = await supabaseClient
      .from("reminder_clicks")
      .select("position_id")
      .eq("user_id", uid)
      .eq("day", day);

    if (error) {
      console.error("loadReminderClicksForDay error:", error);
      return;
    }

    reminderChecklistState.clear();
    (data || []).forEach(row => {
      if (row?.position_id) reminderChecklistState.add(row.position_id);
    });
  }

  async function loadReminderClickCountForDay(uid) {
    if (!uid) return 0;
    const day = getLocalDateString();
    const { count, error } = await supabaseClient
      .from("reminder_clicks")
      .select("position_id", { count: "exact", head: true })
      .eq("user_id", uid)
      .eq("day", day);

    if (error) {
      console.error("loadReminderClickCountForDay error:", error);
      return 0;
    }

    return count || 0;
  }

  async function buildReliabilityChartHtml(myHabits, otherHabits, otherName = "Freund:in") {
    const monthInfo = getStatsMonthInfo();
    const today = new Date();
    const isCurrentMonth = (
      today.getFullYear() === monthInfo.year &&
      today.getMonth() === monthInfo.month
    );
    const visibleDays = isCurrentMonth
      ? Math.max(1, Math.min(today.getDate(), monthInfo.daysInMonth))
      : monthInfo.daysInMonth;
    const xDenominator = Math.max(1, visibleDays - 1);

    const myTop3 = [0, 1, 2].map(i => myHabits?.[i] || null);
    const otherTop3 = [0, 1, 2].map(i => otherHabits?.[i] || null);
    const allHabits = [...myTop3, ...otherTop3].filter(Boolean);
    const ids = allHabits.map(h => h.id).filter(Boolean);
    const monthDaysMap = await loadHabitDaysForMonth(ids);

    const seriesMeta = [];
    const groups = [
      { ownerLabel: "Du", items: myTop3 },
      { ownerLabel: otherName || "Freund:in", items: otherTop3 }
    ];
    groups.forEach(group => {
      group.items.forEach((habit, idx) => {
        const rawTitle = habit?.title?.trim();
        const title = rawTitle ? rawTitle : `Habit ${idx + 1}`;
        seriesMeta.push({
          label: `${group.ownerLabel}: ${title}`,
          color: habit?.color || "#9ca3af",
          days: habit?.id ? (monthDaysMap[habit.id] || new Set()) : new Set()
        });
      });
    });

    const svgW = 640;
    const svgH = 250;
    const padL = 24;
    const padR = 10;
    const padT = 12;
    const padB = 20;
    const innerW = svgW - padL - padR;
    const innerH = svgH - padT - padB;

    function toX(day) {
      return padL + ((day - 1) / xDenominator) * innerW;
    }

    function toY(valuePct) {
      return padT + ((100 - valuePct) / 100) * innerH;
    }

    function pathFromPoints(points) {
      if (!points.length) return "";
      if (points.length === 1) return `M ${points[0].x.toFixed(2)} ${points[0].y.toFixed(2)}`;
      let d = `M ${points[0].x.toFixed(2)} ${points[0].y.toFixed(2)}`;
      for (let i = 1; i < points.length; i++) {
        const p0 = points[i - 1];
        const p1 = points[i];
        const cp1x = p0.x + (p1.x - p0.x) / 3;
        const cp1y = p0.y;
        const cp2x = p0.x + ((p1.x - p0.x) * 2) / 3;
        const cp2y = p1.y;
        d += ` C ${cp1x.toFixed(2)} ${cp1y.toFixed(2)} ${cp2x.toFixed(2)} ${cp2y.toFixed(2)} ${p1.x.toFixed(2)} ${p1.y.toFixed(2)}`;
      }
      return d;
    }

    const gridYValues = [0, 50, 100];
    const gridHtml = gridYValues
      .map(v => {
        const y = toY(v).toFixed(2);
        return `<line class="reliability-grid" x1="${padL}" y1="${y}" x2="${svgW - padR}" y2="${y}"></line>`;
      })
      .join("");

    const habitLineHtml = seriesMeta
      .map(series => {
        const points = [];
        for (let day = 1; day <= visibleDays; day++) {
          const val = series.days.has(day) ? 100 : 0;
          points.push({ x: toX(day), y: toY(val) });
        }
        const d = pathFromPoints(points);
        return `<path class="reliability-line reliability-line-secondary" d="${d}" style="stroke:${series.color};"></path>`;
      })
      .join("");

    const mySeries = seriesMeta.slice(0, 3);
    const otherSeries = seriesMeta.slice(3, 6);

    function buildAveragePoints(seriesList) {
      const points = [];
      for (let day = 1; day <= visibleDays; day++) {
        let doneCount = 0;
        seriesList.forEach(series => {
          if (series.days.has(day)) doneCount += 1;
        });
        const pct = (doneCount / 3) * 100;
        points.push({ x: toX(day), y: toY(pct) });
      }
      return points;
    }

    const myAveragePoints = buildAveragePoints(mySeries);
    const otherAveragePoints = buildAveragePoints(otherSeries);
    const myAveragePath = pathFromPoints(myAveragePoints);
    const otherAveragePath = pathFromPoints(otherAveragePoints);

    const myColor = mySeries[0]?.color || "#3b82f6";
    const otherColor = otherSeries[0]?.color || "#ef4444";
    const primaryLineHtml = `
      <path class="reliability-line reliability-line-primary" d="${myAveragePath}" style="stroke:${myColor};"></path>
      <path class="reliability-line reliability-line-primary" d="${otherAveragePath}" style="stroke:${otherColor};"></path>
    `;

    function averagePercent(seriesList) {
      let done = 0;
      seriesList.forEach(series => {
        for (let day = 1; day <= visibleDays; day++) {
          if (series.days.has(day)) done += 1;
        }
      });
      const max = Math.max(1, visibleDays * 3);
      return Math.round((done / max) * 100);
    }

    const myAvgPct = averagePercent(mySeries);
    const otherAvgPct = averagePercent(otherSeries);
    const delta = myAvgPct - otherAvgPct;
    const centerText = delta === 0
      ? "gleichauf"
      : delta > 0
        ? `+${delta} vorne`
        : `${delta} hinten`;

    const axisLabelHtml = `
      <text class="reliability-axis-label" x="${padL}" y="${(svgH - 2)}">Tag 1</text>
      <text class="reliability-axis-label" x="${(padL + innerW / 2)}" y="${(svgH - 2)}" text-anchor="middle">Monatsmitte</text>
      <text class="reliability-axis-label" x="${(svgW - padR)}" y="${(svgH - 2)}" text-anchor="end">Tag ${visibleDays}</text>
      <text class="reliability-axis-label" x="${padL - 6}" y="${toY(100)}" text-anchor="end" dominant-baseline="middle">100%</text>
      <text class="reliability-axis-label" x="${padL - 6}" y="${toY(50)}" text-anchor="end" dominant-baseline="middle">50%</text>
      <text class="reliability-axis-label" x="${padL - 6}" y="${toY(0)}" text-anchor="end" dominant-baseline="middle">0%</text>
    `;

    const legendHtml = seriesMeta
      .map(series => `
        <div class="reliability-legend-item">
          <span class="reliability-legend-dot" style="background:${series.color};"></span>
          <span class="reliability-legend-label">${escapeHtml(series.label)}</span>
        </div>
      `)
      .join("");

    return `
      <div class="reliability-chart">
        <div class="reliability-summary">
          <div class="reliability-summary-left">Du: ${myAvgPct}%</div>
          <div class="reliability-summary-center">${centerText}</div>
          <div class="reliability-summary-right">${escapeHtml(otherName)}: ${otherAvgPct}%</div>
        </div>
        <svg class="reliability-chart-svg" viewBox="0 0 ${svgW} ${svgH}" preserveAspectRatio="none" role="img" aria-label="Verl√§sslichkeit im Monatsverlauf">
          ${gridHtml}
          ${habitLineHtml}
          ${primaryLineHtml}
          ${axisLabelHtml}
        </svg>
        <div class="reliability-legend">${legendHtml}</div>
        <div class="reliability-help">
          <div class="reliability-help-row">Dicke Linien: durchschnittliche t√§gliche Verl√§sslichkeit je User (√ºber 3 Habits).</div>
          <div class="reliability-help-row">D√ºnne Linien: einzelne Habit-Verl√§ufe (pro Tag 0% = nicht erledigt, 100% = erledigt).</div>
          <div class="reliability-help-row">Oben: Monatsdurchschnitt in % und dein Abstand zum anderen User.</div>
          <div class="reliability-help-row">X-Achse: Tage im Monat, Y-Achse: Verl√§sslichkeit von 0% bis 100%.</div>
        </div>
      </div>
    `;
  }

  async function syncHabitDayForProgress(habitId, progress) {
    if (!habitId) return;
    const day = getLocalDateString();
    const weekday = getWeekdayName();

    if (progress > 0) {
      const { error } = await supabaseClient
        .from("habit_days")
        .upsert(
          { id: crypto.randomUUID(), habit_id: habitId, date: day, day, weekday, done: true },
          { onConflict: "habit_id,date", ignoreDuplicates: true }
        );
      if (error) console.error("habit_days upsert error:", error);
      return;
    }

    const { error } = await supabaseClient
      .from("habit_days")
      .delete()
      .eq("habit_id", habitId)
      .eq("date", day);

    if (error) console.error("habit_days delete error:", error);
  }

  function getGermanMonthName(dateObj) {
    const months = [
      "Januar", "Februar", "M√§rz", "April", "Mai", "Juni",
      "Juli", "August", "September", "Oktober", "November", "Dezember"
    ];
    return months[dateObj.getMonth()];
  }

  function getMonthRange(dateObj = new Date()) {
    const year = dateObj.getFullYear();
    const month = dateObj.getMonth();
    return {
      start: new Date(year, month, 1),
      end: new Date(year, month + 1, 1)
    };
  }

  function getStatsMonthInfo() {
    const base = new Date();
    const target = new Date(base.getFullYear(), base.getMonth() + statsCalendarOffset, 1);
    const year = target.getFullYear();
    const month = target.getMonth();
    const start = new Date(year, month, 1);
    const end = new Date(year, month + 1, 1);
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    return {
      target,
      year,
      month,
      monthName: getGermanMonthName(target),
      start,
      end,
      daysInMonth
    };
  }

  function parseDayNumber(dateStr) {
    if (!dateStr) return null;
    const parts = String(dateStr).split("-");
    if (parts.length < 3) return null;
    return parseInt(parts[2], 10);
  }

  async function loadHabitDaysForMonth(habitIds) {
    if (!habitIds || habitIds.length === 0) return {};
    const info = getStatsMonthInfo();
    const startStr = getLocalDateString(info.start);
    const endStr = getLocalDateString(info.end);

    const { data, error } = await supabaseClient
      .from("habit_days")
      .select("habit_id, date")
      .in("habit_id", habitIds)
      .gte("date", startStr)
      .lt("date", endStr);

    if (error) {
      console.error("loadHabitDaysForMonth error:", error);
      return {};
    }

    const map = {};
    (data || []).forEach(row => {
      const habitId = row.habit_id;
      const dayNum = parseDayNumber(row.date);
      if (!habitId || !dayNum) return;
      if (!map[habitId]) map[habitId] = new Set();
      map[habitId].add(dayNum);
    });
    return map;
  }

  async function loadHabitDayCountsForMonth(habitIds, dateObj = new Date()) {
    if (!habitIds || habitIds.length === 0) return {};
    const range = getMonthRange(dateObj);
    const startStr = getLocalDateString(range.start);
    const endStr = getLocalDateString(range.end);

    const { data, error } = await supabaseClient
      .from("habit_days")
      .select("habit_id")
      .in("habit_id", habitIds)
      .gte("date", startStr)
      .lt("date", endStr);

    if (error) {
      console.error("loadHabitDayCountsForMonth error:", error);
      return {};
    }

    const counts = {};
    (data || []).forEach(row => {
      const habitId = row.habit_id;
      if (!habitId) return;
      counts[habitId] = (counts[habitId] || 0) + 1;
    });
    return counts;
  }



  async function refreshStatsCalendarData() {
    const myIds = (statsCalendarHabits.myHabits || []).map(h => h.id).filter(Boolean);
    const otherIds = (statsCalendarHabits.otherHabits || []).map(h => h.id).filter(Boolean);
    const [myMap, otherMap] = await Promise.all([
      loadHabitDaysForMonth(myIds),
      loadHabitDaysForMonth(otherIds)
    ]);
    statsCalendarData = { ...myMap, ...otherMap };
    renderStatCalendars();
  }

  function renderStatCalendars() {
    const info = getStatsMonthInfo();
    const monthName = info.monthName;
    const year = info.year;
    const daysInMonth = info.daysInMonth;
    const calendars = statsViewEl.querySelectorAll(".stat-calendar");
    calendars.forEach(cal => {
      const habitId = cal.dataset.habitId;
      const color = cal.dataset.color || "#e5e7eb";
      const days = habitId ? statsCalendarData[habitId] : null;
      const headerEl = cal.querySelector(".stat-calendar-header");
      const gridEl = cal.querySelector(".stat-calendar-grid");

      if (headerEl) headerEl.textContent = `${monthName} ${year}`;
      if (gridEl) {
        const daySet = days instanceof Set ? days : new Set();
        let html = "";
        for (let d = 1; d <= daysInMonth; d++) {
          const isActive = daySet.has(d);
          const bg = isActive ? color : "var(--c-card)";
          const cls = isActive ? "stat-day" : "stat-day inactive";
          html += `<div class="${cls}" style="background:${bg};">${d}</div>`;
        }
        gridEl.innerHTML = html;
      }
    });
  }

  function setupStatCalendarInteractions() {
    const bars = statsViewEl.querySelectorAll(".stat-bar.is-clickable");
    bars.forEach(bar => {
      bar.addEventListener("click", (e) => {
        if (e && (e.target.closest(".stat-icon-btn") || e.target.closest(".stat-icon-options"))) {
          return;
        }
        closeAllStatIconPickers();
        const parent = bar.closest(".stat-item");
        const calendar = parent ? parent.querySelector(".stat-calendar") : null;
        if (!calendar) return;

        const isOpen = calendar.classList.contains("is-open");
        statsViewEl.querySelectorAll(".stat-calendar.is-open").forEach(openCal => {
          openCal.classList.remove("is-open");
        });
        if (!isOpen) calendar.classList.add("is-open");
      });
    });

    const navButtons = statsViewEl.querySelectorAll(".stat-cal-nav");
    navButtons.forEach(btn => {
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        const dir = parseInt(btn.dataset.dir, 10) || 0;
        statsCalendarOffset += dir;
        refreshStatsCalendarData();
      });
    });
  }

  function closeAllStatIconPickers(exceptBar = null) {
    if (!statsViewEl) return;
    const openBars = statsViewEl.querySelectorAll(".stat-bar.is-icon-open");
    openBars.forEach(bar => {
      if (exceptBar && bar === exceptBar) return;
      bar.classList.remove("is-icon-open");
      const opts = bar.querySelector(".stat-icon-options");
      if (opts) opts.setAttribute("aria-hidden", "true");
    });
    if (!exceptBar && iconPickerTimer) {
      clearTimeout(iconPickerTimer);
      iconPickerTimer = null;
    }
  }

  function applyIconToStatBar(bar, iconType) {
    const safeIcon = normalizeHabitIcon(iconType);
    bar.dataset.icon = safeIcon;
    const btn = bar.querySelector(".stat-icon-btn");
    if (btn) btn.innerHTML = `<i data-lucide="${safeIcon}"></i>`;
    const options = bar.querySelector(".stat-icon-options");
    if (options) {
      const optionsHtml = HABIT_ICON_TYPES.filter(type => type !== safeIcon)
        .map(type => `
          <button class="stat-icon-option" type="button" data-icon="${type}" aria-label="${type}">
            <i data-lucide="${type}"></i>
          </button>
        `)
        .join("");
      options.innerHTML = optionsHtml;
      options.setAttribute("aria-hidden", "true");
    }
    bar.classList.remove("is-icon-open");
    lucide.createIcons({ scope: bar });
  }

  function updateLocalHabitIcon(habitId, iconType) {
    if (!habitId) return;
    const safeIcon = normalizeHabitIcon(iconType);
    habits = habits.map(h => (String(h.id) === String(habitId) ? { ...h, icon_type: safeIcon } : h));
    if (statsCalendarHabits?.myHabits) {
      statsCalendarHabits.myHabits = statsCalendarHabits.myHabits.map(h =>
        (String(h.id) === String(habitId) ? { ...h, icon_type: safeIcon } : h)
      );
    }
  }

  async function updateHabitIconType(habitId, iconType) {
    if (!habitId || !currentUser) return;
    const safeIcon = normalizeHabitIcon(iconType);
    const { error } = await supabaseClient
      .from("habits")
      .update({ icon_type: safeIcon })
      .eq("id", habitId);
    if (error) console.error("update icon_type error:", error);
  }

  function setupStatIconPickers() {
    if (!statsViewEl) return;
    const bars = statsViewEl.querySelectorAll(".stat-bar[data-owner='my']");
    bars.forEach(bar => {
      const btn = bar.querySelector(".stat-icon-btn");
      const options = bar.querySelector(".stat-icon-options");
      if (!btn || !options) return;
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        const isOpen = bar.classList.contains("is-icon-open");
        closeAllStatIconPickers(bar);
        if (isOpen) {
          bar.classList.remove("is-icon-open");
          options.setAttribute("aria-hidden", "true");
          if (iconPickerTimer) {
            clearTimeout(iconPickerTimer);
            iconPickerTimer = null;
          }
        } else {
          bar.classList.add("is-icon-open");
          options.setAttribute("aria-hidden", "false");
          if (iconPickerTimer) clearTimeout(iconPickerTimer);
          iconPickerTimer = setTimeout(() => {
            closeAllStatIconPickers();
          }, 5000);
        }
      });
    });

    if (statsViewEl.dataset.iconPickerBound === "true") return;
    statsViewEl.dataset.iconPickerBound = "true";

    statsViewEl.addEventListener("click", async (e) => {
      const option = e.target.closest(".stat-icon-option");
      if (!option) return;
      const bar = option.closest(".stat-bar");
      if (!bar || bar.dataset.owner !== "my") return;
      e.stopPropagation();
      if (iconPickerTimer) {
        clearTimeout(iconPickerTimer);
        iconPickerTimer = null;
      }
      const iconType = normalizeHabitIcon(option.dataset.icon);
      applyIconToStatBar(bar, iconType);
      updateLocalHabitIcon(bar.dataset.habitId, iconType);
      await updateHabitIconType(bar.dataset.habitId, iconType);
    });

    statsViewEl.addEventListener("click", (e) => {
      if (e.target.closest(".stat-icon-btn") || e.target.closest(".stat-icon-options")) return;
      closeAllStatIconPickers();
    });
  }



  function barsHtml(habits, keyPrefix) {
    let html = "";
    for (let i = 0; i < 3; i++) {
      const h = habits[i];

      if (!h) {
        html += `
          <div class="stat-item">
            <div class="stat-bar" style="position:relative;">
              <div class="stat-bar-inner">
                <button class="stat-icon-btn" type="button" style="cursor:default; pointer-events:none;">
                  <i data-lucide="brain"></i>
                </button>
                <div class="stat-icon-options" aria-hidden="true"></div>
                <div class="stat-bar-track">
                  <div class="stat-progress" data-progress="0" style="
                    position:absolute;
                    inset:0;
                    width:0%;
                    background:#e5e7eb;
                    border-radius:12px;
                    z-index:1;
                  "></div>
                  <div class="stat-bar-label"></div>
                </div>
              </div>
            </div>
          </div>`;
        continue;
      }

      const x = h.progress || 0;
      const y = h.goal     || 0;
      const rawTitle = h.title || "";
      const hasTitle = rawTitle.trim().length > 0;
      const color = h.color || "#e5e7eb";
      const iconType = normalizeHabitIcon(h.icon_type);
      const iconOptions = HABIT_ICON_TYPES.filter(type => type !== iconType)
        .map(type => `
          <button class="stat-icon-option" type="button" data-icon="${type}" aria-label="${type}">
            <i data-lucide="${type}"></i>
          </button>
        `)
        .join("");

      let percent = 0;

      // QR habit: max value = 21000 kcal
      if (h.qr_enabled === true || h.qr_enabled === "true") {
        const maxKcal = 21000;
        const kcal = parseInt(h.progress) || 0;
        percent = Math.min(100, Math.round((kcal / maxKcal) * 100));
      }
      else {
        if (y > 0) {
          percent = (y === 1)
            ? (x >= 1 ? 100 : 0)
            : Math.round((x / y) * 100);
        }
      }

      html += `
        <div class="stat-item">
        <div class="stat-bar is-clickable" data-habit-id="${h.id}" data-color="${color}" data-owner="${keyPrefix}" data-icon="${iconType}" style="position:relative;">
          <div class="stat-bar-inner">
            <button class="stat-icon-btn" type="button" aria-label="Symbol w√§hlen">
              <i data-lucide="${iconType}"></i>
            </button>
            <div class="stat-icon-options" aria-hidden="true">
              ${iconOptions}
            </div>
            <div class="stat-bar-track">
              <!-- Fortschrittsbalken -->
              <div class="stat-progress" data-progress="${percent}" style="
                position:absolute;
                inset:0;
                width:0%;
                background:${color};
                border-radius:12px;
                z-index:1;
              "></div>
              <!-- Text nur wenn vorhanden -->
              <div class="stat-bar-label">
                ${hasTitle ? rawTitle : ""}
              </div>
            </div>
          </div>
        </div>
        <div class="stat-calendar" data-habit-id="${h.id}" data-color="${color}">
          <div class="stat-calendar-header-row">
            <button class="stat-cal-nav" data-dir="-1" aria-label="Vorheriger Monat">‚Äπ</button>
            <div class="stat-calendar-header"></div>
            <button class="stat-cal-nav" data-dir="1" aria-label="N√§chster Monat">‚Ä∫</button>
          </div>
          <div class="stat-calendar-grid"></div>
        </div>
        </div>
      `;
    }

    return html;
  }
    
    async function loadStreakForUser(userId) {
      if (!userId) return 0;

      const { data, error } = await supabaseClient
        .from("streak_view")
        .select("current_streak")
        .eq("user_id", userId)
        .maybeSingle();

      if (error) {
        console.error("loadStreakForUser error:", error);
        return 0;
      }

      return data?.current_streak ?? 0;
    }

    async function loadStreakForUserCached(userId) {
      const cached = getCached(dataCache.streak, userId, CACHE_TTL.streak);
      if (cached !== null) return cached;
      const fresh = await loadStreakForUser(userId);
      setCached(dataCache.streak, userId, fresh);
      return fresh;
    }

  function updateReminderCompletion() {
      if (!notificationsViewEl) return;
      const statusEl = notificationsViewEl.querySelector("#reminderStatus");
      if (!statusEl) return;
      const isComplete = reminderChecklistItems.every(item => isReminderComplete(item));
      statusEl.classList.toggle("is-complete", isComplete);
    }

    function getReminderTarget(item) {
      return parseInt(item?.target) > 0 ? parseInt(item.target) : 1;
    }

    function getReminderIds(item) {
      if (item?.dbIds && Array.isArray(item.dbIds) && item.dbIds.length > 0) return item.dbIds;
      return [item.id];
    }

    function getReminderCount(item) {
      const ids = getReminderIds(item);
      return ids.reduce((sum, id) => sum + (reminderChecklistState.has(id) ? 1 : 0), 0);
    }

    function isReminderComplete(item) {
      return getReminderCount(item) >= getReminderTarget(item);
    }

    function getReminderTotalTarget() {
      return reminderChecklistItems.reduce((sum, item) => sum + getReminderTarget(item), 0);
    }
    
    async function renderNotifications() {
      if (currentUser?.id) {
        await checkReminderResetDaily();
        await loadReminderClicksForDay(currentUser.id);
      }

      const itemsHtml = reminderChecklistItems.map(item => `
        <button class="reminder-item${isReminderComplete(item) ? " is-selected" : (getReminderCount(item) > 0 ? " is-partial" : "")}" data-reminder-id="${item.id}" type="button">
          <span class="reminder-emoji">${item.emoji}</span>
          <span class="reminder-text">${item.label}</span>
          ${getReminderTarget(item) > 1 ? `<span class="reminder-count">${getReminderCount(item)}/${getReminderTarget(item)}</span>` : ""}
        </button>
      `).join("");

      const isComplete = reminderChecklistItems.every(item => isReminderComplete(item));

      notificationsViewEl.innerHTML = `
        <div class="reminder-pane">
          <div class="reminder-header">
            <button class="reminder-close" id="reminderCloseBtn" aria-label="Schlie√üen">
              <i data-lucide="x"></i>
            </button>
            <div class="reminder-status${isComplete ? " is-complete" : ""}" id="reminderStatus">
              <i data-lucide="check-circle"></i>
              <div class="reminder-status-title">Heute alles erledigt</div>
            </div>
          </div>
          <div class="reminder-list" id="reminderList">
            ${itemsHtml}
          </div>
        </div>
      `;

      const reminderList = notificationsViewEl.querySelector("#reminderList");
      if (reminderList) {
        reminderList.querySelectorAll(".reminder-item").forEach(btn => {
          btn.addEventListener("click", () => {
            const id = btn.dataset.reminderId;
            if (!id) return;
            const item = reminderChecklistItems.find(it => it.id === id);
            if (!item) return;

            const target = getReminderTarget(item);
            const ids = getReminderIds(item);
            const count = getReminderCount(item);

            if (target <= 1) {
              const dbId = ids[0] || id;
              if (reminderChecklistState.has(dbId)) {
                reminderChecklistState.delete(dbId);
                if (currentUser?.id) {
                  const day = getLocalDateString();
                  supabaseClient
                    .from("reminder_clicks")
                    .delete()
                    .eq("user_id", currentUser.id)
                    .eq("day", day)
                    .eq("position_id", dbId)
                    .then(({ error }) => {
                      if (error) console.error("reminder_clicks delete error:", error);
                    });
                }
              } else {
                reminderChecklistState.add(dbId);
                if (currentUser?.id) {
                  const day = getLocalDateString();
                  supabaseClient
                    .from("reminder_clicks")
                    .upsert(
                      { user_id: currentUser.id, day, position_id: dbId },
                      { onConflict: "user_id,day,position_id" }
                    )
                    .then(({ error }) => {
                      if (error) console.error("reminder_clicks upsert error:", error);
                    });
                }
              }
            } else {
              if (count < target) {
                const nextId = ids.find(dbId => !reminderChecklistState.has(dbId)) || ids[ids.length - 1];
                if (nextId && !reminderChecklistState.has(nextId)) {
                  reminderChecklistState.add(nextId);
                  if (currentUser?.id) {
                    const day = getLocalDateString();
                    supabaseClient
                      .from("reminder_clicks")
                      .upsert(
                        { user_id: currentUser.id, day, position_id: nextId },
                        { onConflict: "user_id,day,position_id" }
                      )
                      .then(({ error }) => {
                        if (error) console.error("reminder_clicks upsert error:", error);
                      });
                  }
                }
              } else {
                const removeId = ids.slice().reverse().find(dbId => reminderChecklistState.has(dbId));
                if (removeId) {
                  reminderChecklistState.delete(removeId);
                  if (currentUser?.id) {
                    const day = getLocalDateString();
                    supabaseClient
                      .from("reminder_clicks")
                      .delete()
                      .eq("user_id", currentUser.id)
                      .eq("day", day)
                      .eq("position_id", removeId)
                      .then(({ error }) => {
                        if (error) console.error("reminder_clicks delete error:", error);
                      });
                  }
                }
              }
            }

            const newCount = getReminderCount(item);
            btn.classList.toggle("is-selected", newCount >= target);
            btn.classList.toggle("is-partial", newCount > 0 && newCount < target);
            const countEl = btn.querySelector(".reminder-count");
            if (countEl && target > 1) countEl.textContent = `${newCount}/${target}`;
            updateReminderCompletion();
          });
        });
      }

      const closeBtn = notificationsViewEl.querySelector("#reminderCloseBtn");
      if (closeBtn) {
        closeBtn.addEventListener("click", () => {
          closeNotificationsPane();
        });
      }
    }

    async function renderStats(myHabits, otherHabits, otherUserData) {
      // --- Ensure otherUserData is loaded before rendering ---
      if (!otherUserData) {
        try {
          otherUserData = await loadOtherUserCached();
          otherUser = otherUserData;
          if (otherUserData && (!otherHabits || otherHabits.length === 0)) {
            otherHabits = await loadHabitsForUserCached(otherUserData.id);
          }
        } catch (e) {
          console.error("Failed to load other user for stats rendering:", e);
        }
      }
      const myName = (
        currentUser?.user_metadata?.display_name ||
        currentUser?.email?.split("@")[0] ||
        "Du"
      );
      const myAvatarUrl = getAvatarUrl(currentUser?.user_metadata || {});

      const [myStreak, otherStreak] = await Promise.all([
        loadStreakForUserCached(currentUser.id),
        otherUserData ? loadStreakForUserCached(otherUserData.id) : Promise.resolve(null)
      ]);

      let html = "";

      // === Mein Name + Streak rechts perfekt b√ºndig ===
      html += `
        <div style="
          display:flex;
          justify-content:space-between;
          align-items:flex-end;
          margin-bottom:20px;
        ">

          <!-- Name: klickbar / editierbar -->
          <div id="editableNameWrapper" class="stats-name-row">
            <div id="editableName" class="stats-name" style="line-height:1; margin:0; padding:0; cursor:pointer;">
              ${myName}
            </div>
          </div>

          <button class="stats-panel-toggle" type="button" data-panel-target="my">
            <i data-lucide="panel-bottom-open"></i>
          </button>

        </div>
      `;

      html += `<div class="stats-user-panel" data-panel="my">`;

      html += barsHtml(myHabits, "my");

      const reminderClicksCount = await loadReminderClickCountForDay(currentUser.id);
      if (reminderClicksCount > 0) {
        const reminderTotal = getReminderTotalTarget() || 1;
        const reminderPercent = Math.min(100, Math.round((reminderClicksCount / reminderTotal) * 100));
        html += `
          <div class="stat-item">
            <div class="stat-bar" style="position:relative;">
              <div class="stat-bar-inner">
                <button class="stat-icon-btn" type="button" style="cursor:default; pointer-events:none;">
                  <i data-lucide="cookie"></i>
                </button>
                <div class="stat-icon-options" aria-hidden="true"></div>
                <div class="stat-bar-track">
                  <div class="stat-progress" data-progress="${reminderPercent}" style="
                    position:absolute;
                    inset:0;
                    width:0%;
                    background:#8bb6ff;
                    border-radius:12px;
                    z-index:1;
                  "></div>
                  <div class="stat-bar-label">Ern√§hrung</div>
                </div>
              </div>
            </div>
          </div>
        `;
      }

      html += `</div>`;

      // === Optional: anderer User ===
      if (otherUserData) {
        const otherName = otherUserData.display_name || "Freund:in";
        const otherAvatarUrl = getAvatarUrl(otherUserData || {});
        // otherStreak already loaded above

        html += `<div style="height:40px"></div>`;

        html += `
          <div style="
            display:flex;
            justify-content:space-between;
            align-items:flex-end;
            margin-bottom:20px;
          ">
          <div class="stats-name-row">
              <div class="stats-name" style="
                line-height:1;
                margin:0;
                padding:0;
              ">${otherName}</div>
            </div>

            <button class="stats-panel-toggle" type="button" data-panel-target="other">
              <i data-lucide="panel-top-open"></i>
            </button>
          </div>
        `;

        html += `<div class="stats-user-panel is-collapsed" data-panel="other">`;
        html += barsHtml(otherHabits, "other");
        html += `</div>`;

        const reliabilityChartHtml = await buildReliabilityChartHtml(myHabits, otherHabits, otherName);
        html += `
          <div style="
            display:flex;
            justify-content:space-between;
            align-items:flex-end;
            margin-top:24px;
            margin-bottom:14px;
          ">
            <div class="stats-name-row">
              <div class="stats-name" style="line-height:1; margin:0; padding:0;">Diagramm</div>
            </div>
            <button class="stats-panel-toggle" type="button" data-panel-target="diagram">
              <i data-lucide="panel-top-open"></i>
            </button>
          </div>
        `;
        html += `<div class="stats-user-panel is-collapsed" data-panel="diagram">`;
        html += reliabilityChartHtml;
        html += `</div>`;

      }

      statsViewEl.innerHTML = html;
      lucide.createIcons({ scope: statsViewEl });
      statsCalendarHabits = {
        myHabits: myHabits || [],
        otherHabits: otherHabits || [],
        otherUserId: otherUserData ? otherUserData.id : null
      };
      setupStatCalendarInteractions();
      setupStatIconPickers();
      animateStatBars();
      refreshStatsCalendarData();
      updateDesktopLayoutHeights();
      alignDesktopStatsTop();
      alignDesktopDividerHeight();
      // --- NAME-EDITIERUNG AKTIVIEREN ---
      const editableName = document.getElementById("editableName");
      const statsAvatarSelf = document.getElementById("statsAvatarSelf");

      editableName.addEventListener("click", () => {
        const current = editableName.textContent.trim();

        // Input erzeugen
        editableName.innerHTML = `
          <input id="nameEditInput"
                 type="text"
                 value="${current}"
                 style="
                   font-size:2rem;
                   font-weight:700;
                   border:none;
                   outline:none;
                   background:transparent;
                   border-bottom:2px solid #ccc;
                   width:100%;
                 "
          />
        `;

        const input = document.getElementById("nameEditInput");
        input.focus();
        input.setSelectionRange(current.length, current.length);

        async function save() {
          const newName = input.value.trim();
          if (!newName || newName === current) {
            editableName.textContent = current;
            return;
          }

          const { error } = await supabaseClient.auth.updateUser({
            data: { display_name: newName }
          });

          if (error) {
            console.error("Name update error:", error);
            editableName.textContent = current;
            return;
          }

          // UI aktualisieren
          editableName.textContent = newName;

          // Stats aktualisieren (optional)
          await refreshStatsLive();
        }

        input.addEventListener("blur", save);
        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            save();
          }
        });
      });

      statsViewEl.querySelectorAll(".stats-panel-toggle").forEach(btn => {
        btn.addEventListener("click", () => {
          const target = btn.dataset.panelTarget;
          const panel = statsViewEl.querySelector(`.stats-user-panel[data-panel="${target}"]`);
          if (!panel) return;
          const allPanels = Array.from(statsViewEl.querySelectorAll(".stats-user-panel"));
          const allButtons = Array.from(statsViewEl.querySelectorAll(".stats-panel-toggle"));

          allPanels.forEach(p => {
            if (p === panel || p.classList.contains("is-collapsed")) return;
            if (window.gsap) {
              gsap.to(p, {
                height: 0,
                opacity: 0,
                duration: 0.2,
                ease: "power1.in",
                onComplete: () => {
                  p.classList.add("is-collapsed");
                  p.style.height = "";
                  p.style.opacity = "";
                }
              });
            } else {
              p.classList.add("is-collapsed");
            }
          });

          allButtons.forEach(otherBtn => {
            if (otherBtn === btn) return;
            otherBtn.innerHTML = `<i data-lucide="panel-top-open"></i>`;
            lucide.createIcons({ scope: otherBtn });
          });

          const isCollapsed = panel.classList.contains("is-collapsed");
          if (isCollapsed) {
            panel.classList.remove("is-collapsed");
            if (window.gsap) {
              const targetHeight = panel.scrollHeight;
              gsap.fromTo(panel, { height: 0, opacity: 0 }, {
                height: targetHeight,
                opacity: 1,
                duration: 0.24,
                ease: "power2.out",
                onComplete: () => {
                  panel.style.height = "";
                  panel.style.opacity = "";
                }
              });
            }
          } else {
            if (window.gsap) {
              gsap.to(panel, {
                height: 0,
                opacity: 0,
                duration: 0.2,
                ease: "power1.in",
                onComplete: () => {
                  panel.classList.add("is-collapsed");
                  panel.style.height = "";
                  panel.style.opacity = "";
                }
              });
            } else {
              panel.classList.add("is-collapsed");
            }
          }

          const nowCollapsed = panel.classList.contains("is-collapsed");
          btn.innerHTML = `<i data-lucide="${nowCollapsed ? "panel-top-open" : "panel-bottom-open"}"></i>`;
          lucide.createIcons({ scope: btn });
          updateDesktopLayoutHeights();
          alignDesktopStatsTop();
          alignDesktopDividerHeight();
        });
      });
      lucide.createIcons();
    }

    function animateStatBars() {
      const bars = statsViewEl ? statsViewEl.querySelectorAll(".stat-progress") : [];
      bars.forEach(bar => {
        const target = parseFloat(bar.dataset.progress || "0");
        if (window.gsap) {
          gsap.set(bar, { width: "0%" });
          gsap.to(bar, { width: `${target}%`, duration: 0.6, ease: "power2.out" });
        } else {
          bar.style.width = `${target}%`;
        }
      });
    }

  async function refreshStatsLive() {
    if (!currentUser) return;

    const [myHabits, otherUserData] = await Promise.all([
      loadHabitsForUserCached(currentUser.id),
      loadOtherUserCached()
    ]);
    otherUser = otherUserData;
    const otherHabits = otherUserData ? await loadHabitsForUserCached(otherUserData.id) : [];
    renderStats(myHabits, otherHabits, otherUserData);
  }

    statsBtnEl.addEventListener("click", async () => {
      if (statsOpen) return;

      // Close notifications if open
      const closeBtn = document.getElementById("reminderCloseBtn");
      if (closeBtn) {
        closeBtn.style.opacity = "0";
        closeBtn.style.pointerEvents = "none";
      }
      gsap.to("#notificationsView", {
        top: "100svh",
        duration: 0.42,
        ease: "power1.in",
        delay: 0.4,
        onStart: () => setLoginOrbsPaused(true),
        onComplete: () => setLoginOrbsPaused(false)
      });

      addBtnEl.dataset.mode = "stats";
      statsOpen = true;

      const myHabits = habits;
      let otherHabits = [];
      let otherUserData = otherUser;

      if (!otherUserData) {
        otherUserData = await loadOtherUserCached();
        otherUser = otherUserData;
      }

      if (otherUserData) {
        otherHabits = await loadHabitsForUserCached(otherUserData.id);
      }

      await renderStats(myHabits, otherHabits, otherUserData);

      gsap.to("#statsView", {
        top: "0svh",
        duration: 0.42,
        ease: "power1.out",
        delay: 0.4,
        onStart: () => setLoginOrbsPaused(true),
        onComplete: () => setLoginOrbsPaused(false)
      });

      refreshAddButtonIcon();
    });

  // === Shake Detection + UNO-Wiggle/Hide ===

  let lastShakeTime = 0;
  const SHAKE_THRESHOLD = 18; // ggf. anpassen

  function setupShakeDetection() {
    if (typeof window === "undefined") return;
    if (!("DeviceMotionEvent" in window)) return;

    window.addEventListener("devicemotion", handleDeviceMotion, false);
  }

  function handleDeviceMotion(event) {
    const acc = event.accelerationIncludingGravity || event.acceleration;
    if (!acc) return;

    const x = acc.x || 0;
    const y = acc.y || 0;
    const z = acc.z || 0;
    const magnitude = Math.sqrt(x*x + y*y + z*z);

    const now = Date.now();
    if (magnitude > SHAKE_THRESHOLD && now - lastShakeTime > 1200) {
      lastShakeTime = now;
      onShakeDetected();
    }
  }

  function onShakeDetected() {
    if (!habits || habits.length === 0) return;
    if (deletePanelVisible) return;

    showDeletePanelAndAnimateCards();
  }

  function showDeletePanelAndAnimateCards() {
    deletePanelVisible = true;
    clearTimeout(deleteTimeout);

    const cards = document.querySelectorAll(".card");
    const buttonsRow = document.querySelector(".buttons-row");
    if (!buttonsRow || cards.length === 0) return;

    const buttonsRect = buttonsRow.getBoundingClientRect();
    let panelTopBase = null;

    cards.forEach((card, idx) => {
      const rect = card.getBoundingClientRect();
      const targetTop = buttonsRect.top - rect.height / 2; // Karte halb hinter Buttons
      const dy = targetTop - rect.top;

      if (idx === 0) {
        panelTopBase = targetTop;
      }

      const tl = gsap.timeline();
      tl.to(card, { rotation:-2, duration:0.08, ease:"power1.out" })
        .to(card, { rotation:2, repeat:4, yoyo:true, duration:0.08, ease:"sine.inOut" })
        .to(card, { rotation:0, y:dy, duration:0.38, ease:"power2.out" }, "-=0.08");
    });

    // Panel anzeigen und direkt oberhalb der obersten Karte positionieren
    deletePanel.style.display = "flex";
    deletePanel.style.opacity = "0";

    requestAnimationFrame(() => {
      const panelHeight = deletePanel.offsetHeight || 24;
      let panelTop = 12;
      if (panelTopBase !== null) {
        panelTop = panelTopBase - panelHeight - 8;
        if (panelTop < 8) panelTop = 8;
      }
      deletePanel.style.top = panelTop + "px";

      gsap.to(deletePanel, {
        opacity:1,
        y:0,
        duration:0.25,
        ease:"power1.out"
      });
    });

    // nach 5 Sekunden Inaktivit√§t wieder zur√ºck animieren (ohne L√∂schen)
    deleteTimeout = setTimeout(() => {
      reverseShakeAnimation();
    }, 5000);
  }

  function reverseShakeAnimation() {
    if (!deletePanelVisible) return;
    deletePanelVisible = false;
    clearTimeout(deleteTimeout);

    const cards = document.querySelectorAll(".card");

    cards.forEach(card => {
      const tl = gsap.timeline();
      tl.to(card, {
          y: "-10",
          rotation: -2,
          duration: 0.12,
          ease: "power1.out"
        })
        .to(card, {
          y: 0,
          rotation: 0,
          duration: 0.28,
          ease: "power2.inOut"
        });
    });

    gsap.to(deletePanel, {
      opacity:0,
      y:4,
      duration:0.22,
      ease:"power1.in",
      onComplete: () => {
        deletePanel.style.display = "none";
        deletePanel.style.y = 0;
      }
    });
  }

  async function deleteAllHabits() {
    clearTimeout(deleteTimeout);

    if (currentUser && habits && habits.length > 0) {
      const ids = habits.map(h => h.id);
      const { error } = await supabaseClient
        .from("habits")
        .update({ progress: 0 })
        .in("id", ids);

      if (error) {
        console.error("resetAllHabits error:", error);
      }
    }

    // Lokale Daten aktualisieren
    habits = habits.map(h => ({ ...h, progress: 0 }));
    invalidateHabitsCache(currentUser?.id);

    clearAllSlots();
    habits.forEach((habit, i) => {
      createCardFromHabit(habit, i, 0);
    });
    refreshAddButtonIcon();

    reverseShakeAnimation();
  }

  deleteAllBtn.addEventListener("click", () => {
    deleteAllHabits();
  });

  deletePanel.addEventListener("click", () => {
    // Optional: hier k√∂nnte man das Timeout abbrechen etc.
  });

  // Login-Kreis schwebend animieren

  /*
    SQL zum Sicherstellen, dass die Spalte "color" existiert:

    ALTER TABLE public.habits
    ADD COLUMN IF NOT EXISTS color text DEFAULT '#e4e4e4';

    Aktiv-Status wird logisch abgeleitet √ºber:
      progress > 0  => aktiv
      progress = 0  => inaktiv
  */
    
    // requestAllPermissions removed: permissions are now requested via intro flow only.
    
    function urlBase64ToUint8Array(base64String) {
      const padding = '='.repeat((4 - base64String.length % 4) % 4);
      const base64 = (base64String + padding)
        .replace(/-/g, '+')
        .replace(/_/g, '/');

      const rawData = atob(base64);
      const outputArray = new Uint8Array(rawData.length);

      for (let i = 0; i < rawData.length; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
      }
      return outputArray;
    }

     // Auto permission + push subscribe removed; handled in intro flow.
    
    function getQRParam() {
      const params = new URLSearchParams(window.location.search);
      return params.get("qr"); // z.B. ?qr=ABC123
    }
    

    // === QR Info Modal Handler ===
function showQRInfo(title, kcal, d1, d2, d3) {
  return new Promise(resolve => {
    document.getElementById("qrInfoTitle").textContent = title || "";
    document.getElementById("qrInfoKcal").textContent = `${kcal} KCAL`;

    document.getElementById("qrInfoDate1").innerHTML =
      `<i data-lucide="hand-helping" style="width:20px;height:20px;"></i> ${d1 || "-"}`;

    document.getElementById("qrInfoDate2").innerHTML =
      `<i data-lucide="snowflake" style="width:20px;height:20px;"></i> ${d2 || "-"}`;

    document.getElementById("qrInfoDate3").innerHTML =
      `<i data-lucide="calendar-clock" style="width:20px;height:20px;"></i> ${d3 || "-"}`;

    lucide.createIcons();

    const scr = document.getElementById("qrInfoScreen");
    scr.style.display = "flex";

    const cards = document.querySelectorAll(".card");
    const infoBox = document.getElementById("qrInfoBox");

    // Neues, stabileres Ziel-Y berechnet den Abstand anhand der tats√§chlichen Position der InfoBox
    const infoRect = infoBox.getBoundingClientRect();
    const safeOffset = 40; // zus√§tzlicher Platz, damit die Karten garantiert unter die Box rutschen

    cards.forEach(card => {
      const cardRect = card.getBoundingClientRect();
      const targetY = (infoRect.bottom + safeOffset) - cardRect.top;

      gsap.to(card, { y: targetY, duration: 0.42, ease: "power2.out" });
    });

    const okBtn = document.getElementById("qrInfoOK");
    const cancelBtn = document.getElementById("qrInfoCancel");

    function resetCards() {
      scr.style.display = "none";
      cards.forEach(card => {
        gsap.to(card, { y: 0, duration: 0.42, ease: "power2.out" });
      });
    }

    okBtn.onclick = () => {
      resetCards();
      resolve(true);
    };

    cancelBtn.onclick = () => {
      resetCards();
      resolve(false);
    };
  });
}
    
    function isToday(dateStr) {
      if (!dateStr) return false;
      const d = new Date(dateStr);
      const today = new Date();

      return (
        d.getFullYear() === today.getFullYear() &&
        d.getMonth() === today.getMonth() &&
        d.getDate() === today.getDate()
      );
    }
    
async function processQRFlow(qrId) {
  try {
    if (!qrId) return;

    // URL cleanup
    if (window.history && window.history.replaceState) {
      const cleanUrl = window.location.origin + window.location.pathname;
      window.history.replaceState({}, "", cleanUrl);
    }

    // Ensure user
    if (!currentUser) {
      const { data } = await supabaseClient.auth.getUser();
      currentUser = data?.user || null;
      if (!currentUser) return;
    }

    // Load QR row
    const { data: qrRow, error: qrErr } = await supabaseClient
      .from("qr_codes")
      .select("*")
      .eq("code", qrId)
      .single();

    if (qrErr || !qrRow) return;

    const kcal = parseInt(qrRow.kcal_value) || 0;
    if (kcal <= 0) return;

    // Daily limit
    if (isToday(qrRow.last_scanned)) {
      return;
    }

    // Load QR-enabled habit
    const { data: habit, error: hErr } = await supabaseClient
      .from("habits")
      .select("*")
      .eq("user_id", currentUser.id)
      .eq("qr_enabled", true)
      .limit(1)
      .maybeSingle();

    if (hErr || !habit) return;

    // Confirmation dialog
    const ok = await showQRInfo(
      qrRow.internal_note,
      kcal,
      qrRow.date_manufactured,
      qrRow.date_cooled,
      qrRow.date_planned
    );
    if (!ok) return;

    // Add kcal
    const newProgress = (parseInt(habit.progress) || 0) + kcal;

    const { error: updErr } = await supabaseClient
      .from("habits")
      .update({ progress: newProgress })
      .eq("id", habit.id);

    if (updErr) return;
    syncHabitDayForProgress(habit.id, newProgress, currentUser.id);

    // Update last scanned
    const today = new Date().toISOString().substring(0, 10);

    await supabaseClient
      .from("qr_codes")
      .update({ last_scanned: today })
      .eq("id", qrRow.id);

    // Reload UI
    await safeLoadHabits();
    showAppAfterDataLoaded();

  } catch (err) {
    console.error("processQRFlow fatal error:", err);
  }
}
    

  
    
</script>

<!-- QR INFO SCREEN (Text, no modal look) -->
<div id="qrInfoScreen" style="
  position:fixed;
  inset:0;
  background:transparent;
  display:none;
  justify-content:center;
  align-items:center;
  z-index:999998;
  pointer-events:none;
">
  <div id="qrInfoBox" style="
    pointer-events:auto;
    text-align:center;
    font-size:22px;
    font-weight:700;
    color:var(--c-text);
    background:var(--c-card);
    line-height:1.4;
  ">
  <div id="qrInfoTitle" style="
    font-size:20px;
    font-weight:700;
    margin-bottom:10px;
  "></div>
    <div id="qrInfoKcal"></div>

    <div style="margin-top:12px; font-size:18px; font-weight:600;">
      <div id="qrInfoDate1" style="display:flex; align-items:center; gap:8px; justify-content:center;"></div>
      <div id="qrInfoDate2" style="display:flex; align-items:center; gap:8px; justify-content:center; margin-top:6px;"></div>
      <div id="qrInfoDate3" style="display:flex; align-items:center; gap:8px; justify-content:center; margin-top:6px;"></div>
    </div>

    <div style="display:flex; justify-content:center; gap:16px; margin-top:24px;">
      <button id="qrInfoOK" style="
        padding:12px 22px;
        border-radius:12px;
        border:none;
        background:#000;
        color:white;
        font-size:16px;
        font-weight:600;
      ">OK</button>

      <button id="qrInfoCancel" style="
        padding:12px 22px;
        border-radius:12px;
        border:none;
        background:#ef4444;
        color:white;
        font-size:16px;
        font-weight:600;
      ">Abbrechen</button>
    </div>
  </div>
</div>

<!-- QR CONFIRMATION MODAL -->
<div id="qrConfirmOverlay" style="
  position:fixed;
  inset:0;
  background:rgba(0,0,0,0.35);
  backdrop-filter:blur(2px);
  display:none;
  justify-content:center;
  align-items:center;
  z-index:999999;
">
  <div id="qrConfirmBox" style="
    background:var(--c-card);
    color:var(--c-text);
    padding:24px;
    border-radius:20px;
    width:80%;
    max-width:340px;
    text-align:center;
    box-shadow:0 6px 20px rgba(0,0,0,0.2);
  ">
    <div id="qrConfirmText" style="
      font-size:18px;
      font-weight:600;
      margin-bottom:24px;
    ">
      Soll der Wert hinzugef√ºgt werden?
    </div>

    <div style="display:flex; justify-content:center; gap:16px;">
      <button id="qrConfirmYes" style="
        flex:1;
        padding:12px;
        border-radius:12px;
        border:none;
        background:#000;
        color:white;
        font-size:16px;
        font-weight:600;
      ">Ja</button>

      <button id="qrConfirmNo" style="
        flex:1;
        padding:12px;
        border-radius:12px;
        border:none;
        background:#ef4444;
        color:#ffffff;
        font-size:16px;
        font-weight:600;
      ">Nein</button>
    </div>
  </div>
</div>

<script>
if ("serviceWorker" in navigator) {
  // Only register service worker on secure origins or localhost
  if (location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
    window.addEventListener("load", async () => {
      try {
        // dev override: if URL contains ?sw=0 or localStorage swDisabled, unregister existing SWs
        const urlParams = new URLSearchParams(window.location.search);
        const swDisabled = urlParams.get('sw') === '0' || localStorage.getItem('swDisabled') === '1';
        if (swDisabled && navigator.serviceWorker) {
          const regs = await navigator.serviceWorker.getRegistrations();
          for (const r of regs) await r.unregister();
          console.info('Service workers unregistered (dev override)');
          return;
        }

        const reg = await navigator.serviceWorker.register('/habits/sw.js');
        // immediately check for updates
        try { await reg.update(); } catch(e) { /* ignore */ }

        // If a new SW is waiting, tell it to skipWaiting so it activates immediately
        if (reg.waiting) {
          try { reg.waiting.postMessage({ type: 'SKIP_WAITING' }); } catch(e){}
        }

        // Listen for updates found and when installed -> trigger skipWaiting
        reg.addEventListener('updatefound', () => {
          const installing = reg.installing;
          if (!installing) return;
          installing.addEventListener('statechange', () => {
            if (installing.state === 'installed' && reg.waiting) {
              try { reg.waiting.postMessage({ type: 'SKIP_WAITING' }); } catch(e){}
            }
          });
        });

        // When the controlling worker changes (new SW activated), reload the page to get fresh assets
        navigator.serviceWorker.addEventListener('controllerchange', () => {
          try {
            if (!window.__swReloading) {
              window.__swReloading = true;
              window.location.reload();
            }
          } catch (e) {}
        });

      } catch (err) {
        console.error('SW registration failed:', err);
      }
    });
  } else {
    console.info('Service worker not registered: insecure origin', location.protocol);
  }
}
    
    function setupPushRealtime() {
      if (!currentUser) return;

      if (Notification.permission !== "granted") {
        return;
      }

      supabaseClient
        .channel('push-info-channel')
        .on(
          'postgres_changes',
          {
            event: 'INSERT',
            schema: 'public',
            table: 'push_info',
            filter: `user_id=eq.${currentUser.id}`
          },
          (payload) => {
            const data = payload.new;
            if (!data) return;

            try {
              new Notification(data.title || "Neue Nachricht", {
                body: data.body || ""
              });
            } catch (e) {
              console.error("Notification error:", e);
            }
          }
        )
        .subscribe();
    }

    // Nach Login starten:
    setupPushRealtime();
    
    
    if (currentUser) {
      supabaseClient
        .channel('push-info-channel')
        .on(
          'postgres_changes',
          {
            event: 'INSERT',
            schema: 'public',
            table: 'push_info',
            filter: `user_id=eq.${currentUser.id}`
          },
          (payload) => {
            console.log("üì® PUSH via Realtime empfangen:", payload);

            const data = payload.new;
            if (!data) return;

            if (Notification.permission !== "granted") return;

            try {
              new Notification(data.title || "Neue Nachricht", {
                body: data.body || ""
              });
              console.log("üîî Notification erzeugt:", data.title, data.body);

            } catch (e) {
              console.error("‚ùå Notification error:", e);
            }
          }
        )
        .subscribe();
    }
      
      async function checkMedalScreen() {
        if (!currentUser) return;

        const today = new Date();
        const isMonday = today.getDay() === 1; // Montag

        if (!isMonday) return;

        const { data, error } = await supabaseClient
          .from("streak_view")
          .select("current_streak, showMedal")
          .eq("user_id", currentUser.id)
          .maybeSingle();

        if (error || !data) return;

        if (parseInt(data.showMedal) === 7) return;

        const streak = data.current_streak || 0;

        const medalScreen = document.getElementById("medalScreen");
        const medalText   = document.getElementById("medalText");
        const medalOkBtn  = document.getElementById("medalOkBtn");
        const medalImage  = document.getElementById("medalImage");

        // Erfolg: showMedal = 1
        if (parseInt(data.showMedal) === 1) {
          medalImage.src = "https://raw.githubusercontent.com/lillyapp/habits/refs/heads/main/firstplace.png";
          medalText.textContent =
            `Yeah! Du hast eine Woche mehr geschafft! Dein Streak ist bei ${streak}.`;
        }
        // Misserfolg: showMedal = 0
        else {
          medalImage.src = "https://raw.githubusercontent.com/lillyapp/habits/refs/heads/main/cry.png";
          medalText.textContent =
            "Dein Streak wurde nicht erweitert.\nDu schaffst es!";
        }

        medalScreen.style.display = "flex";

        medalOkBtn.onclick = async () => {
          medalScreen.style.display = "none";

          // Nach OK immer showMedal = 7 setzen
          await supabaseClient
            .from("streak_view")
            .update({ showMedal: 7 })
            .eq("user_id", currentUser.id);
        };
      }
      
</script>

</body>
</html>
  

  <style>
    /* Expanded card: move counter to top-right */
    .card.expanded .counter-wrap {
      top: 24px;
      right: 24px;
      bottom: auto;
    }
  </style>
