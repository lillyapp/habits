<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Consistency</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <link rel="apple-touch-icon" href="./icon.png">

  <!-- Lucide -->
  <script src="https://unpkg.com/lucide@latest"></script>
  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- GSAP -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">

      <link rel="manifest" href="manifest.json">

          <script>
          if ("serviceWorker" in navigator) {
            navigator.serviceWorker.register("sw.js", {
              scope: "./"
            });
          }
          </script>
  <style>
    :root {
      --page-padding: 16px;
      --card-height: calc((100svh - 16px*5 - 60px - env(safe-area-inset-bottom)) / 3);
    }

    * {
      margin:0;
      padding:0;
      box-sizing:border-box;
      user-select:none;
      -webkit-user-select:none;
    }

    body {
      margin:0;
      padding:0;
      font-family: "Poppins", sans-serif;
      background:#fff;
      color:#000;
      height:100svh;
      overflow:hidden;
    }

    /* LOGIN */
    #loginScreen {
      position:absolute;
      inset:0;
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      padding:20px;
      z-index:20;
      background:#fff;
      opacity:1;
      transition:opacity 0.4s ease;
    }

    @keyframes pulse {
      0% {transform:scale(1);}
      50%{transform:scale(1.06);}
      100%{transform:scale(1);}
    }

    #loginCircle {
      width:30px;
      height:30px;
      background:#000;
      border-radius:50%;
      animation:pulse 2.2s ease-in-out infinite;
    }

    #loginHeadline {
      margin-top:28px;
      font-size:26px;
      font-weight:600;
      text-align:center;
    }

    #loginButtonBar {
      width:100%;
      max-width:400px;
      display:flex;
      gap:14px;
      margin-top:50px;
    }

    .btn {
      flex:1;
      padding:14px;
      border-radius:20px;
      border:none;
      font-size:17px;
      cursor:pointer;
    }

    #btnLogin    {background:#000; color:#fff;}
    #btnRegister {background:#e5e5e5; color:#000;}

    #loginForm {
      width:100%;
      max-width:400px;
      display:none;
      flex-direction:column;
      gap:12px;
      margin-top:30px;
    }

    .login-input {
      padding:12px;
      border:none;
      border-radius:12px;
      background:#e5e5e5;
    }

    #loginError {
      margin-top:12px;
      color:#ef4444;
      font-size:14px;
      display:none;
      text-align:center;
    }

    /* MAIN PAGE (Habit-Klötze) */
    #appPage {
      position:absolute;
      inset:0;
      display:none;
      opacity:0;
    }

    .page {
      height:100%;
      display:flex;
      flex-direction:column;
      padding:16px;
      padding-bottom:140px;
      gap:16px;
    }

    .cards {
      flex:1;
      display:flex;
      flex-direction:column;
      gap:16px;
    }

    .slot {
      position:relative;
      height:var(--card-height);
      perspective:1200px;
    }

    .card {
      position:absolute;
      inset:0;
      border-radius:24px;
      background:#e4e4e4;
      padding:24px;
      transform-style:preserve-3d;
      cursor:pointer;
      opacity:0;
      transition:transform 0.25s linear;
    }

    .card-face {
      position:absolute;
      inset:0;
      backface-visibility:hidden;
      border-radius:24px;
      padding:24px;
    }

      .card-face.front {
        background:transparent;
        display:flex;
        flex-direction:column-reverse;  /* wichtig */
        justify-content:flex-start;
      }

    .back {
      background:#e4e4e4;
      transform:rotateY(180deg);
      display:flex;
      flex-direction:row;
      justify-content:space-between;
      padding:24px;
    }

    .half {
      width:50%;
      display:flex;
      justify-content:center;
      align-items:center;
      font-size:2rem;
      font-weight:800;
      color:#777;
    }

      .card-input {
        width: 100%;
        max-width: calc(100% - 90px);
        font-size: 2rem;
        font-weight: 800;
        border: none;
        background: transparent;
        outline: none;
        color: #666;
        margin-top: 6px;
        margin-bottom: 0;
        line-height: 1.1;
        white-space: normal;      /* neuer Umbruch */
        word-wrap: break-word;    /* Wörter umbrechen */
        min-height: 2.4rem;       /* Platz für min. 1 Zeile */
      }

      .card-input:empty::before {
        content: attr(data-placeholder);
        color: #999;
      }

    .counter {
      position:absolute;
      bottom:24px;
      right:24px;
      background:#fff;
      padding:4px 12px;
      border-radius:999px;
      border:2px solid #000;
      font-size:1.2rem;
      font-weight:700;
      display:none;
    }

    /* Bottom Buttons (Plus/Haus + Stats) */
    .buttons-row {
      position:fixed;
      left:0;
      right:0;
      bottom:0;
      padding:0 16px calc(16px + env(safe-area-inset-bottom));
      height:calc(60px + env(safe-area-inset-bottom));
      background:transparent; /* Karten bleiben dahinter sichtbar */
      display:flex;
      gap:12px;
      z-index:9999;
      pointer-events:none;
    }

    .btn-half {
      flex:1;
      height:60px;
      border-radius:999px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:1.5rem;
      border:none;
      cursor:pointer;
      pointer-events:auto;
    }

    .btn-plus { background:#000; color:#fff; }
    .btn-stats { background:#f3f3f3; border:2px solid #ccc; color:#333; }

    /* Stats View */
    #statsView {
      position:fixed;
      left:0;
      right:0;
      top:100svh;
      bottom:0;
      background:#fff;
      padding:24px;
      padding-bottom:140px;
      overflow-y:auto;
      z-index:50;
    }

    .stats-name { font-size:2rem; font-weight:700; margin-bottom:20px; }
    .stat-bar { width:100%; height:48px; background:#e5e7eb; border-radius:16px; margin-bottom:18px; overflow:hidden; }
    .stat-fill {
      height:100%;
      width:0;
      padding-left:12px;
      display:flex;
      align-items:center;
      font-weight:700;
      border-radius:16px;
      color:#000;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    /* Dünner Delete-Balken über der obersten Karte */
    #deletePanel {
      position:fixed;
      left:16px;
      right:16px;
      top:12px; /* wird per JS genauer über der obersten Karte platziert */
      background:#ffffff;
      border-radius:999px;
      box-shadow:0 8px 20px rgba(0,0,0,0.12);
      padding:6px 12px;
      display:none;
      align-items:center;
      justify-content:center;
      gap:8px;
      z-index:10000;
      font-size:12px;
    }

    #deletePanelText {
      font-weight:500;
      white-space:nowrap;
    }

    #deleteAllBtn {
      padding:4px 10px;
      border-radius:999px;
      border:1px solid #d4d4d4;
      background:#f3f3f3;
      color:#ef4444;
      font-weight:600;
      font-size:12px;
      cursor:pointer;
      flex-shrink:0;
    }
  </style>
</head>
<body>

<!-- LOGIN -->
<div id="loginScreen">
  <div id="loginCircle"></div>
  <div id="loginHeadline">Hallo, bitte melde dich an</div>

  <div id="loginButtonBar">
    <button class="btn" id="btnLogin">Login</button>
    <button class="btn" id="btnRegister">Registrieren</button>
  </div>

  <div id="loginForm">
    <input id="loginName" class="login-input" placeholder="Name" type="text" style="display:none;" />
    <input id="loginEmail" class="login-input" placeholder="E-Mail" type="email" />
    <input id="loginPassword" class="login-input" placeholder="Passwort" type="password" />
    <div id="forgotPw" style="
      display:none;
      text-align:center;
      margin-top:-6px;
      font-size:14px;
      color:#555;
      text-decoration:underline;
      cursor:pointer;
    ">
      Passwort vergessen?
    </div>
    <button class="btn" id="loginOkBtn">OK</button>
  </div>

  <div id="loginError"></div>
</div>

<!-- MAIN HABIT PAGE (3 Klötze) -->
<div id="appPage">
  <div class="page">
    <div class="cards">
      <div class="slot" id="slot1"></div>
      <div class="slot" id="slot2"></div>
      <div class="slot" id="slot3"></div>
    </div>
  </div>

  <div class="buttons-row">
    <button class="btn-half btn-plus" id="addBtn" data-mode="main">
      <i data-lucide="plus"></i>
    </button>
    <button class="btn-half btn-stats" id="statsBtn">
      <i data-lucide="bar-chart-2"></i>
    </button>
  </div>

  <div id="statsView"></div>

  <!-- Dünner Shake-Delete-Balken -->
  <div id="deletePanel">
    <span id="deletePanelText">Klicke hier, um alle Habits zu löschen.</span>
    <button id="deleteAllBtn">Löschen</button>
  </div>
</div>

<script>
    lucide.createIcons();

    const supabaseClient = supabase.createClient(
      "https://gglgenarpskajkaanknk.supabase.co",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdnbGdlbmFycHNrYWprYWFua25rIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMwODA2NzAsImV4cCI6MjA3ODY1NjY3MH0.phVPaPpkiXJ0ncbRiBChpVBtY8gv0sm_MjlCJJnaSt4"
    );

    const loginScreen   = document.getElementById("loginScreen");
    const loginForm     = document.getElementById("loginForm");
    const loginError    = document.getElementById("loginError");
    const appPage       = document.getElementById("appPage");
    const btnLogin      = document.getElementById("btnLogin");
    const btnRegister   = document.getElementById("btnRegister");
    const loginOkBtn    = document.getElementById("loginOkBtn");
    const loginName     = document.getElementById("loginName");
    const loginEmail    = document.getElementById("loginEmail");
    const loginPassword = document.getElementById("loginPassword");
    const forgotPw = document.getElementById("forgotPw");
    const addBtnEl      = document.getElementById("addBtn");
    const statsBtnEl    = document.getElementById("statsBtn");
    const statsViewEl   = document.getElementById("statsView");
    const deletePanel   = document.getElementById("deletePanel");
    const deleteAllBtn  = document.getElementById("deleteAllBtn");

    const slotOrder = ["slot3","slot2","slot1"];

    let habits      = [];
    let currentUser = null;
    let authMode    = "login";
    let statsOpen   = false;
    let otherUser   = null;

    let deleteTimeout = null;
    let deletePanelVisible = false;

    const cycleColors = [
      "#ef4444","#f97316","#f59e0b","#eab308","#84cc16","#22c55e",
      "#10b981","#14b8a6","#06b6d4","#0ea5e9","#3b82f6","#6366f1",
      "#8b5cf6","#a855f7","#d946ef","#ec4899","#f43f5e","#dc2626",
      "#ea580c","#ca8a04","#4d7c0f","#15803d","#047857","#0f766e",
      "#0369a1","#1d4ed8","#4338ca","#6d28d9","#7e22ce","#be185d"
    ];

    function darken(hex, f=0.55) {
      let r = parseInt(hex.slice(1,3),16)*f|0;
      let g = parseInt(hex.slice(3,5),16)*f|0;
      let b = parseInt(hex.slice(5,7),16)*f|0;
      return `rgb(${r},${g},${b})`;
    }

    function startLoginCircleFloat() {
      if (!document.getElementById("loginCircle")) return;
      gsap.to("#loginCircle", {
        y: -6,
        duration: 2.4,
        repeat: -1,
        yoyo: true,
        ease: "sine.inOut"
      });
    }

    function showAppAfterDataLoaded() {
      appPage.style.display = "block";
      gsap.fromTo(appPage, { opacity:0 }, {
        opacity:1,
        duration:0.5,
        ease:"sine.inOut"
      });

      gsap.to(loginScreen, {
        opacity:0,
        duration:0.45,
        ease:"sine.inOut",
        onComplete: () => { loginScreen.style.display = "none"; }
      });
    }

    // === Passwort-Reset-Funktionen (müssen VOR dem Login-Block stehen) ===
    function showPasswordResetLink() {
      forgotPw.style.display = "block";
    }

    function hidePasswordResetLink() {
      forgotPw.style.display = "none";
    }

// LOGIN
    loginOkBtn.onclick = async () => {
      loginError.style.display = "none";

      const email    = loginEmail.value.trim();
      const password = loginPassword.value.trim();
      const name     = loginName.value.trim();

      if (!email || (!password && authMode !== "reset") || (authMode === "register" && !name)) {
        loginError.textContent = "Bitte alles ausfüllen.";
        loginError.style.display = "block";
        return;
      }

      let error;

      if (authMode === "login") {
        ({ error } = await supabaseClient.auth.signInWithPassword({ email, password }));
      }

      else if (authMode === "register") {
        const { error: signUpErr } = await supabaseClient.auth.signUp({
          email,
          password,
          options: { data: { display_name: name } }
        });
        error = signUpErr;
      }

      else if (authMode === "reset") {
        const { error: resetErr } = await supabaseClient.auth.resetPasswordForEmail(email, {
          redirectTo: window.location.href
        });

        if (resetErr) {
          loginError.textContent = resetErr.message;
          loginError.style.display = "block";
        } else {
          loginError.textContent = "E-Mail zum Zurücksetzen gesendet.";
          loginError.style.display = "block";
        }
        return;
      }

      if (error) {
        loginError.textContent = error.message;
        loginError.style.display = "block";
        return;
      }

      const { data } = await supabaseClient.auth.getUser();
      currentUser = data.user;

      setupRealtime();
      setupShakeDetection();

      await safeLoadHabits();
      showAppAfterDataLoaded();
      initPushAfterLogin();

      // ⭐ WICHTIG: QR-Processing NACH Login
      const qr = getQRParam();
      if (qr) await processQRFlow(qr);
    };

    // === AUTOLOGIN + QR FLOW ===
    (async () => {
      const { data } = await supabaseClient.auth.getUser();
      if (data.user) {
        currentUser = data.user;

        setupRealtime();
        setupShakeDetection();

        await safeLoadHabits();
        showAppAfterDataLoaded();
        initPushAfterLogin();

        // QR verarbeiten, falls beim Start vorhanden
        const qr = getQRParam();
        if (qr) await processQRFlow(qr);
      }
    })();
    

    

    function setupRealtime() {
      supabaseClient.channel('habits-realtime')
        .on(
          'postgres_changes',
          { event: '*', schema: 'public', table: 'habits' },
          async () => {
            if (statsOpen) await refreshStatsLive();
          }
        )
        .subscribe();
    }

    // ---------- TEIL 1: Nur-Server-Load + Initialisierung ----------
    async function safeLoadHabits() {
      if (!currentUser) {
        const { data } = await supabaseClient.auth.getUser();
        currentUser = data.user;
        if (!currentUser) return;
      }

      const { data, error } = await supabaseClient
        .from("habits_active")
        .select("*")
        .eq("user_id", currentUser.id)
        .order("inserted_at", { ascending: true })
        .limit(3);

      if (error) {
        console.error("safeLoadHabits error:", error);
        return;
      }

      const rows = data || [];

      if (rows.length === 0) {
        await createInitialHabits();   // exakt 3 in DB anlegen
        return safeLoadHabits();       // danach erneut laden
      }

      habits = rows;

      clearAllSlots();
      const baseDelay = 0.0;
      habits.forEach((habit, i) => {
        const delay = baseDelay + (habits.length - 1 - i) * 0.12;
        createCardFromHabit(habit, i, delay);
      });

      refreshAddButtonIcon();
    }

    async function createInitialHabits() {
      if (!currentUser) return;

      const inserts = Array.from({ length: 3 }).map(() => ({
        user_id: currentUser.id,
        title: "",
        color: "#e4e4e4",
        progress: 0,
        goal: 1,
        appear_once: false
      }));

      const { error } = await supabaseClient.from("habits").insert(inserts);
      if (error) console.error("createInitialHabits error:", error);
    }

    function clearAllSlots() {
      slotOrder.forEach(id => { document.getElementById(id).innerHTML = ""; });
    }

    function refreshAddButtonIcon() {
      const addBtn = addBtnEl;

      if (addBtn.dataset.mode === "stats") {
        addBtn.innerHTML = '<i data-lucide="house"></i>';
        addBtn.classList.remove("btn-plus");
        addBtn.style.background = "#f3f3f3";
        addBtn.style.color      = "#333";
        addBtn.style.border     = "2px solid #ccc";
        lucide.createIcons();
        return;
      }

      if (habits.length < 3) {
        addBtn.innerHTML = '<i data-lucide="plus"></i>';
        addBtn.classList.add("btn-plus");
        addBtn.style.background = "#000";
        addBtn.style.color      = "#fff";
        addBtn.style.border     = "none";
      } else {
        addBtn.innerHTML = '<i data-lucide="home"></i>';
        addBtn.classList.remove("btn-plus");
        addBtn.style.background = "#f3f3f3";
        addBtn.style.color      = "#333";
        addBtn.style.border     = "2px solid #ccc";
      }
      lucide.createIcons();
    }

    function createCardFromHabit(habit, index, delay = 0) {
      const slot = document.getElementById(slotOrder[index]);
      const card = document.createElement("div");
      card.className = "card";

      const rawGoal   = habit.goal;
      const goal      = (rawGoal === null || rawGoal === undefined) ? 1 : rawGoal;
      const progress  = parseInt(habit.progress) || 0;
      const dbColor   = habit.color || "#e4e4e4";
      const addr      = habit.location_address || "";
      const qrEnabled = habit.qr_enabled || false;

      card.dataset.index    = index;
      card.dataset.habitId  = habit.id;
      card.dataset.goal     = goal;
      card.dataset.progress = progress;
      card.dataset.color    = dbColor;
      card.dataset.location = addr;
      card.dataset.qr       = qrEnabled ? "true" : "false";

      const isActive = progress > 0;
      card.dataset.active = isActive ? "true" : "false";

      // --- HTML ---
      card.innerHTML = `
        <div class="card-face front">
          <div class="card-input" contenteditable="true" data-placeholder="Titel eingeben..."></div>
          <div class="counter counter-kcal" style="display:none;"></div>
        </div>

        <div class="card-face back">

          <!-- GPS AREA -->
          <div class="half" id="gpsArea">
            <div style="display:flex; flex-direction:column; align-items:center; gap:4px;">
              <i data-lucide="map-pin" style="width:32px;height:32px;color:#777;"></i>

              <div class="gps-address-line1" style="
                font-size:0.75rem;
                color:#555;
                text-align:center;
                line-height:1;
                display:none;
              "></div>

              <div class="gps-address-line2" style="
                font-size:0.75rem;
                color:#555;
                text-align:center;
                line-height:1;
                display:none;
              "></div>
            </div>
          </div>

          <!-- QR AREA -->
          <div class="half" id="qrArea">
            <div style="display:flex; flex-direction:column; align-items:center; gap:4px;">
              <i data-lucide="qr-code" style="width:32px;height:32px;color:#777;"></i>

              <div class="qr-status-text" style="
                font-size:0.75rem;
                color:#555;
                text-align:center;
                line-height:1;
                display:none;
              ">Aktiv</div>
            </div>
          </div>

          <!-- Counter & GPS Input -->
          <div class="half" id="numAreaWrapper">
            <div id="numArea">0</div>

            <input 
              class="gpsInput"
              type="text"
              placeholder="Adresse eingeben..."
              style="
                display:none;
                width:100%;
                padding:6px;
                border-radius:12px;
                border:1px solid #ccc;
                font-size:1rem;
              "
            />
          </div>
        </div>
      `;

      slot.appendChild(card);
      lucide.createIcons();

      // --- DOM REFS ---
      const input   = card.querySelector(".card-input");
      const counter = card.querySelector(".counter");
      const isQR = qrEnabled;
      const kcalTarget = 21000;

      if (isQR) {
        counter.style.display = "block";
        counter.textContent = `${parseInt(progress)} KCAL`;
      } else {
        const goal = parseInt(card.dataset.goal) || 1;
        if (goal >= 2) {
          counter.style.display = "block";
          counter.textContent = `${progress}/${goal}`;
        } else {
          counter.style.display = "none";
        }
      }
      const numArea = card.querySelector("#numArea");

      const line1 = card.querySelector(".gps-address-line1");
      const line2 = card.querySelector(".gps-address-line2");

      const qrStatus = card.querySelector(".qr-status-text");

      // === Titel ===
      input.textContent = habit.title || "";

      // === Adresse anzeigen ===
      if (addr) {
        const parts = addr.split(",");
        line1.textContent = (parts[0] || "").trim();
        line2.textContent = (parts[1] || "").trim();
        line1.style.display = "block";
        line2.style.display = "block";
      } else {
        line1.style.display = "none";
        line2.style.display = "none";
      }

      // === QR-Status setzen ===
      if (qrEnabled) {
        qrStatus.style.display = "block";
        qrStatus.textContent = "Aktiv";
      } else {
        qrStatus.style.display = "none";
      }

      // === Counter ===
      numArea.textContent = goal;
      if (goal >= 2) {
        counter.style.display = "block";
        counter.textContent = progress + "/" + goal;
      } else {
        counter.style.display = "none";
      }

      // === Farben ===
      if (isActive) {
        card.style.background = dbColor;
        input.style.color     = darken(dbColor);
      } else {
        card.style.background = "#e4e4e4";
        card.dataset.color    = "#e4e4e4";
        input.style.color     = "#666";
      }

      // === Animation ===
      gsap.fromTo(card, { y:-80, opacity:0 }, {
        y:0,
        opacity:1,
        duration:0.6,
        ease:"power1.out",
        delay
      });
      
      if (qrEnabled) {
        const kcalProgress = parseInt(progress) || 0;
        counter.style.display = "block";
        counter.textContent = `${kcalProgress} KCAL`;
      }
      
      attachCardLogic(card);
    }

    function shake(card) {
      gsap.fromTo(card,
        { x:-10 },
        { x:10, duration:0.1, repeat:3, yoyo:true, ease:"power1.inOut",
          onComplete: () => { card.style.transform = ""; }
        }
      );
    }
    
    function attachCardLogic(card) {
      const input     = card.querySelector(".card-input");
      const counter   = card.querySelector(".counter");
      const gpsArea   = card.querySelector("#gpsArea");
      const numArea   = card.querySelector("#numArea");
      const gpsInput  = card.querySelector(".gpsInput");
      const qrArea    = card.querySelector("#qrArea");
      const qrStatus  = card.querySelector(".qr-status-text");

      let swipeStartX = 0;
      let swipeEndX   = 0;

      // ======================================
      // SWIPE FRONT/BACK
      // ======================================
      card.addEventListener("touchstart",(e)=>{
        swipeStartX = e.touches[0].clientX;
        swipeEndX   = swipeStartX;
      });

      card.addEventListener("touchmove",(e)=>{
        swipeEndX = e.touches[0].clientX;
      });

      card.addEventListener("touchend",()=>{
        const dx = swipeEndX - swipeStartX;

        if (dx < -40 && !card.style.transform.includes("180deg")){
          gsap.to(card,{ rotationY:180, duration:0.48, ease:"sine.inOut" });
        }
        if (dx > 40 && card.style.transform.includes("180deg")){
          gsap.to(card,{ rotationY:0, duration:0.48, ease:"sine.inOut" });
        }
      });

      // ======================================
      // NUMMER / GOAL ÄNDERN (NICHT BEI QR)
      // ======================================
      numArea.addEventListener("click",(e)=>{
        e.stopPropagation();

        // QR-Mode deaktiviert die Goal-Änderung
        if (card.dataset.qr === "true") return;

        let y = parseInt(card.dataset.goal) || 0;
        y = (y + 1) % 8;

        card.dataset.goal = y;
        numArea.textContent = y;

        let x = parseInt(card.dataset.progress) || 0;
        if (x > y) {
          x = y;
          card.dataset.progress = x;
        }

        if (y >= 2) {
          counter.style.display = "block";
          counter.textContent   = x + "/" + y;
        } else {
          counter.style.display = "none";
        }

        saveHabit(card);
      });

      // ======================================
      // GPS EINGABE
      // ======================================
      gpsArea.addEventListener("click", (e) => {
        e.stopPropagation();

        gsap.to(card, { rotationY:180, duration:0.48, ease:"sine.inOut" });

        gpsInput.style.display = "block";
        numArea.style.display = "none";

        gpsInput.value = card.dataset.location || "";
        gpsInput.focus();
      });

      gpsInput.addEventListener("blur", async () => {
        const addr = gpsInput.value.trim();
        card.dataset.location = addr;

        gpsInput.style.display = "none";
        numArea.style.display = "flex";

        const habitId = card.dataset.habitId;
        if (habitId) {
          const { error } = await supabaseClient
            .from("habits")
            .update({ location_address: addr })
            .eq("id", habitId);

          if (error) console.error("GPS address save error:", error);
        }
      });

      // ======================================
      // QR ENABLE / DISABLE
      // ======================================
      qrArea.addEventListener("click", async (e) => {
        e.stopPropagation();

        const enabled = card.dataset.qr === "true";
        const newVal  = !enabled;

        // Toggle setzen
        card.dataset.qr = newVal ? "true" : "false";

        // UI
        qrStatus.style.display = newVal ? "block" : "none";
        qrStatus.textContent   = newVal ? "Aktiv" : "";

        // Counter vorne → KCAL anzeigen
        if (newVal) {
          const kcal = parseInt(card.dataset.progress) || 0;
          counter.style.display = "block";
          counter.textContent = `${kcal} KCAL`;
        } else {
          const goal = parseInt(card.dataset.goal) || 1;
          const prog = parseInt(card.dataset.progress) || 0;

          if (goal >= 2) {
            counter.style.display = "block";
            counter.textContent   = `${prog}/${goal}`;
          } else {
            counter.style.display = "none";
          }
        }

        // In DB speichern
        const habitId = card.dataset.habitId;

        const { error } = await supabaseClient
          .from("habits")
          .update({ qr_enabled: newVal })
          .eq("id", habitId);

        if (error) console.error("QR update error:", error);
      });

      // ======================================
      // LONG-PRESS FARBE
      // ======================================
      let pressTimer = null;
      let pressInterval = null;
      let lastColor = null;

      card.addEventListener("touchstart",()=>{
        clearTimeout(pressTimer);
        clearInterval(pressInterval);
        lastColor = null;

        pressTimer = setTimeout(()=>{
          if (card.dataset.active === "true") {
            let i = 0;
            pressInterval = setInterval(()=>{
              const col = cycleColors[i % cycleColors.length];
              card.style.background = col;
              card.dataset.color    = col;
              input.style.color     = darken(col);
              lastColor = col;
              i++;
            },900);
          }
        },300);
      });

      card.addEventListener("touchend",()=>{
        clearTimeout(pressTimer);
        clearInterval(pressInterval);
        if (lastColor) saveHabit(card);
      });

      // ======================================
      // TITLE SAVE
      // ======================================
      input.addEventListener("blur", ()=> { saveHabit(card); });
      input.addEventListener("keydown", (e)=>{
        if(e.key==="Enter"){ e.preventDefault(); input.blur(); }
      });

      // ======================================
      // TOGGLE HABIT ODER GPS-CHECK
      // ======================================
      card.addEventListener("click", async (e) => {

        // QR-Mode → keine Toggles, Progress muss über QR kommen
        if (card.dataset.qr === "true") return;

        // GPS Check
        const requiredAddress = card.dataset.location;
        if (requiredAddress && requiredAddress.length > 0) {

          e.stopPropagation();

          navigator.geolocation.getCurrentPosition(async (pos) => {
            const userLat = pos.coords.latitude;
            const userLon = pos.coords.longitude;

            const geo = await geocodeAddress(requiredAddress);
            if (!geo) { shake(card); return; }

            const dist = haversine(userLat, userLon, geo.lat, geo.lon);

            if (dist > 100) { shake(card); return; }

            // OK → Toggle
            proceedHabitToggle(card);

          }, () => shake(card));

          return;
        }

        // Normaler Toggle
        proceedHabitToggle(card);
      });
    }


    
    function proceedHabitToggle(card) {
      const input   = card.querySelector(".card-input");
      const counter = card.querySelector(".counter");

      if(!input.value.trim()) return;

      let goal     = parseInt(card.dataset.goal) || 0;
      let progress = parseInt(card.dataset.progress) || 0;
      let active   = card.dataset.active === "true";
      const idx    = parseInt(card.dataset.index);

      if (goal <= 1) {
        if (active) {
          active   = false;
          progress = 0;
          card.style.background = "#e4e4e4";
          card.dataset.color    = "#e4e4e4";
          input.style.color     = "#666";
        } else {
          active   = true;
          progress = 1;

          let col = card.dataset.color;
          if (!col || col === "#e4e4e4") col = cycleColors[idx % cycleColors.length];

          card.style.background = col;
          card.dataset.color    = col;
          input.style.color     = darken(col);
        }
      } else {
        if (progress < goal) {
          progress += 1;
          active = true;

          let col = card.dataset.color;
          if (!col || col === "#e4e4e4") col = cycleColors[idx % cycleColors.length];

          card.style.background = col;
          card.dataset.color    = col;
          input.style.color     = darken(col);
        } else {
          return;
        }
      }

      card.dataset.progress = progress;
      card.dataset.active   = active ? "true" : "false";

      if (goal >= 2) {
        counter.style.display = "block";
        counter.textContent   = progress + "/" + goal;
      } else {
        counter.style.display = "none";
      }

      saveHabit(card);
    }
    
    async function geocodeAddress(addr) {
      const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(addr)}`;
      const resp = await fetch(url);
      const json = await resp.json();

      if (!json || json.length === 0) return null;

      return {
        lat: parseFloat(json[0].lat),
        lon: parseFloat(json[0].lon)
      };
    }
    
    function haversine(lat1, lon1, lat2, lon2) {
      function toRad(x) { return x * Math.PI / 180; }

      const R = 6371000; // Meter
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);

      const a =
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
        Math.sin(dLon/2) * Math.sin(dLon/2);

      return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }

    async function saveHabit(card) {
      if (!currentUser) return;

      const habitId = card.dataset.habitId;
      const input   = card.querySelector(".card-input");
      const title = input.textContent.trim();
      const color   = card.dataset.color || "#e4e4e4";
      const progress  = parseInt(card.dataset.progress) || 0;
      const goal     = parseInt(card.dataset.goal)     || 0;

      if (!habitId) return;

      const { error } = await supabaseClient
        .from("habits")
        .update({ title, color, progress, goal })
        .eq("id", habitId);

      if (error) console.error("saveHabit error:", error);
    }

    // Add-Button: erstellt nur DB-Datensatz, niemals lokal
    addBtnEl.addEventListener("click", async () => {
      if (addBtnEl.dataset.mode === "stats") {
        addBtnEl.dataset.mode = "main";
        statsOpen = false;
        gsap.to("#statsView",{top:"100svh",duration:0.42,ease:"power1.in"});
        refreshAddButtonIcon();
        return;
      }

      if (habits.length >= 3) return;

      if (!currentUser) {
        const { data } = await supabaseClient.auth.getUser();
        currentUser = data.user;
        if (!currentUser) return;
      }

      const { data, error } = await supabaseClient
        .from("habits")
        .insert({
          user_id: currentUser.id,
          title: "",
          color: "#e4e4e4",
          progress: 0,
          goal: 1,
          appear_once: false
        })
        .select()
        .single();

      if (error) {
        console.error("insert habit error:", error);
        return;
      }

      habits.push(data);
      const index = habits.length - 1;
      createCardFromHabit(data, index, 0);
      refreshAddButtonIcon();
    });

  async function loadOtherUser() {
    if (!currentUser) return null;

    const { data, error } = await supabaseClient
      .from("users_public")
      .select("id, display_name")
      .neq("id", currentUser.id)
      .limit(1);

    if (error) {
      console.error("loadOtherUser error:", error);
      return null;
    }

    return data && data.length > 0 ? data[0] : null;
  }

  async function loadHabitsForUser(userId) {
    const { data, error } = await supabaseClient
      .from("habits_active")
      .select("*")
      .eq("user_id", userId)
      .order("inserted_at", { ascending: true })
      .limit(3);

    if (error) {
      console.error("loadHabitsForUser error:", error);
      return [];
    }
    return data || [];
  }
  
  function barsHtml(habits) {
    let html = "";
    for (let i = 0; i < 3; i++) {
      const h = habits[i];

      if (!h) {
        html += `
          <div class="stat-bar" style="position:relative;">
            <div class="stat-fill" style="width:0%"></div>
          </div>`;
        continue;
      }

      const x = h.progress || 0;
      const y = h.goal     || 0;
      const rawTitle = h.title || "";
      const hasTitle = rawTitle.trim().length > 0;
      const color = h.color || "#e5e7eb";

      let percent = 0;
      if (y > 0) {
        percent = (y === 1)
          ? (x >= 1 ? 100 : 0)
          : Math.round((x / y) * 100);
      }

      html += `
        <div class="stat-bar" style="position:relative;">

          <!-- Fortschrittsbalken -->
          <div style="
            position:absolute;
            inset:0;
            width:${percent}%;
            background:${color};
            border-radius:16px;
            z-index:1;
          "></div>

          <!-- Text nur wenn vorhanden -->
          <div style="
            position:relative;
            z-index:2;
            height:100%;
            display:flex;
            align-items:center;
            padding-left:12px;
            font-weight:700;
            color:#000;
            white-space:nowrap;
            overflow:hidden;
            text-overflow:ellipsis;
          ">
            ${hasTitle ? rawTitle : ""}
          </div>

        </div>
      `;
    }

    return html;
  }
    
    async function loadStreakForUser(userId) {
      const { data, error } = await supabaseClient
        .from("streaks")
        .select("current_streak")
        .eq("user_id", userId)
        .single();

      if (error || !data) {
        return 0;
      }

      return data.current_streak || 0;
    }

    async function renderStats(myHabits, otherHabits, otherUserData) {
      const myName = (
        currentUser?.user_metadata?.display_name ||
        currentUser?.email?.split("@")[0] ||
        "Du"
      );

      const myStreak = await loadStreakForUser(currentUser.id);

      let html = "";

      // === Mein Name + Streak rechts perfekt bündig ===
      html += `
        <div style="
          display:flex;
          justify-content:space-between;
          align-items:flex-end;
          margin-bottom:20px;
        ">

          <!-- Name: klickbar / editierbar -->
          <div id="editableNameWrapper" style="display:flex; align-items:flex-end; gap:6px;">
            <div id="editableName" class="stats-name" style="line-height:1; margin:0; padding:0; cursor:pointer;">
              ${myName}
            </div>
          </div>

          <!-- Streak -->
          <div style="
            display:flex;
            align-items:flex-end;
            gap:6px;
            font-size:1.5rem;
            font-weight:700;
            line-height:1;
          ">
            <i data-lucide="medal" style="width:22px; height:22px;"></i>
            <span>${myStreak}</span>
          </div>

        </div>
      `;

      html += barsHtml(myHabits);

      // === Optional: anderer User ===
      if (otherUserData) {
        const otherName = otherUserData.display_name || "Freund:in";
        const otherStreak = await loadStreakForUser(otherUserData.id);

        html += `<div style="height:40px"></div>`;

        html += `
          <div style="
            display:flex;
            justify-content:space-between;
            align-items:flex-end;
            margin-bottom:20px;
          ">
            <div class="stats-name" style="
              line-height:1;
              margin:0;
              padding:0;
            ">${otherName}</div>

            <div style="
              display:flex;
              align-items:flex-end;
              gap:6px;
              font-size:1.5rem;
              font-weight:700;
              line-height:1;
            ">
              <i data-lucide="medal" style="width:22px; height:22px;"></i>
              <span>${otherStreak}</span>
            </div>
          </div>
        `;

        html += barsHtml(otherHabits);
      }

      statsViewEl.innerHTML = html;
      // --- NAME-EDITIERUNG AKTIVIEREN ---
      const editableName = document.getElementById("editableName");

      editableName.addEventListener("click", () => {
        const current = editableName.textContent.trim();

        // Input erzeugen
        editableName.innerHTML = `
          <input id="nameEditInput"
                 type="text"
                 value="${current}"
                 style="
                   font-size:2rem;
                   font-weight:700;
                   border:none;
                   outline:none;
                   background:transparent;
                   border-bottom:2px solid #ccc;
                   width:100%;
                 "
          />
        `;

        const input = document.getElementById("nameEditInput");
        input.focus();
        input.setSelectionRange(current.length, current.length);

        async function save() {
          const newName = input.value.trim();
          if (!newName || newName === current) {
            editableName.textContent = current;
            return;
          }

          const { error } = await supabaseClient.auth.updateUser({
            data: { display_name: newName }
          });

          if (error) {
            console.error("Name update error:", error);
            editableName.textContent = current;
            return;
          }

          // UI aktualisieren
          editableName.textContent = newName;

          // Stats aktualisieren (optional)
          await refreshStatsLive();
        }

        input.addEventListener("blur", save);
        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            save();
          }
        });
      });
      lucide.createIcons();
    }

  async function refreshStatsLive() {
    if (!currentUser) return;

    const myHabits    = await loadHabitsForUser(currentUser.id);
    const otherHabits = otherUser ? await loadHabitsForUser(otherUser.id) : [];
    renderStats(myHabits, otherHabits, otherUser);
  }

  statsBtnEl.addEventListener("click", async () => {
    if (!currentUser) return;

    otherUser = await loadOtherUser();
    const [myHabits, otherHabits] = await Promise.all([
      loadHabitsForUser(currentUser.id),
      otherUser ? loadHabitsForUser(otherUser.id) : Promise.resolve([])
    ]);

    renderStats(myHabits, otherHabits, otherUser);

    statsOpen = true;
    addBtnEl.dataset.mode = "stats";
    refreshAddButtonIcon();
    gsap.to("#statsView",{top:0,duration:0.45,ease:"power1.out"});
  });

  // === Shake Detection + UNO-Wiggle/Hide ===

  let lastShakeTime = 0;
  const SHAKE_THRESHOLD = 18; // ggf. anpassen

  function setupShakeDetection() {
    if (typeof window === "undefined") return;
    if (!("DeviceMotionEvent" in window)) return;

    if (typeof DeviceMotionEvent !== "undefined" &&
        typeof DeviceMotionEvent.requestPermission === "function") {
      document.body.addEventListener("click", function reqOnce() {
        DeviceMotionEvent.requestPermission().catch(()=>{}).finally(()=>{
          document.body.removeEventListener("click", reqOnce);
        });
      });
    }

    window.addEventListener("devicemotion", handleDeviceMotion, false);
  }

  function handleDeviceMotion(event) {
    const acc = event.accelerationIncludingGravity || event.acceleration;
    if (!acc) return;

    const x = acc.x || 0;
    const y = acc.y || 0;
    const z = acc.z || 0;
    const magnitude = Math.sqrt(x*x + y*y + z*z);

    const now = Date.now();
    if (magnitude > SHAKE_THRESHOLD && now - lastShakeTime > 1200) {
      lastShakeTime = now;
      onShakeDetected();
    }
  }

  function onShakeDetected() {
    if (!habits || habits.length === 0) return;
    if (deletePanelVisible) return;

    showDeletePanelAndAnimateCards();
  }

  function showDeletePanelAndAnimateCards() {
    deletePanelVisible = true;
    clearTimeout(deleteTimeout);

    const cards = document.querySelectorAll(".card");
    const buttonsRow = document.querySelector(".buttons-row");
    if (!buttonsRow || cards.length === 0) return;

    const buttonsRect = buttonsRow.getBoundingClientRect();
    let panelTopBase = null;

    cards.forEach((card, idx) => {
      const rect = card.getBoundingClientRect();
      const targetTop = buttonsRect.top - rect.height / 2; // Karte halb hinter Buttons
      const dy = targetTop - rect.top;

      if (idx === 0) {
        panelTopBase = targetTop;
      }

      const tl = gsap.timeline();
      tl.to(card, { rotation:-2, duration:0.08, ease:"power1.out" })
        .to(card, { rotation:2, repeat:4, yoyo:true, duration:0.08, ease:"sine.inOut" })
        .to(card, { rotation:0, y:dy, duration:0.38, ease:"power2.out" }, "-=0.08");
    });

    // Panel anzeigen und direkt oberhalb der obersten Karte positionieren
    deletePanel.style.display = "flex";
    deletePanel.style.opacity = "0";

    requestAnimationFrame(() => {
      const panelHeight = deletePanel.offsetHeight || 24;
      let panelTop = 12;
      if (panelTopBase !== null) {
        panelTop = panelTopBase - panelHeight - 8;
        if (panelTop < 8) panelTop = 8;
      }
      deletePanel.style.top = panelTop + "px";

      gsap.to(deletePanel, {
        opacity:1,
        y:0,
        duration:0.25,
        ease:"power1.out"
      });
    });

    // nach 5 Sekunden Inaktivität wieder zurück animieren (ohne Löschen)
    deleteTimeout = setTimeout(() => {
      reverseShakeAnimation();
    }, 5000);
  }

  function reverseShakeAnimation() {
    if (!deletePanelVisible) return;
    deletePanelVisible = false;
    clearTimeout(deleteTimeout);

    const cards = document.querySelectorAll(".card");

    cards.forEach(card => {
      const tl = gsap.timeline();
      tl.to(card, {
          y: "-10",
          rotation: -2,
          duration: 0.12,
          ease: "power1.out"
        })
        .to(card, {
          y: 0,
          rotation: 0,
          duration: 0.28,
          ease: "power2.inOut"
        });
    });

    gsap.to(deletePanel, {
      opacity:0,
      y:4,
      duration:0.22,
      ease:"power1.in",
      onComplete: () => {
        deletePanel.style.display = "none";
        deletePanel.style.y = 0;
      }
    });
  }

  async function deleteAllHabits() {
    clearTimeout(deleteTimeout);

    if (currentUser && habits && habits.length > 0) {
      const ids = habits.map(h => h.id);
      const { error } = await supabaseClient
        .from("habits")
        .delete()
        .in("id", ids);

      if (error) {
        console.error("deleteAllHabits error:", error);
      }
    }

    habits = [];
    clearAllSlots();
    refreshAddButtonIcon();
    reverseShakeAnimation();
  }

  deleteAllBtn.addEventListener("click", () => {
    deleteAllHabits();
  });

  deletePanel.addEventListener("click", () => {
    // Optional: hier könnte man das Timeout abbrechen etc.
  });

  // Login-Kreis schwebend animieren
  startLoginCircleFloat();

  /*
    SQL zum Sicherstellen, dass die Spalte "color" existiert:

    ALTER TABLE public.habits
    ADD COLUMN IF NOT EXISTS color text DEFAULT '#e4e4e4';

    Aktiv-Status wird logisch abgeleitet über:
      progress > 0  => aktiv
      progress = 0  => inaktiv
  */
    
    async function requestAllPermissions() {
      // Notifications
      if (Notification.permission !== "granted") {
        await Notification.requestPermission();
      }

      // Motion
      if (typeof DeviceMotionEvent !== "undefined" &&
          typeof DeviceMotionEvent.requestPermission === "function") {
        await DeviceMotionEvent.requestPermission().catch(()=>{});
      }

      // Geo
      navigator.geolocation.getCurrentPosition(()=>{}, ()=>{}, {
        enableHighAccuracy: true
      });
    }

    requestAllPermissions();
    
    function urlBase64ToUint8Array(base64String) {
      const padding = '='.repeat((4 - base64String.length % 4) % 4);
      const base64 = (base64String + padding)
        .replace(/-/g, '+')
        .replace(/_/g, '/');

      const rawData = atob(base64);
      const outputArray = new Uint8Array(rawData.length);

      for (let i = 0; i < rawData.length; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
      }
      return outputArray;
    }

    async function subscribeUserToPush() {
      const reg = await navigator.serviceWorker.ready;

      const vapidKey = urlBase64ToUint8Array("BIuQ1Oi-yAKNjlbzj8r_wUjBY9Q1GRKzr7ZM_CM3ZDZOXHm0HllkPnX4s7H6AEKqIBpDvTdHqgLgo7VjpGW68f0");

      const sub = await reg.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: vapidKey
      });

      const { error } = await supabaseClient
        .from("push_subscriptions")
        .insert({
          user_id: currentUser.id,
          endpoint: sub.endpoint,
          p256dh: btoa(String.fromCharCode(...new Uint8Array(sub.getKey("p256dh")))),
          auth: btoa(String.fromCharCode(...new Uint8Array(sub.getKey("auth"))))
        });

      if (error) console.error("push subscribe error", error);
    }
    
    async function initPushAfterLogin() {
      await requestAllPermissions();
      await subscribeUserToPush();
    }
    
    function getQRParam() {
      const params = new URLSearchParams(window.location.search);
      return params.get("qr"); // z.B. ?qr=ABC123
    }
    
    // === QR CONFIRMATION HANDLER ===
    function askQRPermission(kcal) {
      return new Promise(resolve => {
        const overlay = document.getElementById("qrConfirmOverlay");
        const text    = document.getElementById("qrConfirmText");
        const yesBtn  = document.getElementById("qrConfirmYes");
        const noBtn   = document.getElementById("qrConfirmNo");

        text.textContent = `Soll der Wert "${kcal}" KCAL zu deiner QR-Karte hinzugefügt werden?`;

        overlay.style.display = "flex";

        yesBtn.onclick = () => {
          overlay.style.display = "none";
          resolve(true);
        };

        noBtn.onclick = () => {
          overlay.style.display = "none";
          resolve(false);
        };
      });
    }
    
    function isToday(dateStr) {
      if (!dateStr) return false;
      const d = new Date(dateStr);
      const today = new Date();

      return (
        d.getFullYear() === today.getFullYear() &&
        d.getMonth() === today.getMonth() &&
        d.getDate() === today.getDate()
      );
    }
    
    async function processQRFlow(qrId) {
      try {
        if (!qrId) return;

        // ---------------------------------------------------
        // 0. QR Parameter nach dem ersten Lesen entfernen
        //    → verhindert doppelten Trigger nach Login
        // ---------------------------------------------------
        if (window.history && window.history.replaceState) {
          const cleanUrl = window.location.origin + window.location.pathname;
          window.history.replaceState({}, "", cleanUrl);
        }

        // ---------------------------------------------------
        // 1. User sicherstellen
        // ---------------------------------------------------
        if (!currentUser) {
          const { data } = await supabaseClient.auth.getUser();
          currentUser = data?.user || null;
          if (!currentUser) return;
        }

        // ---------------------------------------------------
        // 2. QR-Code laden
        // ---------------------------------------------------
        const { data: qrRow, error: qrErr } = await supabaseClient
          .from("qr_codes")
          .select("*")
          .eq("code", qrId)
          .single();

        if (qrErr || !qrRow) return;

        const kcal = parseInt(qrRow.kcal_value) || 0;
        if (kcal <= 0) return;

        // ---------------------------------------------------
        // 3. Daily-Limit: nur 1x pro Tag
        // ---------------------------------------------------
        if (isToday(qrRow.last_scanned)) {
          return; // keine Meldung, einfach ignorieren
        }

        // ---------------------------------------------------
        // 4. Habit mit aktivem QR-Tracking holen
        // ---------------------------------------------------
        const { data: habit, error: hErr } = await supabaseClient
          .from("habits")
          .select("*")
          .eq("user_id", currentUser.id)
          .eq("qr_enabled", true)
          .limit(1)
          .maybeSingle();

        if (hErr || !habit) return;

        // ---------------------------------------------------
        // 5. Bestätigungsmodal anzeigen
        // ---------------------------------------------------
        const ok = await askQRPermission(kcal);
        if (!ok) return;

        // ---------------------------------------------------
        // 6. KCAL addieren
        // ---------------------------------------------------
        const newProgress = (parseInt(habit.progress) || 0) + kcal;

        const { error: updErr } = await supabaseClient
          .from("habits")
          .update({ progress: newProgress })
          .eq("id", habit.id);

        if (updErr) return;

        // ---------------------------------------------------
        // 7. Heute in QR-Code speichern
        // ---------------------------------------------------
        const today = new Date().toISOString().substring(0, 10);

        await supabaseClient
          .from("qr_codes")
          .update({ last_scanned: today })
          .eq("id", qrRow.id);

        // ---------------------------------------------------
        // 8. UI aktualisieren (aber NICHT erneut processQRFlow aufrufen)
        // ---------------------------------------------------
        await safeLoadHabits();
        showAppAfterDataLoaded();

      } catch (err) {
        console.error("processQRFlow fatal error:", err);
      }
    }
    

  
    
</script>

<!-- QR CONFIRMATION MODAL -->
<div id="qrConfirmOverlay" style="
  position:fixed;
  inset:0;
  background:rgba(0,0,0,0.35);
  backdrop-filter:blur(2px);
  display:none;
  justify-content:center;
  align-items:center;
  z-index:999999;
">
  <div id="qrConfirmBox" style="
    background:white;
    padding:24px;
    border-radius:20px;
    width:80%;
    max-width:340px;
    text-align:center;
    box-shadow:0 6px 20px rgba(0,0,0,0.2);
  ">
    <div id="qrConfirmText" style="
      font-size:18px;
      font-weight:600;
      margin-bottom:24px;
    ">
      Soll der Wert hinzugefügt werden?
    </div>

    <div style="display:flex; justify-content:center; gap:16px;">
      <button id="qrConfirmYes" style="
        flex:1;
        padding:12px;
        border-radius:12px;
        border:none;
        background:#000;
        color:white;
        font-size:16px;
        font-weight:600;
      ">Ja</button>

      <button id="qrConfirmNo" style="
        flex:1;
        padding:12px;
        border-radius:12px;
        border:none;
        background:#ef4444;
        color:white;
        font-size:16px;
        font-weight:600;
      ">Nein</button>
    </div>
  </div>
</div>
</body>
</html>
  
